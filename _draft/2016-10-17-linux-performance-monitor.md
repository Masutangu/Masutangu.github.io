---
layout: post
date: 2016-10-05T15:59:32+08:00
title: Linux 性能监控
category: 工作
---

本文是对 http://www.vpsee.com/2009/11/linux-system-performance-monitoring-introduction/ 系列文章的笔记，非原创。

https://www.thomas-krenn.com/en/wiki/Linux_Performance_Measurements_using_vmstat


## CPU
### vmstat 

#### 介绍

```
$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0 164412 143200  35916 243216    0    0    12    11   46   22  1  1 98  0  0
 0  0 164412 142960  35916 243260    0    0     0     0  583  854  2  1 97  0  0
 0  0 164412 142960  35916 243260    0    0     0     0  940 1184  2  1 97  0  0
```

参数说明：
* r: 	可运行队列的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用
* b: 	被 blocked 的进程数，正在等待 IO 请求
* in: 	被处理过的中断数
* cs: 	系统上正在做上下文切换的数目
* us: 	用户占用 CPU 的百分比
* sy: 	内核和中断占用 CPU 的百分比
* wa: 	所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比
* id: 	CPU 完全空闲的百分比

合理的参数范围：
* CPU 利用率：如果 CPU 达到 100％ 利用率，那么 us 和 sy 占比应该达到这样一个平衡：65％－70％ User Time，30％－35％ System Time，0％－5％ Idle Time
* 上下文切换：上下文切换应该和 CPU 利用率联系起来看，如果能保持上面的 CPU 利用率平衡，大量的上下文切换是可以接受的
* 可运行队列：每个处理器的可运行队列不应该超过3个线程，比如：双处理器系统的可运行队列里不应该超过6个线程


#### 例子
案例1:

```
vmstat 1
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0    140 2915476 341288 3951700  0    0     0     0 1057  523 19 81  0  0  0
 4  0    140 2915724 341296 3951700  0    0     0     0 1048  546 19 81  0  0  0
 4  0    140 2915848 341296 3951700  0    0     0     0 1044  514 18 82  0  0  0
 4  0    140 2915848 341296 3951700  0    0     0    24 1044  564 20 80  0  0  0
 4  0    140 2915848 341296 3951700  0    0     0     0 1060  546 18 82  0  0  0
```

上面的输出可以看出：
* system time（sy）一直保持在 80％ 以上，而且上下文切换较低（cs），说明某个进程可能一直霸占着 CPU
* run queue（r）刚好在4个

案例2:

```
vmstat 1
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
14  0    140 2904316 341912 3952308  0    0     0   460 1106 9593 36 64  1  0  0
17  0    140 2903492 341912 3951780  0    0     0     0 1037 9614 35 65  1  0  0
20  0    140 2902016 341912 3952000  0    0     0     0 1046 9739 35 64  1  0  0
17  0    140 2903904 341912 3951888  0    0     0    76 1044 9879 37 63  0  0  0
16  0    140 2904580 341912 3952108  0    0     0     0 1055 9808 34 65  1  0  0
```

上面的输出可以看出：
* context switch（cs）比 interrupts（in）要高得多，说明内核不得不来回切换进程
* 进一步观察发现 system time（sy）很高而 user time（us）很低，而且加上高频度的上下文切换（cs），说明正在运行的应用程序调用了大量的系统调用
* run queue（r）在14个线程以上，按照这个测试机器的硬件配置（四核），应该保持在12个以内。

### mpstat
mpstat 和 vmstat 类似，不同的是 mpstat 可以输出多个处理器的数据

### ps
ps 用于查看某个程序、进程占用的 CPU 资源

## 内存

kswapd daemon 用来检查 pages_high 和 pages_low，如果可用内存少于 pages_low，kswapd 就开始扫描并试图释放 32个页面，并且重复扫描释放的过程直到可用内存大于 pages_high 为止。

扫描的时候检查3件事：
* 如果页面没有修改，把页放到可用内存列表里
* 如果页面被文件系统修改，把页面内容写到磁盘上
* 如果页面被修改了，但不是被文件系统修改的，把页面写到交换空间

pdflush daemon 用来同步文件相关的内存页面，把内存页面及时同步到硬盘上。比如打开一个文件，文件被导入到内存里，对文件做了修改后并保存后，内核并不马上保存文件到硬盘，由 pdflush 决定什么时候把相应页面写入硬盘，这由一个内核参数 vm.dirty_background_ratio 来控制，比如下面的参数显示脏页面（dirty pages）达到所有内存页面10％的时候开始写入硬盘。

### vmstat

#### 介绍

```
$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0 164412 143200  35916 243216    0    0    12    11   46   22  1  1 98  0  0
 0  0 164412 142960  35916 243260    0    0     0     0  583  854  2  1 97  0  0
 0  0 164412 142960  35916 243260    0    0     0     0  940 1184  2  1 97  0  0
```

* swpd: 已使用的 SWAP 空间大小，KB 为单位
* free: 可用的物理内存大小，KB 为单位
* buff: 物理内存用来缓存读写操作的 buffer 大小，KB 为单位
* cache: 物理内存用来缓存进程地址空间的 cache 大小，KB 为单位
* si: 数据从 SWAP 读取到 RAM（swap in）的大小，KB 为单位
* so: 数据从 RAM 写到 SWAP（swap out）的大小，KB 为单位
* bi: 磁盘块从文件系统或 SWAP 读取到 RAM（blocks in）的大小，block 为单位
* bo: 磁盘块从 RAM 写到文件系统或 SWAP（blocks out）的大小，block 为单位

#### 例子

```
# vmstat 1
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  3 252696   2432    268   7148 3604 2368  3608  2372  288  288  0  0 21 78  1
 0  2 253484   2216    228   7104 5368 2976  5372  3036  930  519  0  0  0 100  0
 0  1 259252   2616    128   6148 19784 18712 19784 18712 3821 1853  0  1  3 95  1
 1  2 260008   2188    144   6824 11824 2584 12664  2584 1347 1174 14  0  0 86  0
 2  1 262140   2964    128   5852 24912 17304 24952 17304 4737 2341 86 10  0  0  4
```

上面是一个频繁读写交换区的例子，可以观察到：
* buff 稳步减少说明系统知道内存不够了，kwapd 正在从 buff 那里借用部分内存
* kswapd 持续把脏页面写到 swap 交换区（so），并且从 swapd 逐渐增加看出确实如此。根据上面讲的 kswapd 扫描时检查的三件事，如果页面被修改了，但不是被文件系统修改的，把页面写到 swap，所以这里 swapd 持续增加


free https://my.oschina.net/circleblog/blog/715711


## IO
 
## 常用工具汇总

|  		工具 	    |             		简单介绍						|
|----------------|-------------------------------------------------|
|  		top 	 |			查看进程活动状态以及一些系统状况			 |
| 	   vmstat	 | 			查看系统状态、硬件和系统信息等				  |
| 	   iostat	 |   			查看CPU 负载，硬盘状况				  |
| 		sar		 |  			综合工具，查看系统状况					 |
| 	   mpstat	 | 					查看多处理器状况				   |
| 	  netstat	 | 					查看网络状况						|
| 	   iptraf	 | 				   实时网络状况监测		   		       |
|     tcpdump	 |  			抓取网络数据包，详细分析				|
|     tcptrace	 | 					数据包分析工具  				   |
|     netperf	 | 					网络带宽工具						|
|       dstat	 |综合工具，综合了 vmstat, iostat, ifstat, netstat 等多个信息 |