---
layout: post
date: 2017-01-25T20:49:16+08:00
title: 《Linker And Loader》读书笔记
category: 读书笔记
---

http://blog.jobbole.com/96225/#sharedlibs_chs

# Chapter 1. Linking and Loading

链接器和加载器的基本工作是：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。

在有操作系统之前，一个程序可以支配机器所有的内存，由于知道计算机中所有的地址都是可用的，因此它能以固定的内存地址来汇编和链接。但有了操作系统后，程序就必须和操作系统甚至其他程序共享计算机的内存。这意味着操作系统将程序加载到内存之前无法确定程序运行的确切地址，并将最终的地址绑定从链接时推延到加载时。链接器对每一个程序的部分地址进行绑定并分配相对地址，加载器赋予最终的实际地址。

随着硬件重定位和虚拟内存的出现，每个程序可以再次拥有整个地址空间。由于硬件重定位能处理任何加载时的重定位，程序可以以加载到固定地址的方式来链接。但是具有硬件重定位功能的计算机往往不止运行一个程序，而且经常运行同一个程序的多个副本。当运行一个程序的多个实例时，程序中的某些部分在所有运行实例都是相同的（尤其是可执行代码）。如果不变的部分可以分离出来，操作系统就可以只使用一份不变部分的副本，节省存储空间。编译器和汇编器被修改为可以创建多个段的目标代码，为只读代码分配一个段，为其他可写数据分配另外的段。链接器必须能够将所有段合并在一起。

在简单的静态共享库中，每个库在创建时会被绑定到特定的地址，链接器在链接时将程序中引用的库例程绑定到这些特定的地址。由于静态库中任何部分变化时都需要重新链接，因此又出现了动态链接库。使用动态链接库的程序在开始运行之前不会将所用库中的段和符号绑定到确切的地址上。在完全的动态链接中，被调用的例程的地址在第一次调用前都不会被绑定。此外在程序运行过程中也可以加载库并进行绑定。

链接器和加载器完成几个相关但概念上不同的动作：

* 程序加载：将程序从辅助存储设备拷贝到主内存中准备运行。在某些情况下，加载仅仅是将数据从磁盘拷入内存。在其他情况下，还包括分配存储空间，设置保护位或通过虚拟内存将虚拟地址映射到磁盘内存页上。
* 重定位：编译器和汇编器通常为每个文件创建程序地址从 0 开始的目标代码。如果程序是由多个子程序组成，那必须加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。很多系统中，重定向不止进行一次。对于链接器的一种普遍情景是由多个子程序来构建一个程序，并生成一个链接好的起始地址为 0 的输出程序，各个子程序通过重定位在大程序中确定位置。当这个程序被加载时，系统会选择一个加载地址，而链接好的程序会作为整体被重定位到加载地址。
* 符号解析：当通过多个子程序来构建一个程序时，子程序间的相互引用是通过符号进行的。程序可能会调用一个名为 sqrt 的计算平方根例程，并且数学库中定义了 sqrt 例程。链接器通过标明分配给 sqrt 的地址在库中来解析这个符号，并通过修改目标代码使得 call 指令引用该地址。

链接器将一系列的目标文件、库及可能的命令文件作为它的输入，然后将输出的目标文件作为结果，此外可能还有加载映射信息或调试器符号文件的副产品。

每个输入文件都包含一系列的段（segments），即会被连续存放在输出文件中的代码或数据块。每一个输入文件至少还包含一个符号表（symbol table）。有一些符号是导出符号，他们在当前文件中定义并在其他文件中使用，通常都是可以在其它地方被调用的当前文件内例程的名字。另外还有导入符号，在当前文件中使用但不在当前文件中定义，通常都是在该文件中调用但不存在于该文件中的例程的名字。

当链接器运行时，会首先对输入文件进行扫描，得到各个段的大小，并收集对所有符号的定义和引用。它会创建一个列出输入文件中定义的所有段的段表，和包含所有导出、导入符号的符号表。

利用第一遍扫描得到的数据，链接器可以为符号分配数字地址，决定各个段在输出地址空间中的大小和位置，并确定每一部分在输出文件中的布局。

第二遍扫描会利用第一遍扫描中收集的信息来控制实际的链接过程。它会读取并重定位目标代码，替换符号引用的数字地址，调整代码和数据的内存地址以反映重定位的段地址，并将重定位后的代码写入到输出文件中。通常还会再向输出文件中写入文件头部信息，重定位的段和符号表信息。如果程序使用了动态链接，那么符号表中还要包含运行时链接器解析动态符号时所需的信息。
指向各初始化例程的函数指针数组。

链接器和加载器的核心动作是重定位和代码修改。当编译器或汇编器产生一个目标代码文件时，它使用文件中定义的未重定位代码地址和数据地址来生成代码，对于其它地方定义的数据或代码通常就是 0。作为链接过程的一部分，链接器会修改目标代码以反映实际分配的地址。

# Chapter 2. Architectural Issues

硬件体系结构的两个方面影响到链接器：**程序寻址**和**指令格式**。链接器需要做的事情之一就是对数据和指令中的地址及偏移量都要进行修改。


## Application Binary Interfaces

每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口（Application Binary Interface）。ABI 由应用程序在这个系统下运行时必须遵守的编程约定组成。ABI 总是包含一系列的系统调用和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看，ABI 既是系统架构的一部分也是硬件体系结构。

### 指令格式

每种体系结构都有一些不同的指令格式。每条指令都包含一个操作码，它决定了指令做什么，此外还有一个操作数。操作数可以被编码到指令本身(立即操作数)，或者放置在内存中。内存中每个操作数的地址总要经过一些计算，有时地址包含在指令中（直接寻址），更经常的是地址存储在某一个寄存器中（寄存器间接寻址），或通过将指令中的一个常量加上寄存器中的内容计算得来。如果寄存器中的值是一个存储区域的地址，而指令中的常量是存储区域中想要访问的数据的偏移量，这种策略称为基址寻址。如果二者调换过来，寄存器中保存的是偏移量，那这种策略就是索引寻址。

### 过程调用和可寻址性

在最早的计算机中内存很小，指令中的地址域足够容纳计算机任何一个内存位置的地址，现在我们称这种策略为直接寻址。在上世纪 60 年代早期，可寻址内存已经变得相当大，如果指令集中每个指令都包含整个地址将占用太多宝贵的内存。为了解决这个问题，计算机的架构师们在地址引用指令中部分或彻底的放弃了直接寻址，使用索引和基址寄存器来提供寻址所需的大部分或全部地址位。

#### 过程调用

每种 ABI 都通过将硬件定义的调用指令与内存、寄存器的使用约定组合起来定义了一个标准的过程调用序列。硬件的调用指令保存了返回地址（调用执行后的指令地址）并跳转到目标过程。在诸如 x86 这样具有硬件栈的体系结构中返回地址被压入栈中，而在其它体系结构中它会被保存在一个寄存器里，如果必要软件要负责将寄存器中的值保存在内存中。具有栈的体系结构通常都会有一个硬件的返回指令将返回地址推出栈并跳转到该地址，而其它体系结构则使用一个“跳转到寄存器中地址”的指令来返回。

在一个过程的内部，数据寻址可分为 4 类：

* 调用者可以向过程传递参数
* 本地变量在过程中分配，并在过程返回前释放
* 本地静态数据保存在内存的固定位置中，并为该过程私有
* 全局静态数据保存在内存的固定位置中，并可被很多不同过程引用 

为每个过程调用分配的一块栈内存称为“栈框架(stack frame)”。下图显示了一个典型的栈框架：

<img src="/assets/images/linker-and-loader-note/illustration-1.png" width="800" />

相关资料：[《X86汇编调用框架浅析与CFI简介》](http://larmbr.com/2013/09/20/x86-assembly-call-frame-and-dwarf-CFI-introduction/)

对于局部和全局静态数据，编译器可以为一个例程引用的所有静态变量创建一个指针表。如果某个寄存器存有指向这个表的指针，那么例程可以通过使用表指针寄存器将对象在表中的指针读取出来，加载到另一个使用表指针寄存器作为基址的寄存器中，并将第二个寄存器做为基址寄存器来寻址任何想要访问的静态目标。

### 数据和指令引用

下面更具体的看看 3 种体系结构中寻址数据的方法。

#### IBM 370

每个引用数据内存的指令通过将指令中 12 位无符号的偏移量与基址寄存器（也可能是索引寄存器）相加来计算地址。有 16 个通用寄存器，每个均为 32 位，编号从 0 到 15。除了一个之外其余的都可以用作索引寄存器。如果寄存器 0 在地址计算中被指定，那么将使用数值 0 而非寄存器本身的内容（寄存器 0 存在且可以用于计算，但不能用于寻址）。在那些需要从寄存器中读取跳转目标地址的指令而言，寄存器 0 意味着不跳转。

下图所示为主要的指令格式。

RR 为通用寄存器型指令，参加运算的操作数都来自通用寄存器中，运算结果也放在通用寄存器中。指令字长只需要 16 位，一个存储字中可以放两条 RR 型指令。

RX 型为变址型指令，参加运算的一个操作数来自内存，并采用变址寻址方式，通过将指令中的偏移量与基址寄存器和索引寄存器相加得来。多数情况下索引寄存器的数值为 0，这时地址恰好是基址加偏移量。另一个操作数来自通用寄存器，运算结果放入通用寄存器中。指令字长为32位，正好一个存储字。

RS 型指令可用来在通用寄存器与内存之间一次传送多个数据。Rn 为起始通用寄存器编号，Rm 为结束通用寄存器编号，只要用一条指令就能把通用寄存器中从 Rn 开始到 Rm 结束的所有数据都存入相邻的内存单元中，同样，也可以从内存的相邻单元读出多个数据到通用寄存器中。在程序调用和中断处理时，用这种指令可以快速保存和恢复程序现场。
　
SI 型指令的一个操作数在内存中，另一个操作数为立即数。立即数的长度为8位，当然，立即数只能是第二操作数。SS 型指令的两个操作数都在内存中，并且支持"串"操作。如字符串运算，十进制运算等，也可以用来把长度不超过256个字节的数据块从内存的一个区域搬到另一个区域。 

<img src="/assets/images/linker-and-loader-note/illustration-2.png" width="800" />

注意在所有的三类指令格式中，12 位的偏移量永远存储在一个 16 位对齐的半个字的低 12 位中。这就可以在修改目标文件中特定的地址偏移量时不需考虑任何对指令格式的引用，因为偏移量格式都是相同的。

370 的指令寻址也是相当简洁的。在最初的 360 中，跳转指令（经常是指分支指令）都是 RR 或 RX 格式的。在 RR 格式的跳转中，第二个寄存器操作数存有跳转目标，如果是寄存器 0 意味着不进行跳转。在 RX 格式的跳转中，内存操作数是跳转的目标。过程调用是“分支” 和“链接”，它将返回地址存储在特定的寄存器，若是 RR 格式则跳转到第二个寄存器中的地址，若是 RX 格式则跳转到第二个操作数中的地址。

#### SPARC

SPARC 有四种主要指令格式和 31 种次要指令格式。SPARC 直到 V8 版本都是 32 位架构, SPARC V9扩展为64位架构。

##### SPARC V8

在 SPARC V8 中有 31 个通用寄存器，每个 32 位，从 1 到 31 编号。寄存器 0 是一个数值总为 0 的伪寄存器。

数据引用会使用两种寻址模式中的二者之一。一种模式通过将两个寄存器的数值加在一起来计算地址（如果一个寄存器中已经有想要的目的地址，那么另一个寄存器可以是寄存器 0）。另一种模式会将指令中的 13 位有符号偏移量与一个基址寄存器相加。

SPARC 的汇编器和链接器通过一个双指令序列支持一种伪直接寻址策略。这两个指令是 SETHI，它将一个 22 位的立即数装入一个寄存器的高 22 位并使其低 10 位为 0，接着是一个 OR 指令将自己的 13 位立即数通过“或运算”加入到寄存器的低 13 位。

##### SPARC V9

SPARC V9 将所有的寄存器扩展为 64 位,使用寄存器的低 32 位来兼容旧的 32 位程序。 所有已存在的指令仍然按以前的方式工作，除了寄存器已经由 32 位扩展为 64 位了。

##### Intel x86

Intel x86是目前我们讨论的三种体系结构中最复杂的。它具有一个不对称的指令集和分段的地址空间。有 6 个 32 位通用寄存器名为 EAX、EBX、ECX、EDX、ESI 和 EDI，同时还有两个主要用于寻址的寄存器，EBP 和 ESP，六个专门的 16 位段寄存器 CS、DS、ES、FS、GS 和 SS。每个 32 位的寄存器的低半部可以当做 16 位寄存器使用，称为 AX、BX、CX、DX、SI、DI、BP 和 SP。从 AX 到 DX 寄存器的低 8 位和高 8 位又可以作为 8 位寄存器，称为 AL、AH、BL、BH、 CL、CH、DL 和 DH。

ESP 是硬件栈指针，总是保存着当前栈的地址。EBP 通常做为框架寄存器来使用，指向当前栈框架的基地址。

### 分页和虚拟内存

对于 32 位寻址和使用 4K 页的 x86，需要一个具有 220 个项的页表来覆盖整个地址空间。由于每个页表项通常为 4 字节，这会使页表的大小变成不切实际的 4MB。因此，可分页的架构会通过将高层次页表指向那些最终映射到虚拟地址所对应的物理页框的低层次页表来实现对页表的再次分页。

#### 程序地址空间

每个程序都运行在一个由计算机硬件和操作系统共同定义的地址空间中。链接器和加载器需要生成与这个地址空间匹配的可运行程序。Unix 系统将每个程序都放置在单独的地址空间中，而操作系统运行在与应用程序在逻辑上隔离的地址空间中。

#### 映射文件

虚拟内存系统在真实内存和硬盘之间来回移动数据，当数据无法保存在内存中时就会将它交换到磁盘上。

> 与虚拟内存的区别？读这篇文章[<认真分析mmap：是什么 为什么 怎么用>](http://www.cnblogs.com/huxiao-tee/p/4660352.html)
> 常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。

处理对映射文件的写操作有三种不同的方法。最简单的办法是将文件以只读方式（RO）映射，任何对映射文件存储数据的操作都会失败，这通常会导致程序终止。第二种方法是将文件以可读写方式（RW）映射，这样对映射文件在内存中副本的修改会在取消映射的时候写回磁盘上。第三种方法是将文件以写时复制方式（COW）映射，这种情况下操作系统会对该页面做一个副本，这个副本会被当作没有映射的私有页来对待。

#### 共享库和程序

如果单一的程序或单一的程序库在多于一个的地址空间中被使用，若能够在多个地址空间中共享这个程序或程序库的单一副本，那将节省大量的内存。对于操作系统实现这个功能是相当简捷的——只需要将可执行程序文件映射到每一个程序的地址空间即可。操作系统还可以让所有映射到该文件的进程之间共享 RO 和尚未被写的 COW 数据对应的物理页框（如果代码在加载时需要重定位，重定位过程会修改代码页，那他们就必须被当作 COW 对待,而不是 RO）。

#### 位置无关代码

当一个程序在多个不同的地址空间运行时，操作系统通常可以将程序加载到各地址空间的相同位置。这样可以让链接器将程序中所有的地址绑定到固定的位置且在程序加载时不需要进行重定位，因此链接器的工作简单了很多。

共享库使情况变得相当复杂。在一些简单的共享库设计中，每一个库会在系统引导时或库被建立时分配一个全局唯一的内存地址。这可以让每一个库放置在固定的位置上，但由于库内存地址的全局列表需要由系统管理员维护这就给共享库的管理带来了严重的瓶颈。再进一步，如果一个库的新版本比之前的版本尺寸大且无法保存在先前分配的位置，那么整个共享库，以及引用这些库的程序都需要被重新链接。

一个简单的方法是在库中包含标准的重定位信息，在库被映射到各个地址空间时，加载器可以修改程序中的任何重定位地址以反映库被加载的位置。不幸的是，修改的过程会导致对库的代码和数据的修改，这意味着若它是按照 COW 方式映射的则对应的页不能再被共享，或它是按照 RO 方式映射的则会导致程序的崩溃。

为了避免这种情况，共享库使用了位置无关代码（PIC:Position Independnet Code），这是无论被加载到内存中的任何位置都可以正常工作的代码。共享库中的代码通常都是位置无关代码，这样代码可以以 RO 方式映射。数据页仍然带有需要被重定位的指针，但由于数据页将以 COW 方式映射，因此这里对共享不会有什么损失。

对于大部分计算机系统，位置无关代码是非常容易创建的。本章中讨论的三种体系结构都使用相对跳转，因此例程中的跳转指令无需重定位。对栈上的本地数据引用是基于基址寄存器的相对寻址，因此也不需重定位。仅有的挑战在于对那些不在共享库中的例程的调用，以及对全局数据的引用。

### Intel 386分段

一个运行中的 x86 程序由四个段寄存器定义了四个活动段。CS 寄存器定义了代码段，用来指示指令获取的位置。DS 寄存器定义了数据段，用来指示多数数据被读取和存储的位置。SS 寄存器定义了栈段，这对 PUSH 和 POP 指令的操作数是有用的，程序的返回地址会通过 call 和 return 指令被压入和弹出栈中，以 EBP 或 ESP 为基址寄存器可以完成对任何数据的引用。ES 寄存器定义了扩展段，会被一些新的字串操作指令所用到。

# Chapter 3. Object Files

编译器和汇编器创建了目标文件（包含由源程序生成的二进制代码和数据）。链接器将多个目标文件合并成一个,加载器读取这些目标文件并将它们加载到内存中