---
layout: post
date: 2017-01-25T20:49:16+08:00
title: 《Linker And Loader》读书笔记
category: 读书笔记
---

http://blog.jobbole.com/96225/#sharedlibs_chs

# Chapter 1. Linking and Loading

链接器和加载器的基本工作是：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。

在有操作系统之前，一个程序可以支配机器所有的内存，由于知道计算机中所有的地址都是可用的，因此它能以固定的内存地址来汇编和链接。但有了操作系统后，程序就必须和操作系统甚至其他程序共享计算机的内存。这意味着操作系统将程序加载到内存之前无法确定程序运行的确切地址，并将最终的地址绑定从链接时推延到加载时。链接器对每一个程序的部分地址进行绑定并分配相对地址，加载器赋予最终的实际地址。

随着硬件重定位和虚拟内存的出现，每个程序可以再次拥有整个地址空间。由于硬件重定位能处理任何加载时的重定位，程序可以以加载到固定地址的方式来链接。但是具有硬件重定位功能的计算机往往不止运行一个程序，而且经常运行同一个程序的多个副本。当运行一个程序的多个实例时，程序中的某些部分在所有运行实例都是相同的（尤其是可执行代码）。如果不变的部分可以分离出来，操作系统就可以只使用一份不变部分的副本，节省存储空间。编译器和汇编器被修改为可以创建多个段的目标代码，为只读代码分配一个段，为其他可写数据分配另外的段。链接器必须能够将所有段合并在一起。

在简单的静态共享库中，每个库在创建时会被绑定到特定的地址，链接器在链接时将程序中引用的库例程绑定到这些特定的地址。由于静态库中任何部分变化时都需要重新链接，因此又出现了动态链接库。使用动态链接库的程序在开始运行之前不会将所用库中的段和符号绑定到确切的地址上。在完全的动态链接中，被调用的例程的地址在第一次调用前都不会被绑定。此外在程序运行过程中也可以加载库并进行绑定。

链接器和加载器完成几个相关但概念上不同的动作：

* 程序加载：将程序从辅助存储设备拷贝到主内存中准备运行。在某些情况下，加载仅仅是将数据从磁盘拷入内存。在其他情况下，还包括分配存储空间，设置保护位或通过虚拟内存将虚拟地址映射到磁盘内存页上。
* 重定位：编译器和汇编器通常为每个文件创建程序地址从 0 开始的目标代码。如果程序是由多个子程序组成，那必须加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。很多系统中，重定向不止进行一次。对于链接器的一种普遍情景是由多个子程序来构建一个程序，并生成一个链接好的起始地址为 0 的输出程序，各个子程序通过重定位在大程序中确定位置。当这个程序被加载时，系统会选择一个加载地址，而链接好的程序会作为整体被重定位到加载地址。
* 符号解析：当通过多个子程序来构建一个程序时，子程序间的相互引用是通过符号进行的。程序可能会调用一个名为 sqrt 的计算平方根例程，并且数学库中定义了 sqrt 例程。链接器通过标明分配给 sqrt 的地址在库中来解析这个符号，并通过修改目标代码使得 call 指令引用该地址。

链接器将一系列的目标文件、库及可能的命令文件作为它的输入，然后将输出的目标文件作为结果，此外可能还有加载映射信息或调试器符号文件的副产品。

每个输入文件都包含一系列的段（segments），即会被连续存放在输出文件中的代码或数据块。每一个输入文件至少还包含一个符号表（symbol table）。有一些符号是导出符号，他们在当前文件中定义并在其他文件中使用，通常都是可以在其它地方被调用的当前文件内例程的名字。另外还有导入符号，在当前文件中使用但不在当前文件中定义，通常都是在该文件中调用但不存在于该文件中的例程的名字。

当链接器运行时，会首先对输入文件进行扫描，得到各个段的大小，并收集对所有符号的定义和引用。它会创建一个列出输入文件中定义的所有段的段表，和包含所有导出、导入符号的符号表。

利用第一遍扫描得到的数据，链接器可以为符号分配数字地址，决定各个段在输出地址空间中的大小和位置，并确定每一部分在输出文件中的布局。

第二遍扫描会利用第一遍扫描中收集的信息来控制实际的链接过程。它会读取并重定位目标代码，替换符号引用的数字地址，调整代码和数据的内存地址以反映重定位的段地址，并将重定位后的代码写入到输出文件中。通常还会再向输出文件中写入文件头部信息，重定位的段和符号表信息。如果程序使用了动态链接，那么符号表中还要包含运行时链接器解析动态符号时所需的信息。
指向各初始化例程的函数指针数组。

链接器和加载器的核心动作是重定位和代码修改。当编译器或汇编器产生一个目标代码文件时，它使用文件中定义的未重定位代码地址和数据地址来生成代码，对于其它地方定义的数据或代码通常就是 0。作为链接过程的一部分，链接器会修改目标代码以反映实际分配的地址。

# Chapter 2. Architectural Issues

硬件体系结构的两个方面影响到链接器：**程序寻址**和**指令格式**。链接器需要做的事情之一就是对数据和指令中的地址及偏移量都要进行修改。


## Application Binary Interfaces

每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口（Application Binary Interface）。ABI 由应用程序在这个系统下运行时必须遵守的编程约定组成。ABI 总是包含一系列的系统调用和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看，ABI 既是系统架构的一部分也是硬件体系结构。

### 指令格式

每种体系结构都有一些不同的指令格式。每条指令都包含一个操作码，它决定了指令做什么，此外还有一个操作数。操作数可以被编码到指令本身(立即操作数)，或者放置在内存中。内存中每个操作数的地址总要经过一些计算，有时地址包含在指令中（直接寻址），更经常的是地址存储在某一个寄存器中（寄存器间接寻址），或通过将指令中的一个常量加上寄存器中的内容计算得来。如果寄存器中的值是一个存储区域的地址，而指令中的常量是存储区域中想要访问的数据的偏移量，这种策略称为基址寻址。如果二者调换过来，寄存器中保存的是偏移量，那这种策略就是索引寻址。

### 过程调用和可寻址性

在最早的计算机中内存很小，指令中的地址域足够容纳计算机任何一个内存位置的地址，现在我们称这种策略为直接寻址。在上世纪 60 年代早期，可寻址内存已经变得相当大，如果指令集中每个指令都包含整个地址将占用太多宝贵的内存。为了解决这个问题，计算机的架构师们在地址引用指令中部分或彻底的放弃了直接寻址，使用索引和基址寄存器来提供寻址所需的大部分或全部地址位。

#### 过程调用

每种 ABI 都通过将硬件定义的调用指令与内存、寄存器的使用约定组合起来定义了一个标准的过程调用序列。硬件的调用指令保存了返回地址（调用执行后的指令地址）并跳转到目标过程。在诸如 x86 这样具有硬件栈的体系结构中返回地址被压入栈中，而在其它体系结构中它会被保存在一个寄存器里，如果必要软件要负责将寄存器中的值保存在内存中。具有栈的体系结构通常都会有一个硬件的返回指令将返回地址推出栈并跳转到该地址，而其它体系结构则使用一个“跳转到寄存器中地址”的指令来返回。

在一个过程的内部，数据寻址可分为 4 类：

* 调用者可以向过程传递参数
* 本地变量在过程中分配，并在过程返回前释放
* 本地静态数据保存在内存的固定位置中，并为该过程私有
* 全局静态数据保存在内存的固定位置中，并可被很多不同过程引用 

为每个过程调用分配的一块栈内存称为“栈框架(stack frame)”。下图显示了一个典型的栈框架：

<img src="/assets/images/linker-and-loader-note/illustration-1.png" width="800" />

相关资料：[《X86汇编调用框架浅析与CFI简介》](http://larmbr.com/2013/09/20/x86-assembly-call-frame-and-dwarf-CFI-introduction/)

对于局部和全局静态数据，编译器可以为一个例程引用的所有静态变量创建一个指针表。如果某个寄存器存有指向这个表的指针，那么例程可以通过使用表指针寄存器将对象在表中的指针读取出来，加载到另一个使用表指针寄存器作为基址的寄存器中，并将第二个寄存器做为基址寄存器来寻址任何想要访问的静态目标。

### 数据和指令引用

下面更具体的看看 3 种体系结构中寻址数据的方法。

#### IBM 370

每个引用数据内存的指令通过将指令中 12 位无符号的偏移量与基址寄存器（也可能是索引寄存器）相加来计算地址。有 16 个通用寄存器，每个均为 32 位，编号从 0 到 15。除了一个之外其余的都可以用作索引寄存器。如果寄存器 0 在地址计算中被指定，那么将使用数值 0 而非寄存器本身的内容（寄存器 0 存在且可以用于计算，但不能用于寻址）。在那些需要从寄存器中读取跳转目标地址的指令而言，寄存器 0 意味着不跳转。

下图所示为主要的指令格式。

RR 为通用寄存器型指令，参加运算的操作数都来自通用寄存器中，运算结果也放在通用寄存器中。指令字长只需要 16 位，一个存储字中可以放两条 RR 型指令。

RX 型为变址型指令，参加运算的一个操作数来自内存，并采用变址寻址方式，通过将指令中的偏移量与基址寄存器和索引寄存器相加得来。多数情况下索引寄存器的数值为 0，这时地址恰好是基址加偏移量。另一个操作数来自通用寄存器，运算结果放入通用寄存器中。指令字长为32位，正好一个存储字。

RS 型指令可用来在通用寄存器与内存之间一次传送多个数据。Rn 为起始通用寄存器编号，Rm 为结束通用寄存器编号，只要用一条指令就能把通用寄存器中从 Rn 开始到 Rm 结束的所有数据都存入相邻的内存单元中，同样，也可以从内存的相邻单元读出多个数据到通用寄存器中。在程序调用和中断处理时，用这种指令可以快速保存和恢复程序现场。
　
SI 型指令的一个操作数在内存中，另一个操作数为立即数。立即数的长度为8位，当然，立即数只能是第二操作数。SS 型指令的两个操作数都在内存中，并且支持"串"操作。如字符串运算，十进制运算等，也可以用来把长度不超过256个字节的数据块从内存的一个区域搬到另一个区域。 

<img src="/assets/images/linker-and-loader-note/illustration-2.png" width="800" />

注意在所有的三类指令格式中，12 位的偏移量永远存储在一个 16 位对齐的半个字的低 12 位中。这就可以在修改目标文件中特定的地址偏移量时不需考虑任何对指令格式的引用，因为偏移量格式都是相同的。

370 的指令寻址也是相当简洁的。在最初的 360 中，跳转指令（经常是指分支指令）都是 RR 或 RX 格式的。在 RR 格式的跳转中，第二个寄存器操作数存有跳转目标，如果是寄存器 0 意味着不进行跳转。在 RX 格式的跳转中，内存操作数是跳转的目标。过程调用是“分支” 和“链接”，它将返回地址存储在特定的寄存器，若是 RR 格式则跳转到第二个寄存器中的地址，若是 RX 格式则跳转到第二个操作数中的地址。

#### SPARC

SPARC 有四种主要指令格式和 31 种次要指令格式。SPARC 直到 V8 版本都是 32 位架构, SPARC V9扩展为64位架构。

##### SPARC V8

在 SPARC V8 中有 31 个通用寄存器，每个 32 位，从 1 到 31 编号。寄存器 0 是一个数值总为 0 的伪寄存器。

数据引用会使用两种寻址模式中的二者之一。一种模式通过将两个寄存器的数值加在一起来计算地址（如果一个寄存器中已经有想要的目的地址，那么另一个寄存器可以是寄存器 0）。另一种模式会将指令中的 13 位有符号偏移量与一个基址寄存器相加。

SPARC 的汇编器和链接器通过一个双指令序列支持一种伪直接寻址策略。这两个指令是 SETHI，它将一个 22 位的立即数装入一个寄存器的高 22 位并使其低 10 位为 0，接着是一个 OR 指令将自己的 13 位立即数通过“或运算”加入到寄存器的低 13 位。

##### SPARC V9

SPARC V9 将所有的寄存器扩展为 64 位,使用寄存器的低 32 位来兼容旧的 32 位程序。 所有已存在的指令仍然按以前的方式工作，除了寄存器已经由 32 位扩展为 64 位了。

##### Intel x86

Intel x86是目前我们讨论的三种体系结构中最复杂的。它具有一个不对称的指令集和分段的地址空间。有 6 个 32 位通用寄存器名为 EAX、EBX、ECX、EDX、ESI 和 EDI，同时还有两个主要用于寻址的寄存器，EBP 和 ESP，六个专门的 16 位段寄存器 CS、DS、ES、FS、GS 和 SS。每个 32 位的寄存器的低半部可以当做 16 位寄存器使用，称为 AX、BX、CX、DX、SI、DI、BP 和 SP。从 AX 到 DX 寄存器的低 8 位和高 8 位又可以作为 8 位寄存器，称为 AL、AH、BL、BH、 CL、CH、DL 和 DH。

ESP 是硬件栈指针，总是保存着当前栈的地址。EBP 通常做为框架寄存器来使用，指向当前栈框架的基地址。

### 分页和虚拟内存

对于 32 位寻址和使用 4K 页的 x86，需要一个具有 220 个项的页表来覆盖整个地址空间。由于每个页表项通常为 4 字节，这会使页表的大小变成不切实际的 4MB。因此，可分页的架构会通过将高层次页表指向那些最终映射到虚拟地址所对应的物理页框的低层次页表来实现对页表的再次分页。

#### 程序地址空间

每个程序都运行在一个由计算机硬件和操作系统共同定义的地址空间中。链接器和加载器需要生成与这个地址空间匹配的可运行程序。Unix 系统将每个程序都放置在单独的地址空间中，而操作系统运行在与应用程序在逻辑上隔离的地址空间中。

#### 映射文件

虚拟内存系统在真实内存和硬盘之间来回移动数据，当数据无法保存在内存中时就会将它交换到磁盘上。

> 与虚拟内存的区别？读这篇文章[<认真分析mmap：是什么 为什么 怎么用>](http://www.cnblogs.com/huxiao-tee/p/4660352.html)
> 常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。

处理对映射文件的写操作有三种不同的方法。最简单的办法是将文件以只读方式（RO）映射，任何对映射文件存储数据的操作都会失败，这通常会导致程序终止。第二种方法是将文件以可读写方式（RW）映射，这样对映射文件在内存中副本的修改会在取消映射的时候写回磁盘上。第三种方法是将文件以写时复制方式（COW）映射，这种情况下操作系统会对该页面做一个副本，这个副本会被当作没有映射的私有页来对待。

#### 共享库和程序

如果单一的程序或单一的程序库在多于一个的地址空间中被使用，若能够在多个地址空间中共享这个程序或程序库的单一副本，那将节省大量的内存。对于操作系统实现这个功能是相当简捷的——只需要将可执行程序文件映射到每一个程序的地址空间即可。操作系统还可以让所有映射到该文件的进程之间共享 RO 和尚未被写的 COW 数据对应的物理页框（如果代码在加载时需要重定位，重定位过程会修改代码页，那他们就必须被当作 COW 对待,而不是 RO）。

#### 位置无关代码

当一个程序在多个不同的地址空间运行时，操作系统通常可以将程序加载到各地址空间的相同位置。这样可以让链接器将程序中所有的地址绑定到固定的位置且在程序加载时不需要进行重定位，因此链接器的工作简单了很多。

共享库使情况变得相当复杂。在一些简单的共享库设计中，每一个库会在系统引导时或库被建立时分配一个全局唯一的内存地址。这可以让每一个库放置在固定的位置上，但由于库内存地址的全局列表需要由系统管理员维护这就给共享库的管理带来了严重的瓶颈。再进一步，如果一个库的新版本比之前的版本尺寸大且无法保存在先前分配的位置，那么整个共享库，以及引用这些库的程序都需要被重新链接。

一个简单的方法是在库中包含标准的重定位信息，在库被映射到各个地址空间时，加载器可以修改程序中的任何重定位地址以反映库被加载的位置。不幸的是，修改的过程会导致对库的代码和数据的修改，这意味着若它是按照 COW 方式映射的则对应的页不能再被共享，或它是按照 RO 方式映射的则会导致程序的崩溃。

为了避免这种情况，共享库使用了位置无关代码（PIC:Position Independnet Code），这是无论被加载到内存中的任何位置都可以正常工作的代码。共享库中的代码通常都是位置无关代码，这样代码可以以 RO 方式映射。数据页仍然带有需要被重定位的指针，但由于数据页将以 COW 方式映射，因此这里对共享不会有什么损失。

对于大部分计算机系统，位置无关代码是非常容易创建的。本章中讨论的三种体系结构都使用相对跳转，因此例程中的跳转指令无需重定位。对栈上的本地数据引用是基于基址寄存器的相对寻址，因此也不需重定位。仅有的挑战在于对那些不在共享库中的例程的调用，以及对全局数据的引用。

### Intel 386分段

一个运行中的 x86 程序由四个段寄存器定义了四个活动段。CS 寄存器定义了代码段，用来指示指令获取的位置。DS 寄存器定义了数据段，用来指示多数数据被读取和存储的位置。SS 寄存器定义了栈段，这对 PUSH 和 POP 指令的操作数是有用的，程序的返回地址会通过 call 和 return 指令被压入和弹出栈中，以 EBP 或 ESP 为基址寄存器可以完成对任何数据的引用。ES 寄存器定义了扩展段，会被一些新的字串操作指令所用到。

# Chapter 3. Object Files

编译器和汇编器创建了目标文件（包含由源程序生成的二进制代码和数据）。链接器将多个目标文件合并成一个，加载器读取这些目标文件并将它们加载到内存中。

## 目标文件中都有什么?

一个目标文件包含五类信息。

* 头信息：关于文件的整体信息，诸如代码大小，源文件名称和创建日期等。
* 目标代码：由编译器或汇编器产生的二进制指令和数据。
* 重定位信息：目标代码中的一个位置列表，链接器在修改目标代码的地址时会对它进行调整。
* 符号：该模块中定义的全局符号，以及从其它模块导入的或者由链接器定义的符号。
* 调试信息：目标代码中与链接无关但会被调试器使用到的其它信息。包括源代码文件和行号信息，本地符号，被目标代码使用的数据结构描述信息（如 C 语言数据结 构定义）。

### 设计一个目标文件格式

一个文件可能是可链接的，能够作为链接编辑器或链接加载器的输入；它也可能是可执行的，可以加载到内存中作为一个程序运行；或者是可加载的，作为库和程序一起被加载到内存中；或者它是以上几种情况的组合。

一个可链接文件包含目标代码以及链接器处理时所需的扩展符号和重定位信息。目标代码经常被划分为多个会被链接器区别对待的小逻辑段。一个可执行程序中会包含目标代码（为了能让文件被映射到地址空间中它通常是页对齐的），但是可以不需要任何符号（除非它要进行运行时动态链接）以及一部分或完全没有重定位信息。根据系统运行时环境细节的不同，一个可加载文件可以仅包含目标代码,或为了进行运行时链接还包含了完整的符号和重定位信息。

*在应用中会存在某些冲突。面向逻辑的可链接段分组策略很少能够与面向硬件的可执行段分组策略相匹配。尤其是在一些较小的计算机上,链接器每次只会对可链接文件的一小片进行读写，但可执行程序会被整体的加载到内存中。*

## 空目标文件格式: MS-DOS的.COM文件

一个 .COM 文件中除了二进制代码外没有别的。当操作系统运行一个 .COM 文件时，它只需将文件的内容加载到一块空闲内存中，从偏移量 0x100 处开始执行（0-0xFF 存放的是程序的命令行参数和其它参数，称为程序段前缀 PSP），将所有的 x86 段寄存器设置为指向 PSP，将 SP（栈指针）寄存器指向该段的末尾（由于栈是向下生长的），然后跳转到被加载程序的入口处。

x86 的分段架构使得这种文件格式可以工作。因为所有的 x86 程序地址都被解释为是相对于当前段基地址的，所有的段寄存器都指向该段的基址，而程序总是以相对段位置为 0x1 00 的方式被加载。

## 代码区段: Unix a.out文件

具有硬件内存重定位部件的计算机系统（今天几乎所有的计算机都有）通常都会为新运行的程序创建一个具有空地址空间的新进程，这种情况下程序就可以按照从某个固定地址开始的方式被链接，而不需要加载时的重定位。

最简单的情况下，一个 a.out 文件包含一个小文件头，后面接着是可执行代码(由于历 史的原因被称为文本段)，然后是静态数据的初始值：

<img src="/assets/images/linker-and-loader-note/illustration-3.png" width="800" />

PDP-11 产品线的后续型号为代码（称为指令空间 I）和数据（称为数据空间 D）提供了独立的地址空间，这样一个程序可以拥有 64K 的代码空间和 64K 的数据空间。为了支持这个特性，编译器、汇编器、链接器都被修改为可以创建两个段的目标文件（代码放入第一个段中，数据放入第二个段中，程序加载时先将第一个段载入进程的 I 空间，再将第二个段载入进程的 D 空间）。

独立的 I 和 D 空间还有另一个性能上的优势：由于一个程序不能修改自己的 I 空间，因此一个程序的多个实体可以共享一份程序代码的副本。

### a.out 头部

a.out 的头部根据 UNIX 版本的不同而略有变化，但最典型的是 BSD UNIX 的版本：

```c
int a_magic;   // 幻数
int a_text;    // 文本段大小
int a_data;    // 初始化的数据段大小
int a_bss;     // 未初始化的数据段大小
int a_syms;    // 符号表大小
int a_entry;   // 入口点
int a_trsize;  // 文本重定位段大小
int a_drsize;  // 数据重定位段大小
```

幻数 a\_magic 说明了当前可执行文件的类型1。不同的幻数告诉操作系统的程序加载器以不同的方式将文件加载到内存中。文本和数据段大小 a\_text 和 a\_data 以字节为单位标识了头部后面的只读代码段和可读写数据段的大小。由于 UNIX 会自动将新分配的内存清零，因此初值无关紧要或者为 0 的数据不必在 a.out 文件中存储。未初始化数据大小 a\_bss 说明了在 a.out 文件中的可读写数据段后面逻辑上存在多少未初始化的数据（实际上是被初始化为 0）。

a\_entry 域指明了程序的起始地址，同时 a\_syms，a\_trsize 和 a\_drsize 说明了在文件数据段后的符号表与重定位信息的大小。已经被链接好可以运行的程序中既不需要符号表也不需要重定位信息，所以除非链接器为了调试器加入符号信息，否则在可运行文件中这些域都是 0。

### 与虚拟内存的交互

操作系统加载和启动一个简单的两段文件的过程非常简单，如图：

<img src="/assets/images/linker-and-loader-note/illustration-4.png" width="800" />

* 读取 a.out 的头部获取段的大小。
* 检查是否已存在该文件的可共享代码段。如果是的话,将那个段映射到该进程的地址空间。如果不是，创建一个并将它映射到地址空间中，然后从文件中读取文本段放入这个新的内存区域。
* 创建一个足够容纳数据段和BSS的私有数据段，将它映射到进程的地址空间中，然后从文件中读取数据段放入内存中的数据段并将 BSS 段对应的内存空间清零。
* 创建一个栈的段并将其映射到进程的地址空间（由于数据堆和栈的增长方向不同，因此栈段通常是独立于数据段的）。将命令行或者调用程序传递的参数放入栈中。
* 适当的设置各种寄存器并跳转到起始地址。

在一个分页系统中，上述的简单机制会为每一个文本段和数据段分配新的虚拟内存。由于 a.out 文件已经存储在磁盘中了，所以目标文件本身可以被映射到进程的地址空间中。虚拟内存只需要为程序写入的那些页分配新的磁盘空间，这样可以节省磁盘空间。并且由于虚拟内存系统只需要将程序确实需要的那些页从磁盘加载到内存中（而不是整个文件），这样也加快了程序启动的速度。

对 a.out 文件格式进行少许修改就可以做到这一点，如下图所示。这就够成了被称为 ZMAGIC 的格式。这些变化将目标文件中的段对齐到页的边界。在页大小为 4K 的系统上，a.out 头部扩展为 4K，文本段的大小也要对齐到下一个 4K 的边界。由于 BSS 段逻辑上跟在数据段的后面并在程序加载时被清零，所以没有必要对数据段进行页边界对齐的填充。

<img src="/assets/images/linker-and-loader-note/illustration-5.png" width="800" />

ZMAGIC 格式的文件减少了不必要的换页,对应付出的代价是浪费了大量的磁盘空间。a.out 的头部仅有 32 字节长，但是仍需要分配 4K 磁盘空间给它。文本和数据段之间的空隙平均浪费了 2K 空间，即半个 4K 的页。上述这些问题都在被称为 ZMAGIC 的压缩可分页格式中被修正了。

由于并没有什么特别的原因要求文本段的代码必须从地址 0 处开始运行，因此压缩可分页文件将 a.out 头部当成是文本段的一部分（实际上由于未初始化的指针变量经常为 0，位置 0 绝对不是一个程序入口的好地方）。代码紧跟在头部的后面，并将整个页映射为进程的第二个页，而不映射进程地址空间的第一个页，这样对位置 0 的指针引用就会失败。

<img src="/assets/images/linker-and-loader-note/illustration-6.png" width="800" />

QMAGIC 格式的可执行文件中文本和数据段都各自扩充到一个整页，这样系统就可以很容易的将文件中的页映射到地址空间中的页。数据段的最后一页由值为零的 BSS 数据填充补齐；如果 BSS 数据大于可以填充补齐的空间，那么 a.out 的头部中会保存剩余需要分配的 BSS 空间大小。

## 重定位:MS-DOS EXE文件

对于那些可以为每一个进程分配新的地址空间让每个程序都可以加载到相同逻辑地址的系统而言，a.out 格式是足够了。有一些系统会将所有的程序加载到相同的地址空间，还有一些系统虽然会为程序分配各自的地址空间，但是并不总是将程序加载到相同的地址。在这些情况下，可执行程序会包含多个(通常被称为 fixups 的)重定位项，它们指明了程序中需要在被加载时进行修改的地址位置。具 fixups 的最简单的格式之一就是 MS-DOS EXE格式。

每个 .EXE 文件都是以下图所示的头部结构开始的。跟在头部后面的是变量长度相关的额外信息和一个 segment:offset 格式的 32 位修正地址列表。修正地址是程序基地址的相对地址，所以这些修正地址本身也需要被重定位以寻找那些程序中需要被修改的地址。在修正地址列表后的是程序代码。

```c
char signature[2] = "MZ";// magic number
short lastsize; // # bytes used in last block
short nblocks; // number of 512 byte blocks
short nreloc;// number of relocation entries
short hdrsize; // size of file header in 16 byte paragraphs short minalloc; // minimum extra memory to allocate
short maxalloc; // maximum extra memory to allocate
void far *sp;// initial stack pointer
short checksum; // ones complement of file sum
void far *ip;// initial instruction pointer
short relocpos; // location of relocation fixup table
short noverlay; // Overlay number, 0 for program
char extra[];// extra material for overlays, etc.
void far *relocs[]; // relocation entries, starts at relocpos
```

加载.EXE 文件只比加载.COM 文件复杂一点点：

* 读入文件头部，验证幻数是否有效。
* 找一块大小合适的内存区域。minalloc 和 maxalloc 域说明了在被加载程序末尾后需额外分配的内存块的最大和最小尺寸（链接器总是缺省的将最小尺寸设置为程序中类似 BSS 的未初始化数据的大小，将最大尺寸设置为 0xFFFF）。
* 创建一个程序段前缀（Program Segment Prefix），即位于程序开头的控制区域。
* 在 PSP 之后读入程序的代码。nblocks 和 lastsize 域定义了代码的长度。
* 从 relocpos 处开始读取 nreloc 个修正地址项。对每一个修正地址，将其中的基地址与程序代码加载的基地址相加，然后将这个重定位后的修正地址作为指针，将程序代码的实际基地址与这个指针指向的程序代码中的地址相加。
* 将栈指针设置为重定位后的 sp，然后跳转到重定位后的 ip 处开始执行程序。 

## 符号和重定位

目前我们讨论过的目标文件格式都是可加载的，即可以加载到内存中并直接运行。多数目标文件并不是可加载的，而是由编译器或汇编器生成传递给链接器或库管理器的中间文件。

由于可运行文件要运行在计算机的底层硬件上因此必须要足够简单，但可链接文件的处理属于软件层面，因此可以做很多非常高级的事情。原则上，一个支持链接的加载器可以在程序被加载时完成所有链接器必须完成的功能，但由于效率原因加载器通常都尽可能的简单，以提高程序启动的速度。动态链接将很多工作由链接器转移到加载器（由此在性能上有一些损失），但由于现代计算机的速度足够快了，所以利大于弊。

下面看看五种逐步复杂的格式：BSD UNIX 系统采用的 a.out 可重定位格式，System V 使用的 ELF 格式，IBM 360 目标文件格式，32 位 Windows 使用的扩展的 COFF 可链接和 PE 可执行格式，以及 COFF 格式 Windows 系统之前的 OMF 可链接格式。

### 可重定位的 a.out 格式

UNIX 系统对于可运行文件和可链接文件都使用相同的一种目标文件格式，其中可运行文件省略掉了那些仅用于链接器的段。文本和数据段的重定位表的大小保存在 a\_trsize 和 a\_drsize 中，符号表的尺寸保存在 a\_syms 中。这三个段跟在文本和数据段后。

重定位项有两个功能。当一个代码段被重定位到另一个不同的段基址时，重定位项标注出代码中需要被修改的地方。在一个可链接文件中，同样也有用来标注对未定义符号引用的重定位项，这样链接器就知道在最终解析符号时应当向何处补写符号的值。

下图展示了一个重定位项的格式。每一个重定位项包含了在文本或数据段中需被重定位的地址，以及定义了要做什么的信息。该地址是一个从文本段或数据段起始位置到需要重定位的项目的偏移量。长度域说明了该重定位项目的长度，从 0 到 3 依次对应 1、2、4 或者 8 个字节。pcrel 标志表示这是一个“PC（程序计数器）相对的”重定位项目，如果是的话，其会在指令中被作为相对地址使用。

<img src="/assets/images/linker-and-loader-note/illustration-7.png" width="800" />

*注：4 byte 的地址，3 byte 的索引，1 bit 的 pcrel 标志，2 bit 的长度域，1 bit 的外部标志，4 bit 的空闲位*

外部标志域控制对 index 域的解释，确定该重定位项目是对某个段或符号的引用。如果外部标志为 off，那这是一个简单的重定位项目，index 就指明了该项目是基于哪个段（文本、数据或 BSS）寻址的。如果外部标志为 on，那么这是一个对外部符号的引用，则 index 是该文件符号表中的符号序号。

a.out 文件的最后一个段是符号表。每个表项长度为 12 字节，描述一个符号，如下图所示：

<img src="/assets/images/linker-and-loader-note/illustration-8.png" width="800" />

*注：4 byte 的名字偏移量，1 byte 的类型，1 byte 的空闲字节，2 byte 的调试信息，4 byte 的值*

UNIX 编译器允许任意长度的标识符，所以名字字串全部都在符号表后面的字串表中。符号表项的第一个域是该符号以空字符结尾的名字字串在字串表中的偏移量。在类型字节中，若低位被置位则该符号是外部的（可以被其它模块看到的符号，称为全局符号更合适）。其余的位是符号类型。最重要的类型包括：

* 文本、数据或BSS：该模块定义的符号。外部标志位可能设置或没有设置。值为与该符号对应的模块内可重定位地址。
* abs：绝对非可重定位符号(absolute non-relocatable symbol)。很少在调试信息以外的地方使用。外部标志位可能设置或没有设置。值为该符号的绝对地址。
* undefined：在该模块中未定义的符号。外部标志位必须被设置。值通常为0。

作为一种特例，编译器可以使用一个未定义的符号来要求链接器为该符号预留一块存储空间。如果一个外部符号的值不为零，则该值是提示链接器程序希望该符号寻址存储空间的大小。在链接时，若该符号的定义不存在，则链接器根据其名字在 BSS 中创建一块存储空间，大小为所有被链接模块中该符号提示尺寸中的最大值。如果该符号在某个模块中被定义了，则链接器使用该定义而忽略提示的空间大小。这种“公共块技巧(common block hack)”支持 Fortran 公共块和未初始化的 C 外部数据的典型用法。

对于相对简单的分页系统，a.out 格式是简单而有效的。之所以被淘汰出主流，主要是因为它不能很容易的支持动态链接。并且 a.out 格式不支持 C++语言，因为 C++语言对所有的初始化和终结代码都需要特殊的处理。

## Unix ELF 格式

ELF 格式有三个略有不同的类型：可重定位的、可执行的和共享目标（shared objec ts）。可重定位文件由编译器和汇编器创建，但在运行前需要被链接器处理。可执行文件完成了所有的重定位工作和符号解析（除了那些可能需要在运行时被解析的共享库符号），共享目标就是共享库，即包括链接器所需的符号信息，也包括运行时可以直接执行的代码。

ELF 格式具有不寻常的双重特性，如下图所示。编译器、汇编器和链接器将这个文件看作是被区段（section）头部表描述的一系列逻辑区段的集合，而系统加载器将文件看成是由程序头部表描述的一系列段（segment）的集合。一个段（segment）通常会由多个区段（section）组成。可重定位文件具有区段表，可执行程序具有程序头部表，而共享目标文件两者都有。区段（section）是用于链接器后续处理的，而段（segment）会被映射到内存中。

<img src="/assets/images/linker-and-loader-note/illustration-9.png" width="800" />

ELF 文件都是以 ELF 头部起始的，如下图所示。头部被设计为即使在那些字节顺序与文件的目标架构不同的机器上也可以被正确的解码。头 4 个字节是用来标识 ELF 文件的幻数，接下来的 3 个字节描述了头部其余部分的格式。当程序读取了 class 和 byteorder 标志后，它就知道了文件的字节序和字宽度，就可以进行相应的字节顺序和数据宽度的转换：

```c
char magic[4] = "\177ELF";// magic number
char class; // address size, 1 = 32 bit, 2 = 64 bit 
char byteorder; // 1 = little-endian, 2 = big-endian 
char hversion; // header version, always 1
char pad[9];
short filetype; // file type: 1 = relocatable, 2 = executable, // 3 = shared object, 4 = core image
short archtype; // 2 = SPARC, 3 = x86, 4 = 68K, etc. 
int fversion;// file version, always 1
int entry; // entry point if executable
int phdrpos; // file position of program header or 0 
int shdrpos; // file position of section header or 0 int flags; // architecture specific flags, usually 0 short hdrsize; // size of this ELF header
short phdrent; // size of an entry in program header
short phdrcnt; // number of entries in program header or 0
short shdrent; // size of an entry in section header
short phdrcnt; // number of entries in section header or 0
short strsec;// section number that contains section name strings
```

一个可重定位或共享目标文件可以看成是一系列在区段头部表中被定义的区段的集合，如下图。每个区段只包含一种类型的信息，可以是程序代码、只读数据或可读写数据、重定位项或符号。

```c
int sh_name; // name, index into the string table
int sh_type; // section type
int sh_flags;// flag bits, below
int sh_addr; // base memory address, if loadable, or zero 
int sh_offset; // file position of beginning of section 
int sh_size; // size in bytes
int sh_link; // section number with related info or zero 
int sh_info; // more section-specific info
int sh_align;// alignment granularity if section is moved 
int sh_entsize; // size of entries if section is an array
```

区段类型包括：

* PROGBITS：程序内容,包括代码,数据和调试器信息。
* NOBITS：类似于PROGBITS，但在文件本身中并没有分配空间。用于BSS数据，在程序加载时分配空间。
* SYMTAB 和 DYNSYM：符号表，后面会有更加详细的描述。SYMTAB包含所有的符号并用于普通的链接器，DYNSYM 包含那些用于动态链接的符号（后一个表需要在运行时被加载到内存中，因此要让它尽可能的小）
* STRTAB：字串表，与a.out文件中的字串表类似。
* REL 和 RELA：重定位信息。REL 项将其中的重定位值加到存储在代码和数据中的基地址值，而 RELA 将重定位需要的基地址也保存在重定位项自身中。
* DYNAMIC 和 HASH：动态链接信息和运行时符号 hash 表。这里用到了 3 个标志位：AL LOC，意味着在程序加载时该区段要占用内存空间；WRITE 意味着该区段被加载后是可写的；EXECINSTR 即表示该区段包含可执行的机器代码。

区段包括：
* .text 是具有 ALLOC 和 EXECINSTR 属性的 PROGBITS 类型区段。相当于 a.out 的文本段。
* .data 是具有 ALLOC 和 WRITE 属性的 PROGBITS 类型区段。对应于 a.out 的数据段。
* .rodata 是具有 ALLOC 属性的 PROGBITS 类型区段。由于是只读数据，因此没有 WRITE 属性。
* .bss 是具有 ALLOC 和 WRITE 属性的 NOBITS 类型区段。BSS 区段在文件中没有分配空间，因此是 NOBITS 类型，但由于会在运行时分配空间，所以具有 ALLOC 属性。
* .rel.txt，.rel.data 和 .rel.rodata 每个都是 REL 或 RELA 类型区段。是对应文本或数据区段的重定位信息。
* .init 和 .fini，都是具有 ALLOC 和 EXECINSTR 属性的 PROGBITS 类型区段。与 .text 区段相似,但分别为程序启动和终结时执行的代码。C 和 Fortran 不需要这个，但是对于具有初始和终结函数的全局数据的 C++ 语言来说是必须的。
* .symtab 和 .dynsym 分别是 STMTAB 和 DNYSYM 类型的区段，对应为普通的和动态链接器的符号表。动态链接器符号表具有 ALLOC 属性，因为它需要在运行时被加载。
* .strtab 和 .dynstr 都是 STRTAB 类型的区段，这是名称字串的表，要么是符号表，要么是段表的段名称字串。.synstr 区段保存动态链接器符号表字串，由于需要在运行时被加载所以具有 ALLOC 属性。

此外还有一些特殊的区段诸如 .got 和 .plt，分别是全局偏移量表（Global Offset Table）和动态链接时使用的过程链接表（Procedure Linkage Table）。.debug区段包含调试器所需的 符号，.line 区段也是用于调试器的，它保存了从源代码的行号到目标代码位置的映射关系。而 .comment 区段包含着文档字串，通常是版本控制中的版本序号。还有一个特殊的区段类型 .interp，它包含解释器程序的名字。如果这个区段存在，系统不会直接运行这个程序，而是会运行对应的解释器程序并将该 ELF 文件作为参数传递给解释器。

ELF 符号表与 a.out 符号表相似，包含一个由表项组成的数组：

```c
int name; // position of name string in string table 
int value; // symbol value, section relative in reloc, absolute in executable
int size; // object or function size
char type:4; // data object, function, section, or special case file 
char bind:4; // local, global, or weak
char other; // spare
short sect; // section number, ABS, COMMON or UNDEF
```

一个符号的绑定可以是局部的（仅模块内可见），全局的（所有地方均可见），或者弱符号。弱符号是半个全局符号：如果存在一个对未定义的弱符号的有效定义，则链接器采用该值，否则符号值缺省为 0。

符号的类型通常是数据或者函数。对每一个区段都会有一个区段符号，通常都是使用该区段本身的名字，这对重定位项是有用的（ELF 重定位项的符号都是相对地址，因此就需要一个段符号来指明某一个重定位项目是相对于文件中的哪一个区段)。文件入口点是一个包含源代码文件名称的伪符号。

区段号（即 section number）标识该符号的定义所在的那个段，例如函数入口点都是相对于.text 段定义的。这里还可以看到三个特殊的伪区段，UNDEF 用于未定义符号，ABS 用于 不可重定位绝对符号，COMMON 用于尚未分配的公共块

下图是一个典型的完整的 ELF 文件，包含代码、数据、重定位信息、链接器符号、和调试器符号等若干区段。如果该文件是一个 C++程序，那可能还包含.init、.fini、.rel.init 和 .rel.fini 等区段。

<img src="/assets/images/linker-and-loader-note/illustration-10.png" width="800" />


一个 ELF 可执行文件具有与可重定位 ELF 文件相同的通用格式，但对数据部分进行了调整以使得文件可以被映射到内存中并运行。ELF 头部后面紧跟程序头部，程序头部定义了要被映射的段。下图为程序头部，由段描述符组成的数组。

```c
int type; // loadable code or data, dynamic linking info, etc. 
int offset; // file offset of segment
int virtaddr;// virtual address to map segment
int physaddr;// physical address, not used
int filesize;// size of segment in file
int memsize; // size of segment in memory (bigger if contains BSS) 
int flags; // Read, Write, Execute bits
int align; // required alignment, invariably hardware page size
```

一个可执行程序通常只有少数几种段，如代码和数据的只读段，可读写数据的可读写段。所有的可加载区段都归并到适当类型的段中以便系统可以通过少数的一两个操作就可以完成文件映射。