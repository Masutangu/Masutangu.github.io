---
layout: post
date: 2017-01-25T20:49:16+08:00
title: 《Linker And Loader》读书笔记
category: 读书笔记
---

# Chapter 1. Linking and Loading

链接器和加载器的基本工作是：将更抽象的名字与更底层的名字绑定起来，好让程序员使用更抽象的名字编写代码。

在有操作系统之前，一个程序可以支配机器所有的内存，由于知道计算机中所有的地址都是可用的，因此它能以固定的内存地址来汇编和链接。但有了操作系统后，程序就必须和操作系统甚至其他程序共享计算机的内存。这意味着操作系统将程序加载到内存之前无法确定程序运行的确切地址，并将最终的地址绑定从链接时推延到加载时。链接器对每一个程序的部分地址进行绑定并分配相对地址，加载器赋予最终的实际地址。

随着硬件重定位和虚拟内存的出现，每个程序可以再次拥有整个地址空间。由于硬件重定位能处理任何加载时的重定位，程序可以以加载到固定地址的方式来链接。但是具有硬件重定位功能的计算机往往不止运行一个程序，而且经常运行同一个程序的多个副本。当运行一个程序的多个实例时，程序中的某些部分在所有运行实例都是相同的（尤其是可执行代码）。如果不变的部分可以分离出来，操作系统就可以只使用一份不变部分的副本，节省存储空间。编译器和汇编器被修改为可以创建多个段的目标代码，为只读代码分配一个段，为其他可写数据分配另外的段。链接器必须能够将所有段合并在一起。

在简单的静态共享库中，每个库在创建时会被绑定到特定的地址，链接器在链接时将程序中引用的库例程绑定到这些特定的地址。由于静态库中任何部分变化时都需要重新链接，因此又出现了动态链接库。使用动态链接库的程序在开始运行之前不会将所用库中的段和符号绑定到确切的地址上。在完全的动态链接中，被调用的例程的地址在第一次调用前都不会被绑定。此外在程序运行过程中也可以加载库并进行绑定。

链接器和加载器完成几个相关但概念上不同的动作：

* 程序加载：将程序从辅助存储设备拷贝到主内存中准备运行。在某些情况下，加载仅仅是将数据从磁盘拷入内存。在其他情况下，还包括分配存储空间，设置保护位或通过虚拟内存将虚拟地址映射到磁盘内存页上。
* 重定位：编译器和汇编器通常为每个文件创建程序地址从 0 开始的目标代码。如果程序是由多个子程序组成，那必须加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。很多系统中，重定向不止进行一次。对于链接器的一种普遍情景是由多个子程序来构建一个程序，并生成一个链接好的起始地址为 0 的输出程序，各个子程序通过重定位在大程序中确定位置。当这个程序被加载时，系统会选择一个加载地址，而链接好的程序会作为整体被重定位到加载地址。
* 符号解析：当通过多个子程序来构建一个程序时，子程序间的相互引用是通过符号进行的。程序可能会调用一个名为 sqrt 的计算平方根例程，并且数学库中定义了 sqrt 例程。链接器通过标明分配给 sqrt 的地址在库中来解析这个符号，并通过修改目标代码使得 call 指令引用该地址。

链接器将一系列的目标文件、库及可能的命令文件作为它的输入，然后将输出的目标文件作为结果，此外可能还有加载映射信息或调试器符号文件的副产品。

每个输入文件都包含一系列的段（segments），即会被连续存放在输出文件中的代码或数据块。每一个输入文件至少还包含一个符号表（symbol table）。有一些符号是导出符号，他们在当前文件中定义并在其他文件中使用，通常都是可以在其它地方被调用的当前文件内例程的名字。另外还有导入符号，在当前文件中使用但不在当前文件中定义，通常都是在该文件中调用但不存在于该文件中的例程的名字。

当链接器运行时，会首先对输入文件进行扫描，得到各个段的大小，并收集对所有符号的定义和引用。它会创建一个列出输入文件中定义的所有段的段表，和包含所有导出、导入符号的符号表。

利用第一遍扫描得到的数据，链接器可以为符号分配数字地址，决定各个段在输出地址空间中的大小和位置，并确定每一部分在输出文件中的布局。

第二遍扫描会利用第一遍扫描中收集的信息来控制实际的链接过程。它会读取并重定位目标代码，替换符号引用的数字地址，调整代码和数据的内存地址以反映重定位的段地址，并将重定位后的代码写入到输出文件中。通常还会再向输出文件中写入文件头部信息，重定位的段和符号表信息。如果程序使用了动态链接，那么符号表中还要包含运行时链接器解析动态符号时所需的信息。
指向各初始化例程的函数指针数组。

链接器和加载器的核心动作是重定位和代码修改。当编译器或汇编器产生一个目标代码文件时，它使用文件中定义的未重定位代码地址和数据地址来生成代码，对于其它地方定义的数据或代码通常就是 0。作为链接过程的一部分，链接器会修改目标代码以反映实际分配的地址。

# Chapter 2. Architectural Issues

硬件体系结构的两个方面影响到链接器：**程序寻址**和**指令格式**。链接器需要做的事情之一就是对数据和指令中的地址及偏移量都要进行修改。


## Application Binary Interfaces

每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口（Application Binary Interface）。ABI 由应用程序在这个系统下运行时必须遵守的编程约定组成。ABI 总是包含一系列的系统调用和使用这些系统调用的方法，以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看，ABI 既是系统架构的一部分也是硬件体系结构。

### 指令格式

每种体系结构都有一些不同的指令格式。每条指令都包含一个操作码，它决定了指令做什么，此外还有一个操作数。操作数可以被编码到指令本身(立即操作数)，或者放置在内存中。内存中每个操作数的地址总要经过一些计算，有时地址包含在指令中（直接寻址），更经常的是地址存储在某一个寄存器中（寄存器间接寻址），或通过将指令中的一个常量加上寄存器中的内容计算得来。如果寄存器中的值是一个存储区域的地址，而指令中的常量是存储区域中想要访问的数据的偏移量，这种策略称为基址寻址。如果二者调换过来，寄存器中保存的是偏移量，那这种策略就是索引寻址。

### 过程调用和可寻址性

在最早的计算机中内存很小，指令中的地址域足够容纳计算机任何一个内存位置的地址，现在我们称这种策略为直接寻址。在上世纪 60 年代早期，可寻址内存已经变得相当大，如果指令集中每个指令都包含整个地址将占用太多宝贵的内存。为了解决这个问题，计算机的架构师们在地址引用指令中部分或彻底的放弃了直接寻址，使用索引和基址寄存器来提供寻址所需的大部分或全部地址位。

#### 过程调用

每种 ABI 都通过将硬件定义的调用指令与内存、寄存器的使用约定组合起来定义了一个标准的过程调用序列。硬件的调用指令保存了返回地址（调用执行后的指令地址）并跳转到目标过程。在诸如 x86 这样具有硬件栈的体系结构中返回地址被压入栈中，而在其它体系结构中它会被保存在一个寄存器里，如果必要软件要负责将寄存器中的值保存在内存中。具有栈的体系结构通常都会有一个硬件的返回指令将返回地址推出栈并跳转到该地址，而其它体系结构则使用一个“跳转到寄存器中地址”的指令来返回。

在一个过程的内部，数据寻址可分为 4 类：

* 调用者可以向过程传递参数
* 本地变量在过程中分配，并在过程返回前释放
* 本地静态数据保存在内存的固定位置中，并为该过程私有
* 全局静态数据保存在内存的固定位置中，并可被很多不同过程引用 

为每个过程调用分配的一块栈内存称为“栈框架(stack frame)”。下图显示了一个典型的栈框架：

<img src="/assets/images/linker-and-loader-note/illustration-1.png" width="800" />

相关资料：[《X86汇编调用框架浅析与CFI简介》](http://larmbr.com/2013/09/20/x86-assembly-call-frame-and-dwarf-CFI-introduction/)

对于局部和全局静态数据，编译器可以为一个例程引用的所有静态变量创建一个指针表。如果某个寄存器存有指向这个表的指针，那么例程可以通过使用表指针寄存器将对象在表中的指针读取出来，加载到另一个使用表指针寄存器作为基址的寄存器中，并将第二个寄存器做为基址寄存器来寻址任何想要访问的静态目标。