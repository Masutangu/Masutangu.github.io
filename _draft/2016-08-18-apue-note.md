---
layout: post
date: 2016-07-07T15:02:11+08:00
title: APUE 读书笔记
category: 读书笔记
---

# Chapter 1. UNIX System Overview

## 1.1. Introduction

* All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on.

## 1.2. UNIX Architecture

* An operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the **kernel**.
* The interface to the kernel is a layer of software called the **system calls**. Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications.

## 1.3. Logging In

* When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd which composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).

## 1.4. Files and Directories

* The UNIX file system is a hierarchical arrangement of directories and files. 
* Most implementations of UNIX file systems don't store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links.

## 1.5. Input and Output

* File descriptors are normally small non-negative integers that the kernel uses to identify the files being accessed by a particular process.
* By convention, all shells open three descriptors whenever a new program is run: **standard input**, **standard output**, and **standard error**.
* Unbuffered I/O is provided by the functions **open**, **read**, **write**, **lseek**, and **close**. These functions all work with file descriptors.
* The <unistd.h> header and the two constants **STDIN_FILENO** and **STDOUT_FILENO** are part of the POSIX standard
* The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O prevents us from having to worry about choosing optimal buffer sizes, such as the BUFFSIZE constant. Another advantage of using the standard I/O functions is that they simplify dealing with lines of input. The standard I/O constants stdin and stdout are defined in the <stdio.h> header and refer to the standard input and standard output.

## 1.6. Programs and Processes

* A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the six **exec** functions.
* The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer.
* There are three primary functions for process control: fork, exec, and waitpid.
* All the threads within a process share the same **address space**, **file descriptors**, **stacks**, and **process-related attributes**. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.
* Threads are identified by IDs, however, are **local to a process**.

## 1.7. Error Handling

* There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.
* Resource-related nonfatal errors include EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, ENOSR, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as a nonfatal error when it indicates that a shared resource is in use. Sometimes, EINTR can be treated as a nonfatal error when it interrupts a slow system call. The typical recovery action for a resource-related nonfatal error is to delay a little and try again later.

## 1.8. User Identification

* The user ID from our entry in the password file is a numeric value that identifies us to the system.
* Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.
* There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.
* Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32- bit integers.

## 1.9. Signals

* Signals are a technique used to notify a process that some condition has occurred.
* The process has three choices for dealing with the signal.
    * Ignore the signal. This option isn't recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.
    * Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.
    * Provide a function that is called when the signal occurs (this is called "catching" the signal). By providing a function of our own, we'll know when the signal occurs and we can handle it as we wish.

* We have to be the owner of the other process (or the superuser) to be able to send it a signal.

1.10. Time Values

* UNIX systems have maintained two different time values:
    * Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC). These time values are used to record the time when a file was last modified, for example.
        The primitive system data type time_t holds these time values.
    * Process time. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second.
        The primitive system data type clock_t holds these time values. 
        
* When we measure the execution time of a process, as in Section 3.9, we'll see that the UNIX System maintains three values for a process:
    * Clock time
    * User CPU time
    * System CPU time

    The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. 

## 1.11. System Calls and Library Functions

* All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls.
* The system call interface's definition is in the C language, regardless of the actual implementation technique used on any given system to invoke a system call.

# Chapter 2. UNIX Standardization and Implementations

## 2.5. Limits
* Two types of limits are needed:
    * Compile-time limits (e.g., what's the largest value of a short integer?)
    * Runtime limits (e.g., how many characters in a filename?)
    Compile-time limits can be defined in headers that any program can include at compile time. But runtime limits require the process to call a function to obtain the value of the limit.

* Additionally, some limits can be fixed on a given implementation—and could therefore be defined statically in a header—yet vary on another implementation and would require a runtime function call.
* To solve these problems, three types of limits are provided:
    * Compile-time limits (headers)
    * Runtime limits that are not associated with a file or directory (the sysconf function)
    * Runtime limits that are associated with a file or a directory (the pathconf and fpathconf functions)

* All the limits defined by ISO C are compile-time limits that are defined in the file <limits.h>. 
    *  ISO C defines the constant FOPEN_MAX, the minimum number of standard I/O streams that the implementation guarantees can be open at once. This value is in the <stdio.h> header, and its minimum value is 8. The POSIX.1 value STREAM_MAX, if defined, must have the same value as FOPEN_MAX.
    * ISO C also defines the constant TMP_MAX in <stdio.h>. It is the maximum number of unique filenames generated by the tmpnam function.

* sysconf / pathconf / fpathconf
    * All three functions return –1 and set errno to EINVAL if the name isn't one of the appropriate constants. The third column in Figures 2.10 and 2.11 lists the limit constants we'll deal with throughout the rest of this book.
    * Some names can return either the value of the variable (a return value 0) or an indication that the value is indeterminate. An indeterminate value is indicated by returning –1 and not changing the value of errno.
    * The value returned for _SC_CLK_TCK is the number of clock ticks per second, for use with the return values from the times function (Section 8.16).


# Chapter 3. File I/O

## 3.1. Introduction
* Most file I/O on a UNIX system can be performed using only five functions: ```open```, ```read```, ```write```, ```lseek```, and ```close```.

## 3.2. File Descriptors
* To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. 
* UNIX System shells associate **file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error**. This convention is used by the shells and many applications; it is not a feature of the UNIX kernel.
* The magic numbers 0, 1, and 2 should be replaced in POSIX-compliant applications with the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO. These constants are defined in the <unistd.h> header.

## 3.3. open Function
```int open(const char *pathname, int oflag, ... /* mode_t mode */ );```
* This function has a multitude of options, which are specified by the oflag argument. This argument is formed by ORing together one or more of the following constants from the <fcntl.h> header:
    * O_RDONLY: Open for reading only. 
    * O_WRONLY: Open for writing only.   
    * O_RDWR:   Open for reading and writing.

    One and only one of these three constants must be specified. The following constants are optional:
    * O_APPEND:     Append to the end of file on each write.
    * O_CREAT:      Create the file if it doesn't exist. This option requires a third argument to the open function, the mode, which specifies the access permission bits of the new file. 
    * O_EXCL:       Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn't exist is an atomic operation. 
    * O_TRUNC:      If the file exists and if it is successfully opened for either write-only or read–write, truncate its length to 0.
    * O_NOCTTY:     If the pathname refers to a terminal device, do not allocate the device as the controlling terminal for this process. 
    * O_NONBLOCK:   If the pathname refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. 

    
    The following three flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1):
    * O_DSYNC:  Have each write wait for physical I/O to complete, but don't wait for file attributes to be updated if they don't affect the ability to read the data just written.
    * O_RSYNC:  Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.
    * O_SYNC:   Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. 

    The O_DSYNC and O_SYNC flags are similar, but subtly different. The O_DSYNC flag affects a file's attributes only when they need to be updated to reflect a change in the file's data. With the O_SYNC flag, data and attributes are always updated synchronously. When overwriting an existing part of a file opened with the O_DSYNC flag, the file times wouldn't be updated synchronously.

* **The file descriptor returned by open is guaranteed to be the lowest-numbered unused descriptor.**

## 3.4. creat Function
```int creat(const char *pathname, mode_t mode);```

* Note that this function is equivalent to ```open (pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);```
* Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn't already exist. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.
* One deficiency with creat is that the file is opened **only for writing**.

## 3.5. close Function
```int close(int filedes);```
* Closing a file also releases any record locks that the process may have on the file.
* When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don't explicitly close open files.

## 3.6. lseek Function
```off_t lseek(int filedes, off_t offset, int whence);```
* Every open file has an associated "current file offset," normally a non-negative integer that measures the number of bytes from the beginning of the file. 
* Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.
* The interpretation of the offset depends on the value of the whence argument.
    * If whence is SEEK_SET, the file's offset is set to offset bytes from the beginning of the file.
    * If whence is SEEK_CUR, the file's offset is set to its current value plus the offset. The offset can be positive or negative.
    * If whence is SEEK_END, the file's offset is set to the size of the file plus the offset. The offset can be positive or negative.

* Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset. This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns –1.
* The character l in the name lseek means **"long integer"**.
* For regular files, the offset must be non-negative. It is possible, however, that certain devices could allow negative offsets. We should be careful to compare the return value from lseek as being equal to or not equal to –1 and not test if it's less than 0.
* The file's offset can be greater than the file's current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.
* A hole in a file isn't required to have storage backing it on disk. When you write after seeking past the end of the file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.

## 3.7. read Function
```ssize_t read(int filedes, void *buf, size_t nbytes);```
* If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned.
* The read operation starts at the file's current offset. **Before a successful return, the offset is incremented by the number of bytes actually read.**

## 3.8. write Function
```ssize_t write(int filedes, const void *buf, size_t nbytes);```
* The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process.
* After a successful write, the file's offset is incremented by the number of bytes actually written.

## 3.9. I/O Efficiency
* Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. 

## 3.10. File Sharing
* The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.
    * Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are
        * The file descriptor flags (close-on-exec)
        * A pointer to a file table entry
    * The kernel maintains a file table for all open files. Each file table entry contains
        * The file status flags for the file, such as read, write, append, sync, and nonblocking
        * The current file offset
        * A pointer to the v-node table entry for the file
    * Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on.
