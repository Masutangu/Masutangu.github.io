---
layout: post
date: 2016-07-07T15:02:11+08:00
title: APUE 读书笔记
category: 读书笔记
---

# Chapter 1. UNIX System Overview

## 1.1. Introduction

* All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on.

## 1.2. UNIX Architecture

* An operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the **kernel**.
* The interface to the kernel is a layer of software called the **system calls**. Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications.

## 1.3. Logging In

* When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd which composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).

## 1.4. Files and Directories

* The UNIX file system is a hierarchical arrangement of directories and files. 
* Most implementations of UNIX file systems don't store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links.

## 1.5. Input and Output

* File descriptors are normally small non-negative integers that the kernel uses to identify the files being accessed by a particular process.
* By convention, all shells open three descriptors whenever a new program is run: **standard input**, **standard output**, and **standard error**.
* Unbuffered I/O is provided by the functions **open**, **read**, **write**, **lseek**, and **close**. These functions all work with file descriptors.
* The <unistd.h> header and the two constants **STDIN_FILENO** and **STDOUT_FILENO** are part of the POSIX standard
* The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O prevents us from having to worry about choosing optimal buffer sizes, such as the BUFFSIZE constant. Another advantage of using the standard I/O functions is that they simplify dealing with lines of input. The standard I/O constants stdin and stdout are defined in the <stdio.h> header and refer to the standard input and standard output.

## 1.6. Programs and Processes

* A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the six **exec** functions.
* The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer.
* There are three primary functions for process control: fork, exec, and waitpid.
* All the threads within a process share the same **address space**, **file descriptors**, **stacks**, and **process-related attributes**. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.
* Threads are identified by IDs, however, are **local to a process**.

## 1.7. Error Handling

* There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.
* Resource-related nonfatal errors include EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, ENOSR, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as a nonfatal error when it indicates that a shared resource is in use. Sometimes, EINTR can be treated as a nonfatal error when it interrupts a slow system call. The typical recovery action for a resource-related nonfatal error is to delay a little and try again later.

## 1.8. User Identification

* The user ID from our entry in the password file is a numeric value that identifies us to the system.
* Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.
* There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.
* Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32- bit integers.

## 1.9. Signals

* Signals are a technique used to notify a process that some condition has occurred.
* The process has three choices for dealing with the signal.
    * Ignore the signal. This option isn't recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.
    * Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.
    * Provide a function that is called when the signal occurs (this is called "catching" the signal). By providing a function of our own, we'll know when the signal occurs and we can handle it as we wish.

* We have to be the owner of the other process (or the superuser) to be able to send it a signal.

1.10. Time Values

* UNIX systems have maintained two different time values:
    * Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC). These time values are used to record the time when a file was last modified, for example.
        The primitive system data type time_t holds these time values.
    * Process time. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second.
        The primitive system data type clock_t holds these time values. 
        
* When we measure the execution time of a process, as in Section 3.9, we'll see that the UNIX System maintains three values for a process:
    * Clock time
    * User CPU time
    * System CPU time

    The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. 

## 1.11. System Calls and Library Functions

* All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls.
* The system call interface's definition is in the C language, regardless of the actual implementation technique used on any given system to invoke a system call.

# Chapter 2. UNIX Standardization and Implementations

## 2.5. Limits
* Two types of limits are needed:
    * Compile-time limits (e.g., what's the largest value of a short integer?)
    * Runtime limits (e.g., how many characters in a filename?)
    Compile-time limits can be defined in headers that any program can include at compile time. But runtime limits require the process to call a function to obtain the value of the limit.

* Additionally, some limits can be fixed on a given implementation—and could therefore be defined statically in a header—yet vary on another implementation and would require a runtime function call.
* To solve these problems, three types of limits are provided:
    * Compile-time limits (headers)
    * Runtime limits that are not associated with a file or directory (the sysconf function)
    * Runtime limits that are associated with a file or a directory (the pathconf and fpathconf functions)

* All the limits defined by ISO C are compile-time limits that are defined in the file <limits.h>. 
    *  ISO C defines the constant FOPEN_MAX, the minimum number of standard I/O streams that the implementation guarantees can be open at once. This value is in the <stdio.h> header, and its minimum value is 8. The POSIX.1 value STREAM_MAX, if defined, must have the same value as FOPEN_MAX.
    * ISO C also defines the constant TMP_MAX in <stdio.h>. It is the maximum number of unique filenames generated by the tmpnam function.

* sysconf / pathconf / fpathconf
    * All three functions return –1 and set errno to EINVAL if the name isn't one of the appropriate constants. The third column in Figures 2.10 and 2.11 lists the limit constants we'll deal with throughout the rest of this book.
    * Some names can return either the value of the variable (a return value 0) or an indication that the value is indeterminate. An indeterminate value is indicated by returning –1 and not changing the value of errno.
    * The value returned for _SC_CLK_TCK is the number of clock ticks per second, for use with the return values from the times function (Section 8.16).


# Chapter 3. File I/O

## 3.1. Introduction
* Most file I/O on a UNIX system can be performed using only five functions: ```open```, ```read```, ```write```, ```lseek```, and ```close```.

## 3.2. File Descriptors
* To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. 
* UNIX System shells associate **file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error**. This convention is used by the shells and many applications; it is not a feature of the UNIX kernel.
* The magic numbers 0, 1, and 2 should be replaced in POSIX-compliant applications with the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO. These constants are defined in the <unistd.h> header.

## 3.3. open Function
```
int open(const char *pathname, int oflag, ... /* mode_t mode */ );
```

* This function has a multitude of options, which are specified by the oflag argument. This argument is formed by ORing together one or more of the following constants from the <fcntl.h> header:
    * O_RDONLY: Open for reading only. 
    * O_WRONLY: Open for writing only.   
    * O_RDWR:   Open for reading and writing.

    One and only one of these three constants must be specified. The following constants are optional:
    * O_APPEND:     Append to the end of file on each write.
    * O_CREAT:      Create the file if it doesn't exist. This option requires a third argument to the open function, the mode, which specifies the access permission bits of the new file. 
    * O_EXCL:       Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn't exist is an atomic operation. 
    * O_TRUNC:      If the file exists and if it is successfully opened for either write-only or read–write, truncate its length to 0.
    * O_NOCTTY:     If the pathname refers to a terminal device, do not allocate the device as the controlling terminal for this process. 
    * O_NONBLOCK:   If the pathname refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. 

    
    The following three flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1):
    * O_DSYNC:  Have each write wait for physical I/O to complete, but don't wait for file attributes to be updated if they don't affect the ability to read the data just written.
    * O_RSYNC:  Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.
    * O_SYNC:   Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. 

    The O_DSYNC and O_SYNC flags are similar, but subtly different. The O_DSYNC flag affects a file's attributes only when they need to be updated to reflect a change in the file's data. With the O_SYNC flag, data and attributes are always updated synchronously. When overwriting an existing part of a file opened with the O_DSYNC flag, the file times wouldn't be updated synchronously.

* **The file descriptor returned by open is guaranteed to be the lowest-numbered unused descriptor.**

## 3.4. creat Function
```
int creat(const char *pathname, mode_t mode);
```

* Note that this function is equivalent to ```open (pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);```
* Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn't already exist. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.
* One deficiency with creat is that the file is opened **only for writing**.

## 3.5. close Function
```
int close(int filedes);
```

* Closing a file also releases any record locks that the process may have on the file.
* When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don't explicitly close open files.

## 3.6. lseek Function
```off_t lseek(int filedes, off_t offset, int whence);```
* Every open file has an associated "current file offset," normally a non-negative integer that measures the number of bytes from the beginning of the file. 
* Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.
* The interpretation of the offset depends on the value of the whence argument.
    * If whence is SEEK_SET, the file's offset is set to offset bytes from the beginning of the file.
    * If whence is SEEK_CUR, the file's offset is set to its current value plus the offset. The offset can be positive or negative.
    * If whence is SEEK_END, the file's offset is set to the size of the file plus the offset. The offset can be positive or negative.

* Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset. This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns –1.
* The character l in the name lseek means **"long integer"**.
* For regular files, the offset must be non-negative. It is possible, however, that certain devices could allow negative offsets. We should be careful to compare the return value from lseek as being equal to or not equal to –1 and not test if it's less than 0.
* The file's offset can be greater than the file's current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.
* A hole in a file isn't required to have storage backing it on disk. When you write after seeking past the end of the file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.

## 3.7. read Function
```ssize_t read(int filedes, void *buf, size_t nbytes);```
* If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned.
* The read operation starts at the file's current offset. **Before a successful return, the offset is incremented by the number of bytes actually read.**

## 3.8. write Function
```ssize_t write(int filedes, const void *buf, size_t nbytes);```
* The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process.
* After a successful write, the file's offset is incremented by the number of bytes actually written.

## 3.9. I/O Efficiency
* The operating system will try to cache the file incore.
* Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. 

## 3.10. File Sharing
* The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.
    * Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are
        * The file descriptor flags (close-on-exec)
        * A pointer to a file table entry
    * The kernel maintains a file table for all open files. Each file table entry contains
        * The file status flags for the file, such as read, write, append, sync, and nonblocking
        * The current file offset
        * A pointer to the v-node table entry for the file
    * Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on.

* Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file.

* The v-node was invented to provide support for multiple file system types on a single computer system. 

* After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset

* If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file.

* If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry.

* The lseek function modifies only the current file offset in the file table entry. No I/O takes place.

* It is possible for more than one file descriptor entry to point to the same file table entry, as we'll see when we discuss the dup function. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor.

* Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry.

## 3.12. dup and dup2 Functions
```
int dup(int filedes);
int dup2(int filedes, int filedes2);
```

* The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. 
* With dup2, we specify the value of the new descriptor with the filedes2 argument. If filedes2 is already open, it is first closed. If filedes equals filedes2, then dup2 returns filedes2 without closing it.
* Each descriptor has its own set of file descriptor flags. They share the same file status flags—read, write, append, and so on—and the same current file offset.

## 3.13. sync, fsync, and fdatasync Functions
```
int fsync(int filedes);
int fdatasync(int filedes);
```
* Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called **delayed write**.
* To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.
* The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel's block buffers. The command sync(1) also calls the sync function.
* The function fsync refers only to a single file, specified by the file descriptor filedes, and waits for the disk writes to complete before returning.
* The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file's attributes are also updated synchronously.

## 3.14. fcntl Function
```
int fcntl(int filedes, int cmd, ... /* int arg */ );
```
* The fcntl function can change the properties of a file that is already open.
* The fcntl function is used for five different purposes.
    * Duplicate an existing descriptor (cmd = F_DUPFD)
    * Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)
    * Get/set file status flags (cmd = F_GETFL or F_SETFL)
    * Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)
    * Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)

* First seven of these ten cmd values:
    * F_DUPFD: Duplicate the file descriptor filedes. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open. The new descriptor **shares the same file table entry** as filedes. But **the new descriptor has its own set of file descriptor flags**, and its FD_CLOEXEC file descriptor flag is cleared.
    * F_GETFD: Return the file descriptor flags for filedes as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag.
    * F_SETFD: Set the file descriptor flags for filedes. The new flag value is set from the third argument.
    * F_GETFL: Return the file status flags for filedes as the value of the function. We must first use the **O_ACCMODE mask** to obtain the access-mode bits and then compare the result against any of the three values.
    * F_SETFL: Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC.
    * F_GETOWN: Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals.
    * F_SETOWN: Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg.

* All commands return –1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first returns the new file descriptor, the next two return the corresponding flags, and the final one returns a positive process ID or a negative process group ID.

## 3.15. ioctl Function
```
int ioctl(int filedes, int request, ...);
```
* The ioctl function has always been the catchall for I/O operations. Anything that couldn't be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. 

## 3.16. /dev/fd
* Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.
* The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames.

# Chapter 4. Files and Directories
## 4.2. stat, fstat, and lstat Functions
```
int stat(const char *restrict pathname, struct stat *restrict buf); 
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```

```
struct stat {
    mode_t      st_mode;        /* file type & mode (permissions) */
    ino_t       st_ino;         /* i-node number (serial number) */
    dev_t       st_dev;         /* device number (file system) */
    dev_t       st_rdev;        /* device number for special files */
    nlink_t     st_nlink;       /* number of links */
    uid_t       st_uid;         /* user ID of owner */
    gid_t       st_gid;         /* group ID of owner */
    off_t       st_size;        /* size in bytes, for regular files */
    time_t      st_atime;       /* time of last access */
    time_t      st_mtime;       /* time of last modification */
    time_t      st_ctime;       /* time of last file status change */
    blksize_t   st_blksize;     /* best I/O block size */
    blkcnt_t    st_blocks;      /* number of disk blocks allocated */  
};
```

* The lstat function is similar to stat, but when the named file is a symbolic link, lstat returns information about the symbolic link, not the file referenced by the symbolic link.

## 4.3. File Types
* The types are:

    * Regular file
        The most common type of file, which contains data of some form. There is no distinction to the UNIX kernel whether this data is text or binary.

        One notable exception to this is with binary executable files. To execute a program, the kernel must understand its format. All binary executable files conform to a format that allows the kernel to identify where to load a program's text and data.

    * Directory file
        A file that contains the names of other files and pointers to information on these files.

    * Block special file
        A type of file providing buffered I/O access in fixed-size units to devices such as disk drives.

    * Character special file
        A type of file providing unbuffered I/O access in variable-sized units to devices. All devices on a system are either block special files or character special files.

    * FIFO
        A type of file used for communication between processes. It's sometimes called a named pipe. 

    * Socket
        A type of file used for network communication between processes. A socket can also be used for non-network communication between processes on a single host.

    * Symbolic link 
        A type of file that points to another file.

* The type of a file is encoded in the **st_mode** member of the stat structure. 
* Most systems define S_IFMT and S_IFxxx in the file <sys/stat.h>. If we examine this file, we'll find the S_ISDIR macro defined something like ```#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)```
* POSIX.1 allows implementations to represent interprocess communication (IPC) objects, such as message queues and semaphores, as files. 

## 4.4. Set-User-ID and Set-Group-ID
* Every process has six or more IDs associated with it:
    * real user ID / real group ID: who we really are
    * effective user ID / effective group ID / supplementary group IDs: used for file access permission checks
    * saved set-user-ID / saved set-group-ID: saved by exec functions

* The real user ID and real group ID identify who we really are. These two fields are taken from our entry in the password file when we log in. Normally, these values don't change during a login session.
* The effective user ID, effective group ID, and supplementary group IDs determine our file access permissions.
* The saved set-user-ID and saved set-group-ID contain copies of the effective user ID and the effective group ID when a program is executed. An application can test for the constant _POSIX_SAVED_IDS at compile time or can call sysconf with the _SC_SAVED_IDS argument at runtime, to see whether the implementation supports this feature.
* Normally, the effective user ID equals the real user ID, and the effective group ID equals the real group ID.
* Every file has an owner and a group owner. The owner is specified by the st_uid member of the stat
structure; the group owner, by the st_gid member.
* When we execute a program file, the effective user ID of the process is usually the real user ID, and the effective group ID is usually the real group ID. But the capability exists to set a special flag in the file's mode word (st_mode) that says **"when this file is executed, set the effective
user ID of the process to be the owner of the file (st_uid)."** Similarly, another bit can be set in the file's mode word that causes the effective group ID to be the group owner of the file (st_gid). These two bits in the file's mode word are called the **set-user-ID bit** and **the set-group-ID bit**.
* Returning to the stat function, the **set-user-ID bit** and the **set-group-ID bit** are contained in the file's **st_mode** value. These two bits can be tested against the constants **S_ISUID** and **S_ISGID**.

## 4.5. File Access Permissions
* The st_mode value also encodes the access permission bits for the file. 
* There are nine permission bits for each file, divided into three categories:
    | st_mode mask  | Meaning           |
    | ------------- |-------------------| 
    | S_IRUSR       |   user-read       |
    | S_IWUSR       |   user-write      |
    | S_IXUSR       |   user-execute    |
    | S_IRGRP       |   group-read      |
    | S_IWGRP       |   group-write     |
    | S_IXGRP       |   group-execute   |
    | S_IROTH       |   other-read      |
    | S_IWOTH       |   other-write     |
    | S_IXOTH       |   other-execute   |

* The three categories: read, write, and execute—are used in various ways by different functions:
    * The first rule is that whenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including the current directory, if it is implied. This is why the execute permission bit for a directory is often called **the search bit**.

    Note that read permission for a directory and execute permission for a directory mean different things. **Read permission lets us read the directory, obtaining a list of all the filenames in the directory. Execute permission lets us pass through the directory when it is a component of a pathname that we are trying to access.**

    Another example of an implicit directory reference is **if the PATH environment variable specifies a directory that does not have execute permission enabled. In this case, the shell will never find executable files in that directory.**

    * The read permission for a file determines whether we can open an existing file for reading: the **O_RDONLY and O_RDWR flags** for the open function.
    * The write permission for a file determines whether we can open an existing file for writing: the **O_WRONLY and O_RDWR flags** for the open function.
    * We must have write permission for a file to specify the **O_TRUNC** flag in the open function.
    * We cannot create a new file in a directory unless we have **write permission and execute permission** in the directory.
    * To delete an existing file, we need **write permission and execute permission in the directory** containing the file. We do not need read permission or write permission for the file itself.
    * Execute permission for a file must be on if we want to execute the file using any of the six exec functions. The file also has to be a regular file.

* The file access tests that the kernel performs each time a process opens, creates, or deletes a file depend on the owners of the file (st_uid and st_gid), the effective IDs of the process (effective user ID and effective group ID), and the supplementary group IDs of the process, if supported.     
    * If the effective user ID of the process is 0 (the superuser), access is allowed. This gives the superuser free rein throughout the entire file system.
    * If the effective user ID of the process equals the owner ID of the file (i.e., the process owns the file), access is allowed if the appropriate user access permission bit is set. Otherwise, permission is denied.
    * If the effective group ID of the process or one of the supplementary group IDs of the process equals the group ID of the file, access is allowed if the appropriate group access permission bit is set. Otherwise, permission is denied.
    * If the appropriate other access permission bit is set, access is allowed. Otherwise, permission is denied.

* If the process owns the file (step 2), access is granted or denied based only on the user access permissions; the group permissions are never looked at. Similarly, if the process does not own the file, but belongs to an appropriate group, access is granted or denied based only on the group access permissions; the other permissions are not looked at.

## 4.6. Ownership of New Files and Directories
* The user ID of a new file is set to the effective user ID of the process. POSIX.1 allows an implementation to choose one of the following options to determine the group ID of a new file.
    * The group ID of a new file can be the effective group ID of the process
    * The group ID of a new file can be the group ID of the directory in which the file is being created
* The Linux ext2 and ext3 file systems allow the choice between these two POSIX.1 options to be made on a file system basis, using a special flag to the mount(1) command. 
* On Linux 2.4.22 (with the proper mount option) and Solaris 9, the group ID of a new file depends on whether the set-group-ID bit is set for the directory in which the file is being created. If this bit is set for the directory, the group ID of the new file is set to the group ID of the directory; otherwise, the group ID of the new file is set to the effective group ID of the process.

## 4.7. access Function
```
int access(const char *pathname, int mode);
```
* The access function bases its tests on the real user and group IDs.
* The mode is the bitwise OR of any of the following constants:
    | mode Description |            Meaning           |
    | ---------------- |------------------------------| 
    |       R_OK       |    test for read permission  |
    |       W_OK       |   test for write permission  |
    |       X_OK       |  test for execute permission |
    |       F_OK       |   test for existence of file |

## 4.8. umask Function
```
mode_t umask(mode_t cmask);
```
* The umask function sets the file mode creation mask for the process and returns the previous value.
* The cmask argument is formed as the bitwise OR of any of the nine constants from S_IRUSR, S_IWUSR, and so on.
* The file mode creation mask is used whenever the process creates a new file or a new directory.
* **Any bits that are on in the file mode creation mask are turned off in the file's mode.**
* Changing the file mode creation mask of a process doesn't affect the mask of its parent (often a shell).
* Users can set the umask value to control the default permissions on the files they create. The value is expressed in octal, with **one bit representing one permission to be masked off**.

## 4.9. chmod and fchmod Functions
```
int chmod(const char *pathname, mode_t mode); 
int fchmod(int filedes, mode_t mode);
```
|      mode         |           Description         |
| ----------------- |-------------------------------| 
|   S_ISUID         |   set-user-ID on execution    |
|   S_ISGID         |   set-group-ID on execution   |
|   S_ISVTX         |   saved-text (sticky bit)     |
|   S_IRWXU         |read, write, and execute by user (owner)
|   S_IRUSR         |    read by user (owner)       |
|   S_IWUSR         |   write by user (owner)       |
|   S_IXUSR         |   execute by user (owner)     |
|   S_IRWXG         |read, write, and execute by group|
|   S_IRGRP         |        read by group          |
|   S_IWGRP         |       write by group          |
|   S_IXGRP         |       execute by group        |
|   S_IRWXO         |read, write, and execute by other (world)|
|   S_IROTH         |   read by other (world)       |
|   S_IWOTH         |   write by other (world)      |
|   S_IXOTH         |   execute by other (world)    |

* These two functions allow us to change the file access permissions for an existing file.
* The chmod function operates on the specified file, whereas the fchmod function operates on a file that has already been opened.
* To change the permission bits of a file, the effective user ID of the process must be equal to the owner ID of the file, or the process must have superuser permissions.
* ```chmod``` function updates only the time that the i-node was last changed. By default, the ls -l lists the time when the contents of the file were last modified.
* The chmod functions automatically clear two of the permission bits under the following conditions:
    * On systems, such as Solaris, that place special meaning on the sticky bit when used with regular files, if we try to set the sticky bit (S_ISVTX) on a regular file and do not have superuser privileges, the sticky bit in the mode is automatically turned off.
      
      Linux 2.4.22 places no such restriction on the setting of the sticky bit, because the bit has no meaning when applied to regular files on Linux.
    
    * It is possible that the group ID of a newly created file is a group that the calling process does not belong to. Specifically, if the group ID of the new file does not equal either the effective group ID of the process or one of the process's supplementary group IDs and if the process does not have superuser privileges, then **the set-group-ID bit is automatically turned off**. This prevents a user from creating a set-group-ID file owned by a group that the user doesn't belong to.

      FreeBSD 5.2.1, Linux 2.4.22, Mac OS X 10.3, and Solaris 9 add another security feature to try to prevent misuse of some of the protection bits. If a process that does not have superuser privileges writes to a file, the set-user-ID and set-group-ID bits are automatically turned off. 
   
## 4.10. Sticky Bit
* On versions of the UNIX System that predated demand paging, the S_ISVTX bit was known as the sticky bit. If it was set for an executable program file, then the first time the program was executed, a copy of the program's text was saved in the swap area when the process terminated. This caused the program to load into memory more quickly the next time it was executed, because the swap area was handled as a contiguous file, compared to the possibly random location of data blocks in a normal UNIX file system. The sticky bit was often set for common application programs, such as the text editor and the passes of the C compiler. Later versions of the UNIX System referred to this as the **saved-text bit**. With today's newer UNIX systems, most of which have a virtual memory system and a faster file system, the need for this technique has disappeared.

* On contemporary systems, the use of the sticky bit has been extended. The Single UNIX Specification allows the sticky bit to be set for a directory. If the bit is set for a directory, a file in the directory can be removed or renamed only if the user has write permission for the directory and one of the following:
    * Owns the file
    * Owns the directory
    * Is the superuser

    The directories /tmp and /var/spool/uucppublic are typical candidates for the sticky bit—they are directories in which any user can typically create files. The permissions for these two directories are often read, write, and execute for everyone (user, group, and other). But users should not be able to delete or rename files owned by others.

* Solaris 9 places special meaning on the sticky bit if it is set on a regular file. In this case, if none of the execute bits is set, the operating system will not cache the contents of the file.

## 4.11. chown, fchown, and lchown Functions

```
int chown(const char *pathname, uid_t owner, gid_t group); 
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);
```

* The chown functions allow us to change the user ID of a file and the group ID of a file.
* ```lchown``` changes the owners of the symbolic link itself, not the file pointed to by the symbolic link.
* If either of the arguments owner or group is -1, the corresponding ID is left unchanged.
* If _POSIX_CHOWN_RESTRICTED is in effect for the specified file, then
    * Only a superuser process can change the user ID of the file.
    * A nonsuperuser process can change the group ID of the file if the process owns the file (the effective user ID equals the user ID of the file), owner is specified as –1 or equals the user ID of the file, and group equals either the effective group ID of the process or one of the process's supplementary group IDs.

    This means that when _POSIX_CHOWN_RESTRICTED is in effect, you can't change the user ID of other users' files. You can change the group ID of files that you own, but only to groups that you belong to.

* If these functions are called by a process other than a superuser process, on successful return, both the set-user- ID and the set-group-ID bits are cleared.

## 4.12. File Size
* The st_size member of the stat structure contains the size of the file in bytes. This field is meaningful only for regular files, directories, and symbolic links.
* For a regular file, a file size of 0 is allowed. We'll get an end-of-file indication on the first read of the file.
* For a directory, the file size is usually a multiple of a number, such as 16 or 512.
* For a symbolic link, the file size is the number of bytes in the filename.
* Most contemporary UNIX systems provide the fields st_blksize and st_blocks. The first is the preferred block size for I/O for the file, and the latter is the actual number of 512-byte blocks that are allocated.
* **The difference between this size and the size reported by ls is caused by the number of blocks used by the file system to hold pointers to the actual data blocks.**

## 4.13. File Truncation
```
int truncate(const char *pathname, off_t length); 
int ftruncate(int filedes, off_t length);
```
* If the previous size of the file was greater than length, the data beyond length is no longer accessible. If the previous size was less than length, the effect is system dependent. If the implementation does extend a file, data between the old end of file and the new end of file will read as 0.

## 4.14. File Systems
* We can think of a disk drive being divided into one or more partitions. Each partition can contain a file system.
* The i-nodes are fixed-length entries that contain most of the information about a file.
* In the stat structure, **the link count is contained in the st_nlink member**. Its primitive system data type is nlink_t. These types of links are called hard links.
* With a symbolic link, the actual contents of the file—the data blocks—store the name of the file that the symbolic link points to. The file type in the i-node would be **S_IFLNK** so that the system knows that this is a symbolic link.
* The i-node contains all the information about the file: the file type, the file's access permission bits, the size of the file, pointers to the file's data blocks, and so on. Most of the information in the stat structure is obtained from the i-node. Only two items of interest are stored in the directory entry: the filename and the i-node number.
* Because the i-node number in the directory entry points to an i-node in the same file system, we cannot have a directory entry point to an i-node in a different file system. This is why the ln(1) command can't cross file systems.
* When renaming a file without changing file systems, the actual contents of the file need not be moved— all that needs to be done is to add a new directory entry that points to the existing i-node, and then unlink the old directory entry.
* Any leaf directory (a directory that does not contain any other directories) always has a link count of 2. The value of 2 is from the directory entry that names the directory and from the entry for dot in that directory.
* Every subdirectory in a parent directory causes the parent directory's link count to be increased by 1.

## 4.15. link, unlink, remove, and rename Functions
```
int link(const char *existingpath, const char *newpath);
```
* This function creates a new directory entry, newpath, that references the existing file existingpath. **If the newpath already exists, an error is returned**. Only the last component of the newpath is created. **The rest of the path must already exist.**
* The creation of the new directory entry and the increment of the link count must be an atomic operation.
*  If an implementation supports the creation of hard links to directories, it is restricted to only the superuser. The reason is that doing this can cause loops in the file system, which most utilities that process the file system aren't capable of handling. 
```
int unlink(const char *pathname);
```
* This function removes the directory entry and decrements the link count of the file referenced by pathname.
* When a file is closed, the kernel first checks the count of the number of processes that have the file open. If this count has reached 0, the kernel then checks the link count; if it is 0, the file's contents are deleted.
* If pathname is a symbolic link, unlink removes the symbolic link, not the file referenced by the link. There is no function to remove the file referenced by a symbolic link given the name of the link.
* The superuser can call unlink with pathname specifying a directory, but the function rmdir should be used instead to unlink a directory.
```
int remove(const char *pathname);
```
* We can also unlink a file or a directory with the remove function. **For a file, remove is identical to unlink. For a directory, remove is identical to rmdir.**
```
int rename(const char *oldname, const char *newname);
```
* If oldname specifies a file that is not a directory, then we are renaming a file or a symbolic link. In this case, if newname exists, it cannot refer to a directory. If newname exists and is not a directory, it is removed, and oldname is renamed to newname.
* If oldname specifies a directory, then we are renaming a directory. If newname exists, it must refer to a directory, and that directory must be empty. If newname exists and is an empty directory, it is removed, and oldname is renamed to newname.
* If newname exists and is an empty directory, it is removed, and oldname is renamed to newname.
* As a special case, if the oldname and newname refer to the same file, the function returns successfully without changing anything.

## 4.16. Symbolic Links
* A symbolic link is an indirect pointer to a file.
* Symbolic links were introduced to get around the limitations of hard links:
    * Hard links normally require that the link and the file reside in the same file system
    * Only the superuser can create a hard link to a directory
* There are no file system limitations on a symbolic link and what it points to, and anyone can create a symbolic link to a directory.
* If the function follows a symbolic link, a pathname argument to the function refers to the file pointed to by the symbolic link. Otherwise, a pathname argument refers to the link itself, not the file pointed to by the link. 
    | Function |  Does not follow symbolic link |  Follows symbolic link    |  
    | -------- |--------------------------------|---------------------------|
    |  access  |                                |           •               |
    |  chdir   |                                |           •               |   
    |  chmod   |               •                |           •               |                       
    |  chown   |                                |           •               |   
    |  creat   |                                |           •               |        
    |   exec   |                                |           •               |   
    |  lchown  |               •                |           •               |   
    |   link   |                                |           •               |   

    |  lstat   |               •                |                           |
    |  open    |                                |           •               |   
    |  opendir |                                |           •               |                       
    | pathconf |                                |           •               |   
    | readlink |               •                |                           |        
    |  remove  |               •                |                           |   
    |  rename  |               •                |                           |   
    |   stat   |                                |           •               |   
    | truncate |                                |           •               |  
    |  unlink  |               •                |                           |  
   
    * The functions **mkdir, mkfifo, mknod, and rmdir** are not in this figure, as they return an error when the pathname is a symbolic link. 
    * when the open function is called with both O_CREAT and O_EXCL set. In this case, if the pathname refers to a symbolic link, open will fail with errno set to EEXIST. This behavior is intended to close a security hole so that privileged processes can't be fooled into writing to the wrong files.
    * A loop of this form is easy to remove. We are able to unlink the file foo/testdir, as unlink does not follow a symbolic link. But **if we create a hard link that forms a loop of this type, its removal is much more difficult**. This is why the link function will not form a hard link to a directory unless the process has superuser privileges.


## 4.17. symlink and readlink Functions
```
int symlink(const char *actualpath, const char *sympath);
```
* A symbolic link is created with the symlink function. It is not required that actualpath exist when the symbolic link is created.
```
ssize_t readlink(const char* restrict pathname,
 char *restrict buf, size_t bufsize);
```
* The ```readlink``` function open the link itself and read the name in the link. This function combines the actions of open, read, and close. If the function is successful, it returns the number of bytes placed into buf. The contents of the symbolic link that are returned in buf are not null terminated.

## 4.18. File Times
* Three time fields are maintained for each file:
    |   Field     |             Description                 |    Example    | ls(1) option |
    | ----------- |-----------------------------------------|---------------|--------------|
    |   st_atime  |     last-access time of file data       |     read      |     -u       |
    |   st_mtime  | last-modification time of file data     |     write     |   default    |
    |   st_ctime  | last-change time of i-node status       | chmod, chown  |     -c       |                       
  
* The ```ls``` command displays or sorts only on one of the three time values. By default, when invoked with either the ```-l``` or the ```-t``` option, it uses the **modification time** of a file. The ```-u``` option causes it to use the **access time**, and the ```-c``` option causes it to use the **changed-status time**.


## 4.19. utime Function
```
int utime(const char *pathname, const struct utimbuf *times);
```

* The access time and the modification time of a file can be changed with the utime function.
* The structure used by this function is
    ```
    struct utimbuf {
        time_t actime; /* access time */ time_t modtime; /* modification time */
    }
    ```
* The operation of this function, and the privileges required to execute it, depend on whether the times argument is NULL:
    * If times is a null pointer, the access time and the modification time are both set to the current time. To do this, either the effective user ID of the process must equal the owner ID of the file, or the process must have write permission for the file.
    * If times is a non-null pointer, the access time and the modification time are set to the values in the structure pointed to by times. For this case, the effective user ID of the process must equal the owner ID of the file, or the process must be a superuser process. Merely having write permission for the file is not adequate.

* Note that we are unable to specify a value for the changed-status time, st_ctime—the time the i-node was last changed—as this field is automatically updated when the utime function is called.

## 4.20. mkdir and rmdir Functions
```
int mkdir(const char *pathname, mode_t mode);
```
* This function creates a new, empty directory. The entries for dot and dot-dot are automatically created. The specified file access permissions, mode, are modified by the file mode creation mask of the process.
* For a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within the directory.
```
int rmdir(const char *pathname);
```
* An empty directory is deleted with the rmdir function. Recall that an empty directory is one that contains entries only for dot and dot-dot.
* If the link count of the directory becomes 0 with this call, and if no other process has the directory open, then the space occupied by the directory is freed. If one or more processes have the directory open when the link count reaches 0, the last link is removed and the dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory. The directory is not freed, however, until the last process closes it. 

## 4.21. Reading Directories
* Directories can be read by anyone who has access permission to read the directory. But only the kernel can write to a directory, to preserve file system sanity. The write permission bits and execute permission bits for a directory determine if we can create new files in the directory and remove files from the directory—**they don't specify if we can write to the directory itself.**

```
DIR *opendir(const char *pathname);
struct dirent *readdir(DIR *dp);
void rewinddir(DIR *dp);
int closedir(DIR *dp);
long telldir(DIR *dp);
void seekdir(DIR *dp, long loc);
```
* The dirent structure defined in the file <dirent.h> is implementation dependent. Implementations define the structure to contain at least the following two members:
    ```
    struct dirent {
        ino_t d_ino; /* i-node number */    
        char d_name[NAME_MAX + 1]; /* null-terminated filename */
    }
    ```
* The DIR structure is an internal structure used by these six functions to maintain information about the directory being read. The purpose of the DIR structure is similar to that of the FILE structure maintained by the standard I/O library
* The pointer to a DIR structure that is returned by opendir is then used with the other five functions.

## 4.22. chdir, fchdir, and getcwd Functions
```
int chdir(const char *pathname); 
int fchdir(int filedes);
```
* **The current working directory is an attribute of a process**; the home directory is an attribute of a login name.
* The kernel maintain knowledge of the current working directory, Unfortunately, the kernel doesn't maintain the full pathname of the directory. Instead, the kernel keeps information about the directory, such as a pointer to the directory's v-node.
```
char *getcwd(char *buf, size_t size);
```
* The getcwd function is useful when we have an application that needs to return to the location in the file system where it started out. The fchdir function provides us with an easy way to accomplish this task. Instead of calling getcwd, we can open the current directory and save the file descriptor before we change to a different location in the file system. When we want to return to where we started, we can simply pass the file descriptor to fchdir.

## 4.23. Device Special Files
* Every file system is known by its major and minor device numbers, which are encoded in the primitive system data type dev_t. The major number identifies the device driver; the minor number identifies the specific subdevice. Each file system on the same disk drive would usually have the same major number, but a different minor number.
* We can usually access the major and minor device numbers through two macros defined by most implementations: major and minor. This means that we don't care how the two numbers are stored in a dev_t object.
* The st_dev value for every filename on a system is the device number of the file system containing that filename and its corresponding i-node.
* **Only character special files and block special files have an st_rdev value.** This value contains the device number for the actual device.
* Normally, the only types of devices that are block special files are those that can contain random-access file systems: disk drives, floppy disk drives, and CD-ROMs, for example

# Chapter 5. Standard I/O Library

5.2. Streams and FILE Objects
* In Chapter 3, all the I/O routines centered around file descriptors. With the standard I/O library, the discussion centers around streams.  When we open or create a file with the standard I/O library, we say that we have associated a stream with the file.
* Standard I/O file streams can be used with single-byte and multibyte ("wide") character sets. **A stream's orientation determines whether the characters that are read and written are single-byte or multibyte.** Initially, when a stream is created, it has no orientation.
* Only two functions can change the orientation once set. The freopen function (discussed shortly) will clear a stream's orientation; the fwide function can be used to set a stream's orientation.
```
int fwide(FILE *fp, int mode);
```
    * If the mode argument is negative, fwide will try to make the specified stream byte-oriented.
    * If the mode argument is positive, fwide will try to make the specified stream wide-oriented.
    * If the mode argument is zero, fwide will not try to set the orientation, but will still return a value identifying the stream's orientation.

* When we open a stream, the standard I/O function fopen returns a pointer to a FILE object. This object is normally a structure that contains all the information required by the standard I/O library to manage the stream: **the file descriptor used for actual I/O, a pointer to a buffer for the stream, the size of the buffer, a count of the number of characters currently in the buffer, an error flag, and the like.**

## 5.3. Standard Input, Standard Output, and Standard Error
* These three standard I/O streams are referenced through the predefined file pointers stdin, stdout, and stderr. The file pointers are defined in the <stdio.h> header.

## 5.4. Buffering
* Three types of buffering are provided:
    * **Fully buffered**
        In this case, actual I/O takes place **when the standard I/O buffer is filled**. Files residing on disk are normally fully buffered by the standard I/O library. The buffer used is usually obtained by one of the standard I/O functions calling ```malloc``` the first time I/O is performed on a stream.

        The term flush describes the writing of a standard I/O buffer. A buffer can be flushed automatically by the standard I/O routines, such as when a buffer fills, or we can call the function fflush to flush a stream. 

    * **Line buffered**
        In this case, the standard I/O library performs I/O **when a newline character is encountered on input or output**. This allows us to output a single character at a time (with the standard I/O fputc function), knowing that actual I/O will take place only when we finish writing each line.

        Line buffering comes with two caveats:
        * First, the size of the buffer that the standard I/O library is using to collect each line is fixed
        * Second, whenever input is requested through the standard I/O library from either (a) an unbuffered stream or (b) a line-buffered stream (that requires data to be requested from the kernel), all line-buffered output streams are flushed.

    * **Unbuffered**
        The standard I/O library does not buffer the characters. The standard error stream, for example, is normally unbuffered. This is so that any error messages are displayed as quickly as possible, regardless of whether they contain a newline.

* ISO C requires the following buffering characteristics:
    * Standard input and standard output are fully buffered, if and only if they do not refer to an interactive device.
    * Standard error is never fully buffered.

* We can change the buffering by calling either of the following two functions:
```
void setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
```
    * These functions must be called after the stream has been opened (obviously, since each requires a valid file pointer as its first argument) but before any other operation is performed on the stream.
    * With setvbuf, we specify exactly which type of buffering we want. This is done with the mode argument:
        * _IOFBF: fully buffered 
        * _IOLBF: line buffered 
        * _IONBF: unbuffered
      If we specify an unbuffered stream, the buf and size arguments are ignored. If we specify fully buffered or line buffered, buf and size can optionally specify a buffer and its size. If the stream is buffered and buf is NULL, the standard I/O library will automatically allocate its own buffer of the appropriate size for the stream. By appropriate size, we mean the value specified by the constant BUFSIZ.

* Some C library implementations use the value from the ```st_blksize``` member of the ```stat``` structure to determine the optimal standard I/O buffer size.
* Be aware that if we allocate a standard I/O buffer as an automatic variable within a function, we have to close the stream before returning from the function. 
* In general, we should let the system choose the buffer size and automatically allocate the buffer. When we do this, the standard I/O library automatically releases the buffer when we close the stream.
* This function causes any unwritten data for the stream to be passed to the kernel. As a special case, if fp is NULL, this function causes all output streams to be flushed.
    ```
    int fflush(FILE *fp);
    ```

## 5.5. Opening a Stream
```
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int filedes, const char *type);
```
* The differences in these three functions are as follows:
    * The fopen function opens a specified file.
    * The freopen function opens a specified file on a specified stream, closing the stream first if it is already open. If the stream previously had an orientation, freopen clears it. This function is typically used to open a specified file as one of the predefined streams: standard input, standard output, or standard error.
    * The fdopen function takes an existing file descriptor, which we could obtain from the open, dup, dup2, fcntl, pipe, socket, socketpair, or accept functions, and associates a standard I/O stream with the descriptor. This function is often used with descriptors that are returned by the functions that create pipes and network communication channels. Because these special types of files cannot be opened with the standard I/O fopen function, we have to call the device-specific function to obtain a file descriptor, and then associate this descriptor with a standard I/O stream using fdopen.

    |       type        |                           Description                            |  
    | ----------------- |------------------------------------------------------------------|
    |       r or rb     |                          open for reading                        |   
    |       w or wb     |                truncate to 0 length or create for writing        |  
    |       a or ab     |  append; open for writing at end of file, or create for writing  |    
    |  r+ or r+b or rb+ |                      open for reading and writing                |   
    |  w+ or w+b or wb+ |       truncate to 0 length or create for reading and writing     |  
    |  a+ or a+b or ab+ |       open or create for reading and writing at end of file      |   
     
* Using the character b as part of the type allows the standard I/O system to differentiate between a text file and a binary file. **Since the UNIX kernel doesn't differentiate between these types of files, specifying the character b as part of the type has no effect.**
* With fdopen, the meanings of the type argument differ slightly. The descriptor has already been opened, so opening for write does not truncate the file. (If the descriptor was created by the open function, for example, and the file already existed, the O_TRUNC flag would control whether or not the file was truncated. The fdopen function cannot simply truncate any file it opens for writing.) Also, the standard I/O append mode cannot create the file (since the file has to exist if a descriptor refers to it).
* When a file is opened for reading and writing (the plus sign in the type), the following restrictions apply.
    * Output cannot be directly followed by input without an intervening fflush, fseek, fsetpos,or rewind.
    * Input cannot be directly followed by output without an intervening fseek, fsetpos,or rewind, or an input operation that encounters an end of file.

|                Restriction            | r | w | a | r+ | w+ | a+ |                           
| ------------------------------------- |---|---|---|----|----|----|
|         file must already exist       | • |   |   | •  |    |    |                        
|  previous contents of file discarded  |   | • |   |    | •  |    | 
|           stream can be read          | • |   |   | •  | •  | •  | 
|           stream can be written       |   | • | • | •  | •  | •  | 
|   stream can be written only at end   |   |   | • |    |    | •  | 

* Note that if a new file is created by specifying a type of either w or a, we are not able to specify the file's access permission bits
* By default, the stream that is opened is fully buffered, unless it refers to a terminal device, in which case it is line buffered.
* An open stream is closed by calling fclose:
    ```
    int fclose(FILE *fp);
    ```
    Any buffered output data is flushed before the file is closed. Any input data that may be buffered is discarded.

## 5.6. Reading and Writing a Stream
* Once we open a stream, we can choose from among three types of unformatted I/O:
    * Character-at-a-time I/O. We can read or write one character at a time, with the standard I/O functions handling all the buffering, if the stream is buffered.
    * Line-at-a-time I/O. If we want to read or write a line at a time, we use fgets and fputs. Each line is terminated with a newline character, and we have to specify the maximum line length that we can handle when we call fgets. 
    * Direct I/O. This type of I/O is supported by the fread and fwrite functions. For each I/O operation, we read or write some number of objects, where each object is of a specified size. The term direct I/O, from the ISO C standard, is known by many names: binary I/O, object-at-a-time I/O, record-oriented I/O, or structure-oriented I/O.

* Input Functions
    Three functions allow us to read one character at a time:
    ```
    int getc(FILE *fp);
    int fgetc(FILE *fp);
    int getchar(void);
    ```
    The difference between the first two functions is that getc can be implemented as a macro, whereas fgetc cannot be implemented as a macro. This means three things:
    * The argument to getc should not be an expression with side effects.
    * Since fgetc is guaranteed to be a function, we can take its address. This allows us to pass the address of fgetc as an argument to another function.
    * Calls to fgetc probably take longer than calls to getc, as it usually takes more time to call a function.
    * The reason for requiring an integer return value is so that all possible character values can be returned, along with an indication that either an error occurred or the end of file has been encountered. The constant EOF in <stdio.h> is required to be a negative value. Its value is often –1. 
    This representation also means that **we cannot store the return value from these three functions in a character variable and compare this value later against the constant EOF.**

    > 为什么这三个函数返回 int？因为出错的情况下要返回一个值，这个出错的返回值不能是任何可能的字符。于是返回 unsigned char 不能达到要求。同理，返回char也不行。因此将返回值扩展成int（从unsigned char转换）。这样的话，读取成功的话返回正值，出错情况返回为负值。一般都把EOF定义成-1。

    * Note that these functions return the same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call either ferror or feof.
    ```
    int ferror(FILE *fp);
    int feof(FILE *fp);
    ```

    * In most implementations, two flags are maintained for each stream in the FILE object:
    * An error flag
    * An end-of-file flag

    Both flags are cleared by calling clearerr: ```void clearerr(FILE *fp);```

    * After reading from a stream, we can push back characters by calling ungetc: ```int ungetc(int c, FILE *fp);```
    The characters that are pushed back are returned by subsequent reads on the stream in reverse order of their pushing.

    * Pushback is often used when we're reading an input stream and breaking the input into words or tokens of some form. Sometimes we need to peek at the next character to determine how to handle the current character. It's then easy to push back the character that we peeked at, for the next call to getc to return.

    * When we push characters back with ungetc, they don't get written back to the underlying file or device. They are kept incore in the standard I/O library's buffer for the stream.

* Output Functions
```
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
```
    * Like the input functions, putchar(c) is equivalent to putc(c, stdout), and putc can be implemented as a macro, whereas fputc cannot be implemented as a macro.

## 5.7. Line-at-a-Time I/O
```
char *fgets(char *restrict buf, int n, FILE *restrict fp); 
char *gets(char *buf);
```
    * With fgets, we have to specify the size of the buffer, n. This function reads up through and including the next newline, but no more than n–1 characters, into the buffer. The buffer is terminated with a null byte. If the line, including the terminating newline, is longer than n–1, only a partial line is returned, but the buffer is always null terminated. Another call to fgets will read what follows on the line.
    * **The gets function should never be used.** The problem is that it doesn't allow the caller to specify the buffer size. This allows the buffer to overflow, if the line is longer than the buffer, writing over whatever happens to follow the buffer in memory.
    * An additional difference with gets is that it doesn't store the newline in the buffer, as does fgets.

```
int fputs(const char *restrict str, FILE *restrict fp); 
int puts(const char *str);
```
    * The function fputs writes the null-terminated string to the specified stream. The null byte at the end is not written. Note that this need not be line-at-a-time output, since the string need not contain a newline as the last non-null character.
    * The puts function writes the null-terminated string to the standard output, without writing the null byte. But puts then writes a newline character to the standard output.

## 5.9. Binary I/O
```
size_t fread(void *restrict ptr, size_t size, size_t nobj,
             FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj,
              FILE *restrict fp);
```
* A fundamental problem with binary I/O is that it can be used to read **only data that has been written on the same system.** The norm today is to have heterogeneous systems connected together with networks. It is common to want to write data on one system and process it on another. These two functions won't work, for two reasons:
    * The offset of a member within a structure can differ between compilers and systems, because of different alignment requirements. Indeed, some compilers have an option allowing structures to be packed tightly, to save space with a possible runtime performance penalty, or aligned accurately, to optimize runtime access of each member. This means that even on a single system, the binary layout of a structure can differ, depending on compiler options.
    * The binary formats used to store multibyte integers and floating-point values differ among machine architectures.

## 5.10. Positioning a Stream
```
long ftell(FILE *fp);
int fseek(FILE *fp, long offset, int whence);
void rewind(FILE *fp);

off_t ftello(FILE *fp);
int fseeko(FILE *fp, off_t offset, int whence);

int fgetpos(FILE *restrict fp, fpos_t *restrict pos); 
int fsetpos(FILE *fp, const fpos_t *pos);

```
* There are three ways to position a standard I/O stream:
    * The two functions ftell and fseek. They have been around since V ersion 7, but they assume that a file's position can be stored in a long integer.
    * The two functions ftello and fseeko. They were introduced in the Single UNIX Specification to allow for file offsets that might not fit in a long integer. They replace the long integer with the off_t data type.
    * The two functions fgetpos and fsetpos. They were introduced by ISO C. They use an abstract data type, fpos_t, that records a file's position. This data type can be made as big as necessary to record a file's position.

* Portable applications that need to move to non-UNIX systems should use fgetpos and fsetpos.
* For a binary file, a file's position indicator is measured in bytes from the beginning of the file. The value returned by ftell for a binary file is this byte position.
* ISO C doesn't require an implementation to support the SEEK_END specification for a binary file, as some systems require a binary file to be padded at the end with zeros to make the file size a multiple of some magic number. Under the UNIX System, however, SEEK_END is supported for binary files.
* **For text files, the file's current position may not be measurable as a simple byte offset.** Again, this is mainly under non-UNIX systems that might store text files in a different format. **To position a text file, whence has to be SEEK_SET, and only two values for offset are allowed: 0—meaning rewind the file to its beginning—or a value that was returned by ftell for that file**. A stream can also be set to the beginning of the file with the rewind function.
* The ftello function is the same as ftell, and the fseeko function is the same as fseek, except that the type of the offset is off_t instead of long.

## 5.11. Formatted I/O
* Formatted output is handled by the four printf functions:
    ```
    int printf(const char *restrict format, ...);
    int fprintf(FILE *restrict fp, const char *restrict format, ...);

    int sprintf(char *restrict buf, const char *restrict format, ...);
    int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    ```

    The printf function writes to the standard output, fprintf writes to the specified stream, and sprintf places the formatted characters in the array buf.

    The ```sprintf``` function automatically appends a null byte at the end of the array, but this null byte is not included in the return value.

    Because ```sprintf``` can lead to buffer-overflow problems, ```snprintf``` was introduced. With it, the size of the buffer is an explicit parameter; any characters that would have been written past the end of the buffer are discarded instead. The ```snprintf``` function returns the number of characters that would have been written to the buffer had it been big enough. 

    A conversion specification has four optional components, shown in square brackets below:
    ```%[flags][fldwidth][precision][lenmodifier]convtype```

* Formatted input is handled by the three scanf functions:
    ```
    int scanf(const char *restrict format, ...);
    int fscanf(FILE *restrict fp, const char *restrict format, ...);
    int sscanf(const char *restrict buf, const char *restrict format, ...);
    ```
    The scanf family is used to parse an input string and convert character sequences into variables of specified types. The arguments following the format contain the addresses of the variables to initialize with the results of the conversions.
    
    If a character doesn't match, processing stops, leaving the remainder of the input unread.

## 5.12. Implementation Details
* Under the UNIX System, the standard I/O library ends up calling the I/O routines that we described in Chapter 3. Each standard I/O stream has an associated file descriptor, and we can obtain the descriptor for a stream by calling ```fileno```.
```
int fileno(FILE *fp);
```

## 5.13. Temporary Files
* The ISO C standard defines two functions that are provided by the standard I/O library to assist in creating temporary files.
```
char *tmpnam(char *ptr);  // Returns: pointer to unique pathname
FILE *tmpfile(void);      // Returns: file pointer if OK, NULL on error
```

* The ```tmpnam``` function generates a string that is a valid pathname and that is not the same name as an existing file. This function generates a different pathname each time it is called, up to **TMP_MAX** times. TMP_MAX is defined in <stdio.h>.
* If ptr is NULL, the generated pathname is stored in a static area, and a pointer to this area is returned as the value of the function. Subsequent calls to tmpnam can overwrite this static area. 
* If ptr is not NULL, it is assumed that it points to an array of at least L_tmpnam characters. (The constant L_tmpnam is defined in <stdio.h>.) T
* The tmpfile function creates a temporary binary file (type wb+) that is automatically removed when it is closed or on program termination. Under the UNIX System, it makes no difference that this file is a binary file.
* The standard technique often used by the tmpfile function is to create a unique pathname by calling tmpnam, then create the file, and immediately unlink it. 

* The Single UNIX Specification defines two additional functions as XSI extensions for dealing with temporary files. 
    * The first of these is the tempnam function:
        ```
        char *tempnam(const char *directory, const char *prefix);
        ```
        The tempnam function is a variation of tmpnam that allows the caller to specify both the directory and a prefix for the generated pathname. There are four possible choices for the directory, and the first one that is true is used:
        * If the environment variable TMPDIR is defined, it is used as the directory. (We describe environment variables in Section 7.9.)
        * If directory is not NULL, it is used as the directory.
        * The string P_tmpdir in <stdio.h> is used as the directory.
        * A local directory, usually /tmp, is used as the directory.

        If the prefix argument is not NULL, it should be a string of up to five bytes to be used as the first characters of the filename.
    * The second function that XSI defines is mkstemp. It is similar to tmpfile, but returns an open file descriptor for the temporary file instead of a file pointer.
        ```
        int mkstemp(char *template);
        ```
        The name of the temporary file is selected using the template string. This string is a pathname whose last six characters are set to XXXXXX.

* There is a drawback to using tmpnam and tempnam: **a window exists between the time that the unique pathname is returned and the time that an application creates a file with that name.** During this timing window, another process can create a file of the same name. The tempfile and mkstemp functions should be used instead, as they don't suffer from this problem.

## 5.14. Alternatives to Standard I/O
* The standard I/O library is not perfect. Korn and Vo list numerous defects: some in the basic design, but most in the various implementations:
    * One inefficiency inherent in the standard I/O library is the amount of data copying that takes place. When we use the line-at-a-time functions, fgets and fputs, the data is usually copied twice: once between the kernel and the standard I/O buffer (when the corresponding read or write is issued) and again between the standard I/O buffer and our line buffer.

# Chapter 6. System Data Files and Information
## 6.1. Introduction
* A UNIX system requires numerous data files for normal operation: the password file /etc/passwd and the group file /etc/group are two files that are frequently used by various programs. 
* We want to be able to store these data files in a format other than ASCII text, but still provide an interface for an application program that works with any file format. The portable interfaces to these data files are the subject of this chapter.

## 6.2. Password File
* There are several alternatives to using /dev/null to prevent a particular user from logging in to a system. It is common to see /bin/false used as the login shell. It is also common to see /bin/true used to disable an account. All it does is exit with a successful (zero) status.
* The nobody user name can be used to allow people to log in to a system, but with a user ID (65534) and group ID (65534) that provide no privileges.
* POSIX.1 defines only two functions to fetch entries from the password file. These functions allow us to look up an entry given a user's login name or numerical user ID.
    ```
    struct passwd *getpwuid(uid_t uid);
    struct passwd *getpwnam(const char *name);
    ```
    The ```getpwuid``` function is used by the ls(1) program to map the numerical user ID contained in an i-node into a user's login name. The ```getpwnam``` function is used by the login(1) program when we enter our login name.

    Both functions return a pointer to a passwd structure that the functions fill in. This structure is usually a static variable within the function, so its contents are overwritten each time we call either of these functions

* The following three functions can be used to go through the entire password file:
    ```
    struct passwd *getpwent(void);  // Returns: pointer if OK, NULL on error or end of file
    void setpwent(void);
    void endpwent(void);
    ```
    We call ```getpwent``` to return the next entry in the password file. As with the two POSIX.1 functions, getpwent returns a pointer to a structure that it has filled in. If this is the first call to this function, it opens whatever files it uses. There is no order implied when we use this function; the entries can be in any order.

    The function ```setpwent``` rewinds whatever files it uses, and ```endpwent``` closes these files.

## 6.3. Shadow Passwords
* The encrypted password is a copy of the user's password that has been put through a one-way encryption algorithm. 
* To make it more difficult to obtain the raw materials (the encrypted passwords), systems now store the encrypted password in another file, often called the **shadow password file**.
* The shadow password file should not be readable by the world. Only a few programs need to access encrypted passwords—login and passwd.

## 6.4. Group File
* The UNIX System's group file, called the group database by POSIX.1, contains fields that are contained in a group structure that is defined in <grp.h>.
* The field **gr_mem** is an array of pointers to the user names that belong to this group. This array is terminated by a null pointer.
* We can look up either a group name or a numerical group ID with the following two functions, which are defined by POSIX.1:
    ```
    struct group *getgrgid(gid_t gid);
    struct group *getgrnam(const char *name);
    ```
* If we want to search the entire group file, we need some additional functions. The following three functions are like their counterparts for the password file:
    ```
    struct group *getgrent(void);  // Returns: pointer if OK, NULL on error or end of file
    void setgrent(void);
    void endgrent(void);
    ```

## 6.5. Supplementary Group IDs
```
int getgroups(int gidsetsize, gid_t grouplist[]);
int setgroups(int ngroups, const gid_t grouplist[]);
int initgroups(const char *username, gid_t basegid);
```
* The advantage in using supplementary group IDs is that we no longer have to change groups explicitly. It is not uncommon to belong to multiple groups (i.e., participate in multiple projects) at the same time.
* The setgroups function can be called by the superuser to set the supplementary group ID list for the calling process: grouplist contains the array of group IDs, and ngroups specifies the number of elements in the array. The value of ngroups cannot be larger than **NGROUPS_MAX**.
* The only use of setgroups is usually from the initgroups function, which reads the entire group file—with the functions getgrent, setgrent, and endgrent, which we described earlier—and determines the group membership for username. It then calls setgroups to initialize the supplementary group ID list for the user. One must be superuser to call initgroups, since it calls setgroups. 
* The initgroups function is called by only a few programs: the login(1) program, for example.

## 6.7. Other Data Files
* The general principle is that every data file has at least three functions:
    * A get function that reads the next record, opening the file if necessary. These functions normally return a pointer to a structure. A null pointer is returned when the end of file is reached. Most of the get functions return a pointer to a static structure, so we always have to copy it if we want to save it.
    * A set function that opens the file, if not already open, and rewinds the file. This function is used when we know we want to start again at the beginning of the file.
    * An end entry that closes the data file. As we mentioned earlier, we always have to call this when we're done, to close all the files.

* Additionally, if the data file supports some form of keyed lookup, routines are provided to search for a record with a specific key. For example, two keyed lookup routines are provided for the password file: getpwnam looks for a record with a specific user name, and getpwuid looks for a record with a specific user ID.

## 6.8. Login Accounting
* Two data files that have been provided with most UNIX systems are the utmp file, which keeps track of all the users currently logged in, and the wtmp file, which keeps track of all logins and logouts. With Version 7, one type of record was written to both files, a binary record consisting of the following structure:
    ```
    struct utmp {
        char ut_line[8]; /* tty line: "ttyh0", "ttyd0", "ttyp0", ... */ 
        char ut_name[8]; /* login name */
        long ut_time; /* seconds since Epoch */
    };
    ```

* On login, one of these structures was filled in and written to the utmp file by the login program, and the same structure was appended to the wtmp file.
* On logout, the entry in the utmp file was erased—filled with null bytes—by the init process, and a new entry was appended to the wtmp file. This logout entry in the wtmp file had the ut_name field zeroed out. Special entries were appended to the wtmp file to indicate when the system was rebooted and right before and after the system's time and date was changed.
* The who(1) program read the utmp file and printed its contents in a readable form. Later versions of the UNIX System provided the last(1) command, which read through the wtmp file and printed selected entries.
* On FreeBSD 5.2.1, Linux 2.4.22, and Mac OS X 10.3, the utmp(5) manual page gives the format of their versions of these login records. The pathnames of these two files are /var/run/utmp and /var/log/wtmp.

## 6.9. System Identification
* POSIX.1 defines the uname function to return information on the current host and operating system.
    ```
    int uname(struct utsname *name);
    ```
* We pass the address of a utsname structure, and the function fills it in. POSIX.1 defines only the minimum fields in the structure, which are all character arrays, and it's up to each implementation to set the size of each array. 
    ```
    struct utsname {
        char  sysname[];
        char  nodename[];
        char  release[];
        char  version[];
        char  machine[];
    };
    ```
    The information in the utsname structure can usually be printed with the uname(1) command.

* Historically, BSD-derived systems provide the gethostname function to return only the name of the host. This name is usually the name of the host on a TCP/IP network.
    ```
    int gethostname(char *name, int namelen);
    ```

    The namelen argument specifies the size of the name buffer. If enough space is provided, the string returned through name is null terminated. If insufficient room is provided, however, it is unspecified whether the string is null terminated.

* The gethostname function, now defined as part of POSIX.1, specifies that the maximum host name length is **HOST_NAME_MAX**. 

* There is also a hostname(1) command that can fetch or set the host name. The host name is normally set at bootstrap time from one of the start-up files invoked by /etc/rc or init.


## 6.10. Time and Date Routines

* The UNIX System has always differed from other operating systems in:
    * keeping time in UTC instead of the local time
    * automatically handling conversions, such as daylight saving time
    * keeping the time and date as a single quantity.

* The time function returns the current time and date:
    ```
    time_t time(time_t *calptr);
    ```

    The time value is always returned as the value of the function. If the argument is non- null, the time value is also stored at the location pointed to by calptr.

* The gettimeofday function provides greater resolution (up to a microsecond) than the time function. This is important for some applications.
    ```
    int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
    ```

    The only legal value for tzp is NULL; other values result in unspecified behavior.

    The gettimeofday function stores the current time as measured from the Epoch in the memory pointed to by tp. This time is represented as a timeval structure, which stores seconds and microseconds:
        ```
        struct timeval {
           time_t tv_sec;    /* seconds */
           long   tv_usec;   /* microseconds */
        };
        ```

* The two functions ```localtime``` and ```gmtime``` convert a calendar time into what's called a broken-down time, a tm structure:
    ```
    struct tm *gmtime(const time_t *calptr); 
    struct tm *localtime(const time_t *calptr);
    ```
    ```
    struct tm {         /* a broken-down time */
        int  tm_sec;    /* seconds after the minute: [0 - 60] */
        int  tm_min;    /* minutes after the hour: [0 - 59] */
        int  tm_hour;   /* hours after midnight: [0 - 23] */
        int  tm_mday;   /*dayofthemonth:[1-31]*/
        int  tm_mon;    /* months since January: [0 - 11] */
        int  tm_year;   /* years since 1900 */
        int  tm_wday;   /* days since Sunday: [0 - 6] */
        int  tm_yday;   /* days since January 1: [0 - 365] */
        int  tm_isdst;  /* daylight saving time flag: <0, 0, >0 */
    };
    ```

    The reason that the seconds can be greater than 59 is to allow for a leap second. Note that all the fields except the day of the month are 0-based. The daylight saving time flag is positive if daylight saving time is in effect, 0 if it's not in effect, and negative if the information isn't available.

    The difference between localtime and gmtime is that the first converts the calendar time to the local time, taking into account the local time zone and daylight saving time flag, whereas the latter converts the calendar time into a broken-down time expressed as UTC.
    
* The function mktime takes a broken-down time, expressed as a local time, and converts it into a time_t value.
    ```
    time_t mktime(struct tm *tmptr);
    ```

* The asctime and ctime functions produce the familiar 26-byte string that is similar to the default output of the date(1) command: ```Tue Feb 10 18:27:38 2004\n\0```
    ```
    char *asctime(const struct tm *tmptr); 
    char *ctime(const time_t *calptr);
    ```
 
* The final time function, strftime, is the most complicated. It is a printf-like function for time values.
    ```
    size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format,
                const struct tm *restrict tmptr);
    ```

    The final argument is the time value to format, specified by a pointer to a broken-down time value. The formatted result is stored in the array buf whose size is maxsize characters. If the size of the result, including the terminating null, fits in the buffer, the function returns the number of characters stored in buf, excluding the terminating null. Otherwise, the function returns 0.


# Chapter 7. Process Environment

## 7.2. main Function
* A C program starts execution with a function called main. The prototype for the main function is

    ```int main(int argc, char *argv[]);```

    where argc is the number of command-line arguments, and argv is an array of pointers to the arguments.

* When a C program is executed by the kernel—by one of the exec functions, a special start-up routine is called before the main function is called. The executable program file specifies this routine as the starting address for the program; this is set up by the link editor when it is invoked by the C compiler. This start-up routine takes values from the kernel—the command-line arguments and the environment—and sets things up so that the main function is called as shown earlier.

## 7.3. Process Termination
* There are eight ways for a process to terminate. Normal termination occurs in five ways:
    * Return from main
    * Calling exit
    * Calling _exit or _Exit
    * Return of the last thread from its start routine 
    * Calling pthread_exit from the last thread

    Abnormal termination occurs in three ways:
    * Calling abort 
    * Receipt of a signal 
    * Response of the last thread to a cancellation request 

* The start-up routine that we mentioned in the previous section is also written so that if the main function returns, the exit function is called. 

* Three functions terminate a program normally: _exit and _Exit, which return to the kernel immediately, and exit, which performs certain cleanup processing and then returns to the kernel:
    ```
    void exit(int status);  // #include <stdlib.h>
    void _Exit(int status); // #include <stdlib.h>
    void _exit(int status); // #include <unistd.h>
    ```

    The reason for the different headers is that exit and _Exit are specified by ISO C, whereas _exit is specified by POSIX.1.

    The ```exit``` function has always performed a clean shutdown of the standard I/O library: the ```fclose``` function is called for all open streams.

    Most UNIX System shells provide a way to examine the exit status of a process. If

    * any of these functions is called without an exit status
    * main does a return without a return value, or 
    * the main function is not declared to return an integer
    
    the exit status of the process is undefined. However, if the return type of main is an integer and main "falls off the end" (an implicit return), the exit status of the process is 0.

* With ISO C, a process can register up to 32 functions that are automatically called by exit. These are called exit handlers and are registered by calling the atexit function:
    ```
    int atexit(void (*func)(void));
    ```

    The exit function calls these functions in reverse order of their registration. Each function is called as many times as it was registered.

    ISO C requires that systems support at least 32 exit handlers. The ```sysconf``` function can be used to determine the maximum number of exit handlers supported by a given platform.

    With ISO C and POSIX.1, exit first calls the exit handlers and then closes (via fclose) all open streams. POSIX.1 extends the ISO C standard by specifying that any exit handlers installed will be cleared if the program calls any of the exec family of functions.

    Note that the only way a program is executed by the kernel is when one of the exec functions is called. The only way a process voluntarily terminates is when _exit or _Exit is called, either explicitly or implicitly (by calling exit). A process can also be involuntarily terminated by a signal.


## 7.4. Command-Line Arguments
* We are guaranteed by both ISO C and POSIX.1 that argv[argc] is a null pointer. This lets us alternatively code the argument-processing loop as
    ```
    for (i = 0; argv[i] != NULL; i++)
    ```

## 7.5. Environment List
* Each program is also passed an environment list. Like the argument list, the environment list is an array of character pointers, with each pointer containing the address of a null-terminated C string. The address of the array of pointers is contained in the global variable environ: ```extern char **environ;```
* Access to specific environment variables is normally through the getenv and putenv functions, instead of through the environ variable. But to go through the entire environment, the environ pointer must be used.

## 7.6. Memory Layout of a C Program
* Historically, a C program has been composed of the following pieces:
    * Text segment, the machine instructions that the CPU executes. Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. Also, the text segment is often read-only, to prevent a program from accidentally modifying its instructions.

    * Initialized data segment, usually called simply the data segment, containing variables that are specifically initialized in the program.
    * Uninitialized data segment, often called the "bss" segment, named after an ancient assembler operator that stood for "block started by symbol." Data in this segment is initialized by the kernel to arithmetic 0 or null pointers before the program starts executing.
    * Stack, where automatic variables are stored, along with information that is saved each time a function is called. Each time a function is called, the address of where to return to and certain information about the caller's environment, such as some of the machine registers, are saved on the stack.  The newly called function then allocates room on the stack for its automatic and temporary variables. This is how recursive functions in C can work. Each time a recursive function calls itself, a new stack frame is used.
    * Heap, where dynamic memory allocation usually takes place. Historically, the heap has been located between the uninitialized data and the stack.

* With Linux on an Intel x86 processor, the text segment starts at location 0x08048000, and the bottom of the stack starts just below 0xC0000000. (The stack grows from higher- numbered addresses to lower-numbered addresses on this particular architecture.) The unused virtual address space between the top of the heap and the top of the stack is large.

* Several more segment types exist in an a.out, containing the symbol table, debugging information, linkage tables for dynamic shared libraries, and the like. These additional sections don't get loaded as part of the program's image executed by a process.
* Note from Figure 7.6 that the contents of the uninitialized data segment are not stored in the program file on disk. This is because the kernel sets it to 0 before the program starts running. The only portions of the program that need to be saved in the program file are the text segment and the initialized data.

* The size(1) command reports the sizes (in bytes) of the text, data, and bss segments.

## 7.7. Shared Libraries
* Shared libraries remove the common library routines from the executable file, instead maintaining a single copy of the library routine somewhere in memory that all processes reference. This reduces the size of each executable file but may add some runtime overhead, either when the program is first executed or the first time each shared library function is called.
* Another advantage of shared libraries is that library functions can be replaced with new versions without having to relink edit every program that uses the library. 

## 7.8. Memory Allocation
```
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size); 
void *realloc(void *ptr, size_t newsize);
void free(void *ptr);
```
* ISO C specifies three functions for memory allocation:
    * **malloc**, which allocates a specified number of bytes of memory. The initial value of the memory is indeterminate.
    * **calloc**, which allocates space for a specified number of objects of a specified size. The space is initialized to all 0 bits.
    * **realloc**, which increases or decreases the size of a previously allocated area. When the size increases, it may involve moving the previously allocated area somewhere else, to provide the additional room at the end. Also, when the size increases, the initial value of the space between the old contents and the end of the new area is indeterminate.

* The pointer returned by the three allocation functions is guaranteed to be suitably aligned so that it can be used for any data object.

* The function free causes the space pointed to by ptr to be deallocated. This freed space is usually put into a pool of available memory and can be allocated in a later call to one of the three alloc functions.

* As a special case, if ptr is a null pointer, realloc behaves like malloc and allocates a region of the specified newsize.

* The allocation routines are usually implemented with the sbrk(2) system call. This system call expands (or contracts) the heap of the process.

* Although sbrk can expand or contract the memory of a process, most versions of malloc and free never decrease their memory size. The space that we free is available for a later allocation, but the freed space is not usually returned to the kernel; that space is kept in the malloc pool.

* It is important to realize that most implementations allocate a little more space than is requested and use the additional space for record keeping—the size of the allocated block, a pointer to the next allocated block, and the like.

* Writing past the end or before the beginning of a dynamically-allocated buffer can corrupt more than internal record-keeping information. The memory before and after a dynamically-allocated buffer can potentially be used for other dynamically-allocated objects. These objects can be unrelated to the code corrupting them, making it even more difficult to find the source of the corruption.

* Other possible errors that can be fatal are freeing a block that was already freed and calling free with a pointer that was not obtained from one of the three alloc functions. If a process calls malloc, but forgets to call free, its memory usage continually increases; this is called leakage. 

* Because memory allocation errors are difficult to track down, some systems provide versions of these functions that do additional error checking every time one of the three alloc functions or free is called.

* One additional function is also worth mentioning. The function ```alloca``` has the same calling sequence as malloc; however, instead of allocating memory from the heap, the memory is allocated from the stack frame of the current function. 

## 7.9. Environment Variables
* ISO C defines a function that we can use to fetch values from the environment, but this standard says that the contents of the environment are implementation defined.
    ```
    char *getenv(const char *name);
    ```

    We should always use getenv to fetch a specific value from the environment, instead of accessing environ directly.

* The prototypes for the middle three functions listed in Figure 7.8 are:
    ```
    int putenv(char *str);
    int setenv(const char *name, const char *value, int rewrite);
    int unsetenv(const char *name);
    ```

    The operation of these three functions is as follows.
    * The ```putenv``` function takes a string of the form name=value and places it in the environment list. If name already exists, its old definition is first removed.
    * The ```setenv``` function sets name to value. If name already exists in the environment, then (a) if rewrite is nonzero, the existing definition for name is first removed; (b) if rewrite is 0, an existing definition for name is not removed, name is not set to the new value, and no error occurs.
    * The ```unsetenv``` function removes any definition of name. It is not an error if such a definition does not exist.

    Note the difference between putenv and setenv. Whereas setenv must allocate memory to create the name=value string from its arguments, putenv is free to place the string passed to it directly into the environment.  In this case, it would be an error to pass it a string allocated on the stack, since the memory would be reused after we return from the current function.

* It is interesting to examine how these functions must operate when modifying the environment list. Recall Figure 7.6: the environment list—the array of pointers to the actual name=value strings—and the environment strings are typically stored at the top of a process's memory space, above the stack. 

    Deleting a string is simple; we simply find the pointer in the environment list and move all subsequent pointers down one. But adding a string or modifying an existing string is more difficult. The space at the top of the stack cannot be expanded, because it is often at the top of the address space of the process and so can't expand upward; it can't be expanded downward, because all the stack frames below it can't be moved.

    * If we're modifying an existing name:
        * If the size of the new value is less than or equal to the size of the existing value, we can just copy the new string over the old string.
        * If the size of the new value is larger than the old one, however, we must malloc to obtain room for the new string, copy the new string to this area, and then replace the old pointer in the environment list for name with the pointer to this allocated area.

    * If we're adding a new name, it's more complicated. First, we have to call malloc to allocate room for the name=value string and copy the string to this area.
        * Then, if it's the first time we've added a new name, we have to call malloc to obtain room for a new list of pointers. We copy the old environment list to this new area and store a pointer to the name=value string at the end of this list of pointers. We also store a null pointer at the end of this list, of course. Finally, we set environ to point to this new list of pointers. If the original environment list was contained above the top of the stack, as is common, then we have moved this list of pointers to the heap. But most of the pointers in this list still point to name=value strings above the top of the stack.

        * If this isn't the first time we've added new strings to the environment list, then we know that we've already allocated room for the list on the heap, so we just call realloc to allocate room for one more pointer. The pointer to the new name=value string is stored at the end of the list (on top of the previous null pointer), followed by a null pointer.

## 7.10. setjmp and longjmp Functions
* In C, we can't goto a label that's in another function. Instead, we must use the ```setjmp``` and ```longjmp``` functions to perform this type of branching. As we'll see, these two functions are useful for handling error conditions that occur in a deeply nested function call.
```
int setjmp(jmp_buf env);
void longjmp(jmp_buf env, int val);
```
* An automatic variable can never be referenced after the function that declared it returns.
```
FILE *
open_data(void)
{
    FILE    *fp;
    char    databuf[BUFSIZ];
/* setvbuf makes this the stdio buffer */
if ((fp = fopen(DATAFILE, "r")) == NULL) return(NULL);
if (setvbuf(fp, databuf, _IOLBF, BUFSIZ) != 0) return(NULL);
    return(fp);     /* error */
}
```

The problem is that when open_data returns, the space it used on the stack will be used by the stack frame for the next function that is called. But the standard I/O library will still be using that portion of memory for its
stream buffer. 

## 7.11. getrlimit and setrlimit Functions
```
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);
```
* Every process has a set of resource limits, some of which can be queried and changed by the ```getrlimit``` and ```setrlimit``` functions.
* The resource limits for a process are normally established by process 0 when the system is initialized and then inherited by each successive process. Each implementation has its own way of tuning the various limits.
* Each call to these two functions specifies a single resource and a pointer to the following structure:
```
struct rlimit {
    rlim_t rlim_cur; /* soft limit: current limit */
    rlim_t rlim_max; /* hard limit: maximum value for rlim_cur */
};
```
    Three rules govern the changing of the resource limits.
    * A process can change its soft limit to a value less than or equal to its hard limit.
    * A process can lower its hard limit to a value greater than or equal to its soft limit. This lowering of the hard limit is irreversible for normal users.
    * Only a superuser process can raise a hard limit.

# Chapter 8. Process Control

## 8.2. Process Identifiers
* Every process has a unique process ID, a non-negative integer. Because the process ID is the only well-known identifier of a process that is always unique, it is often used as a piece of other identifiers, to guarantee uniqueness. 
* Although unique, process IDs are reused. As processes terminate, their IDs become candidates for reuse. Most UNIX systems implement algorithms to delay reuse.
* There are some special processes, but the details differ from implementation to implementation. Process ID 0 is usually the scheduler process and is often known as the swapper. No program on disk corresponds to this process, which is part of the kernel and is known as a system process.
* Process ID 1 is usually the init process and is invoked by the kernel at the end of the bootstrap procedure.  The program file for this process was /etc/init in older versions of the UNIX System and is /sbin/init in newer versions. This process is responsible for bringing up a UNIX system after the kernel has been bootstrapped. init usually reads the system-dependent initialization files—the /etc/rc* files or /etc/inittab and the files in /etc/init.d—and brings the system to a certain state, such as multiuser. 

     The init process never dies. It is a normal user process, not a system process within the kernel, like the swapper, although it does run with superuser privileges. 
* In addition to the process ID, there are other identifiers for every process. The following functions return these identifiers:
    ```
    pid_t getpid(void);    // Returns: process ID of calling process
    pid_t getppid(void);   // Returns: parent process ID of calling process
    uid_t getuid(void);    // Returns: real user ID of calling process
    uid_t geteuid(void);   // Returns: effective user ID of calling process
    pid_t getpid(void);    // Returns: real group ID of calling process
    gid_t getegid(void);   // Returns: effective group ID of calling process

## 8.3. fork Function
```
pid_t fork(void);  // Returns: 0 in child, process ID of child in parent, –1 on error
```
* An existing process can create a new one by calling the ```fork``` function.
* Process ID 0 is reserved for use by the kernel, so it's not possible for 0 to be the process ID of a child.
* Both the child and the parent continue executing with the instruction that follows the call to fork. The child is a copy of the parent. For example, the child gets a copy of the parent's data space, heap, and stack. Note that this is a copy for the child; the parent and the child do not share these portions of memory. The parent and the child share the text segment.
* Current implementations don't perform a complete copy of the parent's data, stack, and heap, since a fork is often followed by an exec. Instead, a technique called copy-on-write (COW) is used. These regions are shared by the parent and the child and have their protection changed by the kernel to read-only. If either process tries to modify these regions, the kernel then makes a copy of that piece of memory only, typically a "page" in a virtual memory system.
* Solaris 9 provides two threads libraries: one for POSIX threads (pthreads) and one for Solaris threads. The behavior of fork differs between the two thread libraries. For POSIX threads, fork creates a process containing only the calling thread, but for Solaris threads, fork creates a process containing copies of all threads from the process of the calling thread. To provide similar semantics as POSIX threads, Solaris provides the fork1 function, which can be used to create a process that duplicates only the calling thread, regardless of the thread library used. 
* Another difference is that using strlen requires a function call, whereas sizeof calculates the buffer length at compile time, as the buffer is initialized with a known string, and its size is fixed.
* But when we redirect standard output to a file, we get two copies of the printf line. In this second case, the printf before the fork is called once, but the line remains in the buffer when fork is called. This buffer is then copied into the child when the parent's data space is copied to the child. Both the parent and the child now have a standard I/O buffer with this line in it. The second printf, right before the exit, just appends its data to the existing buffer. When each process terminates, its copy of the buffer is finally flushed.
* **One characteristic of fork is that all file descriptors that are open in the parent are duplicated in the child.** The parent and the child share a file table entry for every open descriptor.
* Besides the open files, there are numerous other properties of the parent that are inherited by the child:

	* Real user ID, real group ID, effective user ID, effective group ID
	* Supplementary group IDs
	* Process group ID
	* Session ID
	* Controlling terminal
	* The set-user-ID and set-group-ID flags
	* Current working directory
	* Root directory
	* File mode creation mask
	* Signal mask and dispositions
	* The close-on-exec flag for any open file descriptors
	* Environment
	* Attached shared memory segments
	* Memory mappings
	* Resource limits

	The differences between the parent and child are:
	* The return value from fork
	* The process IDs are different
	* The two processes have different parent process IDs: the parent process ID of the child is the parent; the parent process ID of the parent doesn't change
	* The child's tms_utime, tms_stime, tms_cutime, and tms_cstime values are set to 0
	* File locks set by the parent are not inherited by the child

    Locks created by flock() are associated with an open file description. This means that duplicate file descriptors (created by, for example, fork(2) or dup(2)) refer to the same lock, and this lock may be modified or released using any of these file descriptors. Furthermore, the lock is released either by an explicit LOCK_UN operation on any of these duplicate file descriptors, or when all such file descriptors have been closed.

	* Pending alarms are cleared for the child
	* The set of pending signals for the child is set to the empty set

* The two main reasons for fork to fail are:
	* if too many processes are already in the system, which usually means that something else is wrong, or
	* if the total number of processes for this real user ID exceeds the system's limit.

* There are two uses for fork:
	* When a process wants to duplicate itself so that the parent and child can each execute different sections of code at the same time. This is common for network serversthe parent waits for a service request from a client. When the request arrives, the parent calls fork and lets the child handle the request. The parent goes back to waiting for the next service request to arrive.

	* When a process wants to execute a different program. This is common for shells. In this case, the child does an exec right after it returns from the fork.

* Some operating systems combine the operations from step 2a fork followed by an execinto a single operation called a ```spawn```. The UNIX System separates the two, as there are numerous cases where it is useful to fork without doing an exec. Also, separating the two allows the child to change the per-process attributes between the fork and the exec, such as I/O redirection, user ID, signal disposition, and so on.

* The vfork function is intended to create a new process when the purpose of the new process is to exec a new program. The vfork function creates the new process, just like fork, **without copying the address space of the parent into the child**, as the child won't reference that address space; the child simply calls exec (or exit) right after the vfork. Instead, while the child is running and until it calls either exec or exit, the child runs in the address space of the parent. This optimization provides an efficiency gain on some paged virtual-memory implementations of the UNIX System. (As we mentioned in the previous section, implementations use copy-on-write to improve the efficiency of a fork followed by an exec, but no copying is still faster than some copying.)

* Another difference between the two functions is that vfork guarantees that the child runs first, until the child calls exec or exit. When the child calls either of these functions, the parent resumes. (This can lead to deadlock if the child depends on further actions of the parent before calling either of these two functions.)

* If the child calls exit, the implementation flushes the standard I/O streams. If this is the only action taken by the library, then we will see no difference with the output generated if the child called _exit. If the implementation also closes the standard I/O streams, however, the memory representing the FILE object for the standard output will be cleared out. Because the child is borrowing the parent's address space, when the parent resumes and calls printf, no output will appear and printf will return -1. Note that the parent's STDOUT_FILENO is still valid, as the child gets a copy of the parent's file descriptor array.

## 8.5. exit Functions

* A process can terminate normally in five ways:
	* Executing a return from the main function. As we saw in Section 7.3, this is equivalent to calling exit.
	* Calling the exit function. This function is defined by ISO C and includes the calling of all exit handlers that have been registered by calling atexit and closing all standard I/O streams. Because ISO C does not deal with file descriptors, multiple processes and job control, the definition of this function is incomplete for a UNIX system.
	* Calling the _exit or _Exit function. ISO C defines _Exit to provide a way for a process to terminate without running exit handlers or signal handlers. Whether or not standard I/O streams are flushed depends on the implementation. On UNIX systems, _Exit and _exit are synonymous and do not flush standard I/O streams. The _exit function is called by exit and handles the UNIX system-specific details; _exit is specified by POSIX.1.

	In most UNIX system implementations, exit(3) is a function in the standard C library, whereas _exit(2) is a system call.

	* Executing a return from the start routine of the last thread in the process. The return value of the thread is not used as the return value of the process, however. When the last thread returns from its start routine, the process exits with a termination status of 0.
	* Calling the pthread_exit function from the last thread in the process. As with the previous case, the exit status of the process in this situation is always 0, regardless of the argument passed to pthread_exit.

* Regardless of how a process terminates, the same code in the kernel is eventually executed. This kernel code closes all the open descriptors for the process, releases the memory that it was using, and the like.

* Note that we differentiate between the exit status, which is the argument to one of the three exit functions or the return value from main, and the termination status. The exit status is converted into a termination status by the kernel when _exit is finally called.

* If the parent terminates before the child? The answer is that the init process becomes the parent process of any process whose parent terminates.

* Minimally, this information consists of the process ID, the termination status of the process, and the amount of CPU time taken by the process. In UNIX System terminology, a process that has terminated, but whose parent has not yet waited for it, is called a **zombie**. The ps(1) command prints the state of a zombie process as Z.

* The final condition to consider is this: what happens when a process that has been inherited by init terminates? Does it become a zombie? The answer is "no," because init is written so that whenever one of its children terminates, init calls one of the wait functions to fetch the termination status.

## 8.6. wait and waitpid Functions
```
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```

* When a process terminates, either normally or abnormally, the kernel notifies the parent by sending the SIGCHLD signal to the parent. Because the termination of a child is an asynchronous event, it can happen at any time while the parent is running. This signal is the asynchronous notification from the kernel to the parent. The parent can choose to ignore this signal, or it can provide a function that is called when the signal occurs: a signal handler. The default action for this signal is to be ignored.

* We need to be aware that a process that calls wait or waitpid can:
	* Block, if all of its children are still running
	* Return immediately with the termination status of a child, if a child has terminated and is waiting for its termination status to be fetched
	* Return immediately with an error, if it doesn't have any child processes

* The differences between these two functions are as follows:
	* The wait function can block the caller until a child process terminates, whereas waitpid has an option that prevents it from blocking.
	* The waitpid function doesn't wait for the child that terminates first; it has a number of options that control which process it waits for.

* If a child has already terminated and is a zombie, wait returns immediately with that child's status. Otherwise, it blocks the caller until a child terminates. If the caller blocks and has multiple children, wait returns when one terminates. We can always tell which child terminated, because the process ID is returned by the function.

* For both functions, the argument statloc is a pointer to an integer. If this argument is not a null pointer, the termination status of the terminated process is stored in the location pointed to by the argument. If we don't care about the termination status, we simply pass a null pointer as this argument.

* Traditionally, the integer status that these two functions return has been defined by the implementation, with certain bits indicating the exit status (for a normal return), other bits indicating the signal number (for an abnormal return), one bit to indicate whether a core file was generated, and so on.

* The interpretation of the pid argument for waitpid depends on its value:
	* **pid == 1**: Waits for any child process. In this respect, waitpid is equivalent to wait.
	* **pid > 0** : Waits for the child whose process ID equals pid.
	* **pid == 0**: Waits for any child whose process group ID equals that of the calling process.
	* **pid < 1** : Waits for any child whose process group ID equals the absolute value of pid.

* With wait, the only real error is if the calling process has no children. (Another error return is possible, in case the function call is interrupted by a signal.) With waitpid, however, it's also possible to get an error if the specified process or process group does not exist or is not a child of the calling process.

* The options argument lets us further control the operation of waitpid. This argument is either 0 or is constructed from the bitwise OR of the constants in:
	| WCONTINUED| If the implementation supports job control, the status of any child specified by pid that has been continued after being stopped, but whose status has not yet been reported, is returned (XSI extension to POSIX.1). |
	| WNOHANG	| The waitpid function will not block if a child specified by pid is not immediately available. In this case, the return value is 0. |
	| WUNTRACED | If the implementation supports job control, the status of any child specified by pid that has stopped, and whose status has not been reported since it has stopped, is returned. The WIFSTOPPED macro determines whether the return value corresponds to a stopped child process. |

* Recall our discussion about zombie processes. If we want to write a process so that it forks a child but we don't want to wait for the child to complete and we don't want the child to become a zombie until we terminate, the trick is to **call fork twice**.

## 8.8. wait3 and wait4 Functions
* The only feature provided by these two functions that isn't provided by the wait, waitid, and waitpid functions is an additional argument that allows the kernel to return a summary of the resources used by the terminated process and all its child processes.
* The resource information includes such statistics as the amount of user CPU time, the amount of system CPU time, number of page faults, number of signals received, and the like.

## 8.9. Race Conditions
* To avoid race conditions and to avoid polling, some form of signaling is required between multiple processes. Signals can be used. Various forms of interprocess communication (IPC) can also be used.

## 8.10. exec Functions
```
// All six return: –1 on error, no return on success
int execl(const char *path, const char *arg, ...
                       /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
                       /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                       char *const envp[]);
```
* When a process calls one of the exec functions, that process is completely replaced by the new program, and the new program starts executing at its main function. The process ID does not change across an exec, because a new process is not created; exec merely replaces the current process its text, data, heap, and stack segments with a brand new program from disk.

* The first difference in these functions is that the first four take a pathname argument, whereas the last two take a filename argument. When a filename argument is specified
	* If filename contains a slash, it is taken as a pathname.
	* Otherwise, the executable file is searched for in the directories specified by the PATH environment variable.

* There are security reasons for never including the current directory in the search path.
* If either execlp or execvp finds an executable file using one of the path prefixes, but the file isn't a machine executable that was generated by the link editor, the function assumes that the file is a shell script and tries to invoke /bin/sh with the filename as input to the shell.

* The final difference is the passing of the environment list to the new program. The two functions whose names end in an e (execle and execve) allow us to pass a pointer to an array of pointers to the environment strings. The other four functions, however, use the environ variable in the calling process to copy the existing environment for the new program.

* Every system has a limit on the total size of the argument list and the environment list. This limit is given by ARG_MAX. This value must be at least 4,096 bytes on a POSIX.1 system.

* We've mentioned that the process ID does not change after an exec, but the new program inherits additional properties from the calling process:
	* Process ID and parent process ID
	* Real user ID and real group ID
	* Supplementary group IDs
	* Process group ID
	* Session ID
	* Controlling terminal
	* Time left until alarm clock
	* Current working directory
	* Root directory
	* File mode creation mask
	* File locks
	* Process signal mask
	* Pending signals
	* Resource limits
	* Values for tms_utime, tms_stime, tms_cutime, and tms_cstime

* The handling of open files depends on the value of the close-on-exec flag for each descriptor. Every open descriptor in a process has a close-on-exec flag. If this flag is set, the descriptor is closed across an exec. Otherwise, the descriptor is left open across the exec.
* POSIX.1 specifically requires that open directory streams (recall the opendir function from Section 4.21) be closed across an exec. This is normally done by the opendir function calling fcntl to set the close-on-exec flag for the descriptor corresponding to the open directory stream.
* Note that the real user ID and the real group ID remain the same across the exec, but the effective IDs can change, depending on the status of the set-user-ID and the set- group-ID bits for the program file that is executed. If the set-user-ID bit is set for the new program, the effective user ID becomes the owner ID of the program file. Otherwise, the effective user ID is not changed (it's not set to the real user ID). The group ID is handled in the same way.
* In many UNIX system implementations, only one of these six functions, execve, is a system call within the kernel. The other five are just library functions that eventually invoke this system call.

## 8.11. Changing User IDs and Group IDs
```
int setuid(uid_t uid);
int setgid(gid_t gid);
```
* We can set the real user ID and effective user ID with the setuid function. Similarly, we can set the real group ID and the effective group ID with the setgid function.
* There are rules for who can change the IDs. Let's consider only the user ID for now. (Everything we describe for the user ID also applies to the group ID.)
	* If the process has superuser privileges, the setuid function sets the real user ID, effective user ID, and saved set-user-ID to uid.
	* If the process does not have superuser privileges, but uid equals either the real user ID or the saved set-user-ID, setuid sets only the effective user ID to uid. The real user ID and the saved set-user-ID are not changed.
	* If neither of these two conditions is true, errno is set to EPERM, and 1 is returned.

* We can make a few statements about the three user IDs that the kernel maintains:
	* Only a superuser process can change the real user ID. Normally, the real user ID is set by the login(1) program when we log in and never changes. Because login is a superuser process, it sets all three user IDs when it calls setuid.
	* The effective user ID is set by the exec functions only if the set-user-ID bit is set for the program file. If the set-user-ID bit is not set, the exec functions leave the effective user ID as its current value. We can call setuid at any time to set the effective user ID to either the real user ID or the saved set-user-ID. Naturally, we can't set the effective user ID to any random value.
	* The saved set-user-ID is copied from the effective user ID by exec. If the file's set-user-ID bit is set, this copy is saved after exec stores the effective user ID from the file's user ID.

* Note that we can obtain only the current value of the real user ID and the effective user ID with the functions ```getuid``` and ```geteuid```. We can't obtain the current value of the saved set-user-ID.

* Historically, BSD supported the swapping of the real user ID and the effective user ID with the setreuid function.
    ```
    int setreuid(uid_t ruid, uid_t euid); 
    int setregid(gid_t rgid, gid_t egid);
    ```
    We can supply a value of –1 for any of the arguments to indicate that the corresponding ID should remain unchanged.
    Be aware, however, that when programs that used this feature spawned a shell, they had to set the real user ID to the normal user ID before the exec.

* POSIX.1 includes the two functions seteuid and setegid. These functions are similar to setuid and setgid,
but only the effective user ID or effective group ID is changed.
    ```
    int seteuid(uid_t uid);
    int setegid(gid_t gid);
    ```
    An unprivileged user can set its effective user ID to either its real user ID or its saved set-user-ID. For a privileged user, only the effective user ID is set to uid. 

* Everything that we've said so far in this section also applies in a similar fashion to group IDs. The supplementary group IDs are not affected by setgid, setregid, or setegid.

## 8.12. Interpreter Files
* All contemporary UNIX systems support interpreter files. These files are text files that begin with a line of the form
    
```#! pathname [ optional-argument ]```

* The pathname is normally an absolute pathname, since no special operations are performed on it (i.e., PATH is not used). The recognition of these files is done within the kernel as part of processing the exec system call. The actual file that gets executed by the kernel is not the interpreter file, but the file specified by the pathname on the first line of the interpreter file.

* Be aware that systems place a size limit on the first line of an interpreter file. This limit includes the #!, the pathname, the optional argument, the terminating newline, and any spaces.

* Interpreter files are useful for the following reasons:
    * They hide that certain programs are scripts in some other language. 
    * Interpreter scripts provide an efficiency gain. 
    * Interpreter scripts let us write shell scripts using shells other than /bin/sh. When it finds an executable file that isn't a machine executable, execlp has to choose a shell to invoke, and it always uses /bin/sh.

## 8.13. system Function
```
int system(const char *cmdstring);
```
* If cmdstring is a null pointer, system returns nonzero only if a command processor is available. This feature determines whether the system function is supported on a given operating system. Under the UNIX System, system is always available.
* Because system is implemented by calling fork, exec, and waitpid, there are three types of return values.
    * If either the fork fails or waitpid returns an error other than EINTR, system returns –1 with errno set to indicate the error.
    * If the exec fails, implying that the shell can't be executed, the return value is as if the shell had executed exit(127).
    * Otherwise, all three functions—fork, exec, and waitpid—succeed, and the return value from system is the termination status of the shell, in the format specified for waitpid.

* What happens if we call system from a set-user-ID program? Doing so is a security hole and should never be done. The superuser permissions that we gave the tsys program are retained across the fork and exec that are done by system. The system function should never be used from a set-user-ID or a set-group-ID program.

    One reason for this admonition is that system invokes the shell to parse the command string, and the shell uses its IFS variable as the input field separator. Older versions of the shell didn't reset this variable to a normal set of characters when invoked. This allowed a malicious user to set IFS before system was called, causing system to execute a different program.

## 8.14. Process Accounting
* Most UNIX systems provide an option to do process accounting. When enabled, the kernel writes an accounting record each time a process terminates. These accounting records are typically a small amount of binary data with the name of the command, the amount of CPU time used, the user ID and group ID, the starting time, and so on.
* A superuser executes accton with a pathname argument to enable accounting. The accounting records are written to the specified file, which is usually /var/account/acct on FreeBSD and Mac OS X, /var/account/pacct on Linux, and /var/adm/pacct on Solaris. Accounting is turned off by executing accton without any arguments.
* The structure of the accounting records is defined in the header <sys/acct.h> and looks something like
```
typedef  u_short comp_t;   /* 3-bit base 8 exponent; 13-bit fraction */

struct  acct
{
  char   ac_flag;     /* flag (see Figure 8.26) */
  char   ac_stat;     /* termination status (signal & core flag only) */
                      /* (Solaris only) */
  uid_t  ac_uid;      /* real user ID */
  gid_t  ac_gid;      /* real group ID */
  dev_t  ac_tty;      /* controlling terminal */
  time_t ac_btime;    /* starting calendar time */
  comp_t ac_utime;    /* user CPU time (clock ticks) */
  comp_t ac_stime;    /* system CPU time (clock ticks) */
  comp_t ac_etime;    /* elapsed time (clock ticks) */
  comp_t ac_mem;      /* average memory usage */
  comp_t ac_io;       /* bytes transferred (by read and write) */
                      /* "blocks" on BSD systems */
  comp_t ac_rw;       /* blocks read or written */
                      /* (not present on BSD systems) */
  char   ac_comm[8];  /* command name: [8] for Solaris, */
                      /* [10] for Mac OS X, [16] for FreeBSD, and */
                      /* [17] for Linux */
};
```
* The accounting records correspond to processes, not programs. A new record is initialized by the kernel for the child after a fork, not when a new program is executed. Although exec doesn't create a new accounting record, the command name changes, and the AFORK flag is cleared. This means that if we have a chain of three programsA execs B, then B execs C, and C exitsonly a single accounting record is written. The command name in the record corresponds to program C, but the CPU times, for example, are the sum for programs A, B, and C.
* Note that the ac_stat member is not the true termination status of the process, but corresponds to a portion of the termination status that we discussed in Section 8.6. The only information in this byte is a core-flag bit (usually the high-order bit) and the signal number (usually the seven low-order bits), if the process terminated abnormally. If the process terminated normally, we are not able to obtain the exit status from the accounting file.

## 8.15. User Identification
```
char *getlogin(void);
```
* This function can fail if the process is not attached to a terminal that a user logged in to. We normally call these processes daemons.
* To find the login name, UNIX systems have historically called the ttyname function (Section 18.9) and then tried to find a matching entry in the utmp file.
* The environment variable LOGNAME is usually initialized with the user's login name by login(1) and inherited by the login shell. Realize, however, that a user can modify an environment variable, so we shouldn't use LOGNAME to validate the user in any way.

## 8.16. Process Times
```
clock_t times(struct tms *buf);

struct tms {
    clock_t tms_utime; /* user CPU time */
    clock_t tms_stime; /* system CPU time */
    clock_t tms_cutime; /* user CPU time, terminated children */ 
    clock_t tms_cstime; /* system CPU time, terminated children */
};
```
* Any process can call the times function to obtain these values for itself and any terminated children.
* Note that the structure does not contain any measurement for the wall clock time. Instead, the function returns the wall clock time as the value of the function, each time it's called. This value is measured from some arbitrary point in the past, so we can't use its absolute value; instead, we use its relative value.
* The two structure fields for child processes contain values only for children that we have waited for with wait, waitid, or waitpid.
* All the clock_t values returned by this function are converted to seconds using the number of clock ticks per second—the _SC_CLK_TCK value returned by sysconf
* Most implementations provide the getrusage(2) function. This function returns the CPU times and 14 other values indicating resource usage.

# Chapter 9. Process Relationships












## 10.7. SIGCLD Semantics
* This older handling of SIGCLD consists of the following.
    * If the process specifically sets its disposition to SIG_IGN, children of the calling process will not generate zombie processes. Note that this is different from its default action (SIG_DFL). Instead, on termination, the status of these child processes is discarded. If it subsequently calls one of the wait functions, the calling process will block until all its children have terminated, and then wait returns –1 with errno set to ECHILD.
    * If we set the disposition of SIGCLD to be caught, the kernel immediately checks whether any child processes are ready to be waited for and, if so, calls the SIGCLD handler.

## 10.8. Reliable-Signal Terminology and Semantics
* A signal is generated for a process (or sent to a process) when the event that causes the signal occurs. The event could be a hardware exception (e.g., divide by 0), a software condition (e.g., an alarm timer expiring), a terminal-generated signal, or a call to the kill function. When the signal is generated, the kernel usually sets a flag of some form in the process table.
* A signal is delivered to a process when the action for a signal is taken. During the time between the generation of a signal and its delivery, the signal is said to be pending.
* A process has the option of blocking the delivery of a signal. If a signal that is blocked is generated for a process, and if the action for that signal is either the default action or to catch the signal, then the signal remains pending for the process until the process either (a) unblocks the signal or (b) changes the action to ignore the signal. 
* The system determines what to do with a blocked signal when the signal is delivered, not when it's generated. This allows the process to change the action for the signal before it's delivered.
* What happens if a blocked signal is generated more than once before the process unblocks the signal? POSIX.1 allows the system to deliver the signal either once or more than once. If the system delivers the signal more than once, we say that the signals are queued. Instead, the UNIX kernel simply delivers the signal once.
* What happens if more than one signal is ready to be delivered to a process? POSIX.1 does not specify the order in which the signals are delivered to the process. The Rationale for POSIX.1 does suggest, however, that signals related to the current state of the process be delivered before other signals. (SIGSEGV is one such signal.)
* Each process has a signal mask that defines the set of signals currently blocked from delivery to that process. A process can examine and change its current signal mask by calling sigprocmask. POSIX.1 defines a data type, called sigset_t, that holds a signal set. The signal mask, for example, is stored in one of these signal sets.

## 10.9. kill and raise Functions
```
int kill(pid_t pid, int signo);
int raise(int signo);
```
* The kill function sends a signal to a process or a group of processes. The raise function allows a process to send a signal to itself.
* There are four different conditions for the pid argument to kill:
    * pid > 0   The signal is sent to the process whose process ID is pid.
    * pid == 0  The signal is sent to all processes whose process group ID equals the process group ID of the sender and for which the sender has permission to send the signal. Note that the term all processes excludes an implementation-defined set of system processes. For most UNIX systems, this set of system processes includes the kernel processes and init.
    * pid < 0   The signal is sent to all processes whose process group ID equals the absolute value of pid and for which the sender has permission to send the signal. Again, the set of all processes excludes certain system processes
    * pid == -1 The signal is sent to all processes on the system for which the sender has permission to send the signal. As before, the set of processes excludes certain system processes.

* A process needs permission to send a signal to another process. The superuser can send a signal to any process. For other users, the basic rule is that the real or effective user ID of the sender has to equal the real or effective user ID of the receiver. If the implementation supports _POSIX_SAVED_IDS (as POSIX.1 now requires), the saved set-user-ID of the receiver is checked instead of its effective user ID. There is also one special case for the permission testing: **if the signal being sent is SIGCONT, a process can send it to any other process in the same session.**

* POSIX.1 defines **signal number 0 as the null signal**. If the signo argument is 0, then the normal error checking is performed by kill, but no signal is sent. **This is often used to determine if a specific process still exists.** If we send the process the null signal and it doesn't exist, kill returns –1 and errno is set to ESRCH. Also understand that the test for process existence is not atomic. By the time that kill returns the answer to the caller, the process in question might have exited, so the answer is of limited value.

* If the call to kill causes the signal to be generated for the calling process and if the signal is not blocked, either signo or some other pending, unblocked signal is delivered to the process before kill returns. 

## 10.10. alarm and pause Functions
```
unsigned int alarm(unsigned int seconds);  // Returns: 0 or number of seconds until previously set alarm
```
* The alarm function allows us to set a timer that will expire at a specified time in the future. When the timer expires, the SIGALRM signal is generated. If we ignore or don't catch this signal, its default action is to terminate the process.
* The seconds value is the number of clock seconds in the future when the signal should be generated. Be aware that when that time occurs, the signal is generated by the kernel, but there could be additional time before the process gets control to handle the signal, because of processor scheduling delays.
* There is only one of these alarm clocks per process. If, when we call alarm, a previously registered alarm clock for the process has not yet expired, the number of seconds left for that alarm clock is returned as the value of this function. That previously registered alarm clock is replaced by the new value.
* If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled. The number of seconds left for that previous alarm clock is still returned as the value of the function.
* The pause function suspends the calling process until a signal is caught. The only time pause returns is if a signal handler is executed and that handler returns. In that case, pause returns –1 with errno set to EINTR.
```
static void
sig_alrm(int signo)
{
    /* nothing to do, just return to wake up the pause */ 
}
unsigned int
sleep1(unsigned int nsecs)
{
    if (signal(SIGALRM, sig_alrm) == SIG_ERR) 
        return(nsecs);
    alarm(nsecs);       /* start the timer */
    pause();            /* next caught signal wakes us up */
    return(alarm(0));   /* turn off timer, return unslept time */
}
* This function looks like the sleep function, but this simple implementation has three problems:
    * If the caller already has an alarm set, that alarm is erased by the first call to alarm. We can correct this by looking at the return value from the first call to alarm. If the number of seconds until some previously set alarm is less than the argument, then we should wait only until the previously set alarm expires. If the previously set alarm will go off after ours, then before returning we should reset this alarm to occur at its designated time in the future.
    * We have modified the disposition for SIGALRM. If we're writing a function for others to call, we should save the disposition when we're called and restore it when we're done. We can correct this by saving the return value from signal and resetting the disposition before we return.
    * **There is a race condition between the first call to alarm and the call to pause.** On a busy system, it's possible for the alarm to go off and the signal handler to be called before we call pause. If that happens, the caller is suspended forever in the call to pause (assuming that some other signal isn't caught).

* The SVR2 implementation of sleep used setjmp and longjmp to avoid the race condition described in problem 3 of the previous example.
```
static jmp_buf  env_alrm;
static void
sig_alrm(int signo)
{
    longjmp(env_alrm, 1);
}
unsigned int
sleep2(unsigned int nsecs)
{
    if (signal(SIGALRM, sig_alrm) == SIG_ERR) 
        return(nsecs);
    if (setjmp(env_alrm) == 0) {
        alarm(nsecs);
        pause();
    }
    return(alarm(0));
}
```

There is, however, another subtle problem with the sleep2 function that involves its interaction with other signals. If the SIGALRM interrupts some other signal handler, when we call longjmp, we abort the other signal handler. 

* A common use for alarm, in addition to implementing the sleep function, is to put an upper time limit on operations that can block.
```
static void
sig_alrm(int signo)
{
    /* nothing to do, just return to interrupt the read */ 
}
int
main(void)
{
    int     n;
    char    line[MAXLINE];
    if (signal(SIGALRM, sig_alrm) == SIG_ERR) 
        err_sys("signal(SIGALRM) error");
    alarm(10);
    if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0)
        err_sys("read error");
    alarm(0);
    write(STDOUT_FILENO, line, n);
    exit(0); 
}
```
This sequence of code is common in UNIX applications, but this program has two problems:
    * The program has one of the same flaws that we described before: a race condition between the first call to alarm and the call to read. If the kernel blocks the process between these two function calls for longer than the alarm period, the read could block forever. Most operations of this type use a long alarm period, such as a minute or more, making this unlikely; nevertheless, it is a race condition.
    * If system calls are automatically restarted, the read is not interrupted when the SIGALRM signal handler returns. In this case, the timeout does nothing.

## 10.11. Signal Sets
* We need a data type to represent multiple signals—a signal set. POSIX.1 defines the data type sigset_t to contain a signal set and the following five functions to manipulate signal sets. 
```
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo); 
int sigdelset(sigset_t *set, int signo);
// All four return: 0 if OK, –1 on error

int sigismember(const sigset_t *set, int signo);
// Returns: 1 if true, 0 if false, –1 on error
```
 The function sigemptyset initializes the signal set pointed to by set so that all signals are excluded. The function sigfillset initializes the signal set so that all signals are included. All applications have to call either sigemptyset or sigfillset once for each signal set, before using the signal set.
 Once we have initialized a signal set, we can add and delete specific signals in the set. The function sigaddset adds a single signal to an existing set, and sigdelset removes a single signal from a set. 

## 10.12. sigprocmask Function
* A process can examine its signal mask, change its signal mask, or perform both operations in one step by calling the following function.
```
int sigprocmask(int how, const sigset_t *restrict set,
                sigset_t *restrict oset);
```
 First, if oset is a non-null pointer, the current signal mask for the process is returned through oset.

 Second, if set is a non-null pointer, the ```how``` argument indicates how the current signal mask is modified.

 | SIG_BLOCK    | The new signal mask for the process is the union of its current signal mask and the signal set pointed to by set. That is, set contains the additional signals that we want to block. |
 | SIG_UNBLOCK  | The new signal mask for the process is the intersection of its current signal mask and the complement of the signal set pointed to by set. That is, set contains the signals that we want to unblock. |
 | SIG_SETMASK  | The new signal mask for the process is replaced by the value of the signal set pointed to by set. |

* If set is a null pointer, the signal mask of the process is not changed, and how is ignored.
  
  After calling sigprocmask, if any unblocked signals are pending, at least one of these signals is delivered to the
process before sigprocmask returns. 
 
* The sigprocmask function is defined only for single-threaded processes. A separate function is provided to manipulate a thread's signal mask in a multithreaded process.

## 10.13. sigpending Function
* The sigpending function returns the set of signals that are blocked from delivery and currently pending for the calling process. The set of signals is returned through the set argument.
```
int sigpending(sigset_t *set);
```

## 10.14. sigaction Function
* The sigaction function allows us to examine or modify (or both) the action associated with a particular signal. This function supersedes the signal function from earlier releases of the UNIX System.
```
int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
```
  The argument signo is the signal number whose action we are examining or modifying. If the act pointer is non- null, we are modifying the action. If the oact pointer is non-null, the system returns the previous action for the signal through the oact pointer. 

```
struct sigaction {
  void      (*sa_handler)(int);         /* addr of signal handler, or SIG_IGN, or SIG_DFL */
  sigset_t sa_mask;                     /* additional signals to block */
  int      sa_flags;                    /* signal options, Figure 10.16 */
  void (*sa_sigaction)(int, siginfo_t *, void *); /* alternate handler */
};
```
* When changing the action for a signal, if the sa_handler field contains the address of a signal-catching function (as opposed to the constants SIG_IGN or SIG_DFL), then the sa_mask field specifies a set of signals that are added to the signal mask of the process before the signal-catching function is called. This way, we are able to block certain signals whenever a signal handler is invoked. 
* The operating system includes the signal being delivered in the signal mask when the handler is invoked. Hence, we are guaranteed that whenever we are processing a given signal, another occurrence of that same signal is blocked until we're finished processing the first occurrence.
* Once we install an action for a given signal, that action remains installed until we explicitly change it by calling sigaction.
* The sa_flags field of the act structure specifies various options for the handling of this signal:
  | SA_INTERRUPT | System calls interrupted by this signal are not automatically restarted |
  | SA_NOCLDSTOP | If signo is SIGCHLD, do not generate this signal when a child process stops (job control). This signal is still generated, of course, when a child terminates |
  | SA_NOCLDWAIT | If signo is SIGCHLD, this option prevents the system from creating zombie processes when children of the calling process terminate. If it subsequently calls wait, the calling process blocks until all its child processes have terminated and then returns –1 with errno set to ECHILD. |
  | SA_NODEFER   | When this signal is caught, the signal is not automatically blocked by the system while the signal-catching function executes |
  | SA_ONSTACK   | If an alternate stack has been declared with sigaltstack(2), this signal is delivered to the process on the alternate stack. |
  | SA_RESETHAND | The disposition for this signal is reset to SIG_DFL, and the SA_SIGINFO flag is cleared on entry to the signal-catching function. Setting this flag causes sigaction to behave as if SA_NODEFER is also set.｜
  | SA_RESTART   | System calls interrupted by this signal are automatically restarted. |
  | SA_SIGINFO   | This option provides additional information to a signal handler: a pointer to a siginfo structure and a pointer to an identifier for the process context. |
* The sa_sigaction field is an alternate signal handler used when the SA_SIGINFO flag is used with sigaction. Implementations might use the same storage for both the sa_sigaction field and the sa_handler field, so applications can use only one of these fields at a time. Normally, the signal handler is called as ```void handler(int signo);```, but if the SA_SIGINFO flag is set, the signal handler is called as ```void handler(int signo, siginfo_t *info, void *context);```
  The siginfo_t structure contains information about why the signal was generated. 

```
struct siginfo {
    int    si_signo;    /* signal number */
    int    si_errno;    /* if nonzero, errno value from <errno.h> */
    int    si_code;     /* additional info (depends on signal) */
    pid_t  si_pid;      /* sending process ID */
    uid_t  si_uid;      /* sending process real user ID */
    void  *si_addr;     /* address that caused the fault */
    int    si_status;   /* exit value or signal number */
    long   si_band;     /* band number for SIGPOLL */
/* possibly other fields also */
```
## 10.15. sigsetjmp and siglongjmp Functions
* There is a problem in calling longjmp, however. When a signal is caught, the signal-catching function is entered with the current signal automatically being added to the signal mask of the process. This prevents subsequent occurrences of that signal from interrupting the signal handler. If we longjmp out of the signal handler, what happens to the signal mask for the process?

  Under FreeBSD 5.2.1 and Mac OS X 10.3, setjmp and longjmp save and restore the signal mask. Linux 2.4.22 and Solaris 9, however, do not do this. FreeBSD and Mac OS X provide the functions _setjmp and _longjmp, which do not save and restore the signal mask.

  To allow either form of behavior, POSIX.1 does not specify the effect of setjmp and longjmp on signal masks. Instead, two new functions, sigsetjmp and siglongjmp, are defined by POSIX.1. These two functions should always be used when branching from a signal handler.

  ```
  int sigsetjmp(sigjmp_buf env, int savemask);  // Returns: 0 if called directly, nonzero if returning from a call to siglongjmp
  void siglongjmp(sigjmp_buf env, int val);
  ```

  The only difference between these functions and the setjmp and longjmp functions is that sigsetjmp has an additional argument. If savemask is nonzero, then sigsetjmp also saves the current signal mask of the process in env. When siglongjmp is called, if the env argument was saved by a call to sigsetjmp with a nonzero savemask, then siglongjmp restores the saved signal mask.

* The program in Figure 10.20 demonstrates how the signal mask that is installed by the system when a signal handler is invoked automatically includes the signal being caught. The program also illustrates the use of the sigsetjmp and siglongjmp functions.

  This program demonstrates another technique that should be used whenever siglongjmp is called from a signal handler. We set the variable canjump to a nonzero value only after we've called sigsetjmp. This variable is also examined in the signal handler, and siglongjmp is called only if the flag canjump is nonzero. This provides protection against the signal handler being called at some earlier or later time, when the jump buffer isn't initialized by sigsetjmp.

  Here, we use the data type sig_atomic_t, which is defined by the ISO C standard to be the type of variable that can be written without being interrupted. By this we mean that a variable of this type should not extend across page boundaries on a system with virtual memory and can be accessed with a single machine instruction. We always include the ISO type qualifier volatile for these data types too, since the variable is being accessed by two different threads of control: the main function and the asynchronously executing signal handler.

## 10.16. sigsuspend Function
* What if we want to unblock a signal and then pause, waiting for the previously blocked signal to occur? Assuming that the signal is SIGINT, the incorrect way to do this is
  ```
  sigset_t     newmask, oldmask;

  sigemptyset(&newmask);
  sigaddset(&newmask, SIGINT);

  /* block SIGINT and save current signal mask */
  if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
      err_sys("SIG_BLOCK error");

  /* critical region of code */

  /* reset signal mask, which unblocks SIGINT */
  if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
      err_sys("SIG_SETMASK error");

  /* window is open */
  pause();  /* wait for signal to occur */

  /* continue processing */
  ```
  If the signal is sent to the process while it is blocked, the signal delivery will be deferred until the signal is unblocked. To the application, this can look as if the signal occurs between the unblocking and the pause. If this happens, or if the signal does occur between the unblocking and the pause, we have a problem. Any occurrence of the signal in this window of time is lost in the sense that we might not see the signal again, in which case the pause will block indefinitely. This is another problem with the earlier unreliable signals.

* To correct this problem, we need a way to both reset the signal mask and put the process to sleep in a single atomic operation. This feature is provided by the sigsuspend function.
```
int sigsuspend(const sigset_t *sigmask);
```
  The signal mask of the process is set to the value pointed to by sigmask. Then the process is suspended until a signal is caught or until a signal occurs that terminates the process. If a signal is caught and if the signal handler returns, then sigsuspend returns, and the signal mask of the process is set to its value before the call to sigsuspend.

* Another use of sigsuspend is to wait for a signal handler to set a global variable.
  For portability between non-POSIX systems that support ISO C, and POSIX.1 systems, the only thing we should do within a signal handler is assign a value to a variable of type sig_atomic_t.

* As another example of signals, we show how signals can be used to synchronize a parent and child.

void
abort(void)         /* POSIX-style abort() function */
{
    sigset_t           mask;
    struct sigaction   action;

    /*
     * Caller can't ignore SIGABRT, if so reset to default.
     */
    sigaction(SIGABRT, NULL, &action);
    if (action.sa_handler == SIG_IGN) {
        action.sa_handler = SIG_DFL;
        sigaction(SIGABRT, &action, NULL);
    }
    if (action.sa_handler == SIG_DFL)
        fflush(NULL);           /* flush all open stdio streams */

    /*
     * Caller can't block SIGABRT; make sure it's unblocked.
     */
    sigfillset(&mask);
    sigdelset(&mask, SIGABRT);  /* mask has only SIGABRT turned off */
    sigprocmask(SIG_SETMASK, &mask, NULL);
    kill(getpid(), SIGABRT);    /* send the signal */

    /*
     * If we're here, process caught SIGABRT and returned.
     */
    fflush(NULL);               /* flush all open stdio streams */
    action.sa_handler = SIG_DFL;
    sigaction(SIGABRT, &action, NULL);  /* reset to default */
    sigprocmask(SIG_SETMASK, &mask, NULL);  /* just in case ... */
    kill(getpid(), SIGABRT);                /* and one more time */
    exit(1);    /* this should never be executed ... */
}

## 10.18. system Function
* POSIX.1 requires that system ignore SIGINT and SIGQUIT and block SIGCHLD.
* The delivery of this signal in the parent should be blocked while the system function is executing. Indeed, this is what POSIX.1 specifies. Otherwise, when the child created by system terminates, it would fool the caller of system into thinking that one of its own children terminated. The caller would then use one of the wait functions to get the termination status of the child, thus preventing the system function from being able to obtain the child's termination status for its return value.
  一旦子进程结束，内核会向应用程序递送 SIGCHLD 信号，运行信号处理函数，如果在信号处理函数中调用 wait 系列函数，之后system中调用的 wait 就会返回-1，errno 设置为 ECHLD，表明没有可收尸的子进程（因为已经被信号处理函数的 wait 回收了）。
  system函数之所以阻塞SIGCHLD，是为了保证system函数能够正确获取子进程的退出状态，并返回给 system 的调用者。

* Recall from Section 9.6 that typing the interrupt character causes the interrupt signal to be sent to all the processes in the foreground process group.

  when we're running another program with the system function, we shouldn't have both the parent and the child catching the two terminal-generated signals: interrupt and quit. These two signals should really be sent to the program that is running: the child. Since the command that is executed by system can be an interactive command and since the caller of system gives up control while the program executes, waiting for it to finish, the caller of system should not be receiving these two terminal-generated signals. This is why POSIX.1 specifies that the system function should ignore these two signals while waiting for the command to complete.

* POSIX.1 states that if wait or waitpid returns the status of a child process while SIGCHLD is pending, then SIGCHLD should not be delivered to the process unless the status of another child process is also available. None of the four implementations discussed in this book implements this semantic. Instead, SIGCHLD remains pending after the system function calls waitpid; when the signal is unblocked, it is delivered to the caller. If we called wait in the sig_chld function in Figure 10.26, it would return 1 with errno set to ECHILD, since the system function already retrieved the termination status of the child.

*
```
int
system(const char *cmdstring)   /* with appropriate signal handling */
{
    pid_t               pid;
    int                 status;
    struct sigaction    ignore, saveintr, savequit;
    sigset_t            chldmask, savemask;

    if (cmdstring == NULL)
        return(1);      /* always a command processor with UNIX */

    ignore.sa_handler = SIG_IGN;    /* ignore SIGINT and SIGQUIT */
    sigemptyset(&ignore.sa_mask);
    ignore.sa_flags = 0;
    if (sigaction(SIGINT, &ignore, &saveintr) < 0)
        return(-1);
    if (sigaction(SIGQUIT, &ignore, &savequit) < 0)
        return(-1);
    sigemptyset(&chldmask);         /* now block SIGCHLD */
    sigaddset(&chldmask, SIGCHLD);
    if (sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0)
        return(-1);

    if ((pid = fork()) < 0) {
        status = -1;    /* probably out of processes */
    } else if (pid == 0) {          /* child */
        /* restore previous signal actions & reset signal mask */
        sigaction(SIGINT, &saveintr, NULL);
        sigaction(SIGQUIT, &savequit, NULL);
        sigprocmask(SIG_SETMASK, &savemask, NULL);

        execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
        _exit(127);     /* exec error */
    } else {                        /* parent */
       while (waitpid(pid, &status, 0) < 0)
           if (errno != EINTR) {
               status = -1; /* error other than EINTR from waitpid() */
               break;
           }
    }

    /* restore previous signal actions & reset signal mask */
    if (sigaction(SIGINT, &saveintr, NULL) < 0)
        return(-1);
    if (sigaction(SIGQUIT, &savequit, NULL) < 0)
        return(-1);
    if (sigprocmask(SIG_SETMASK, &savemask, NULL) < 0)
        return(-1);

    return(status);
}
```
  Note that we have to reset the dispositions of these two signals in the child before the call to execl. This allows execl to change their dispositions to the default, based on the caller's dispositions.

* Beware of the return value from system. It is the termination status of the shell, which isn't always the termination status of the command string. The return value from system reports an abnormal termination only when the shell itself abnormally terminate

## 10.19. sleep Function
```
unsigned int sleep(unsigned int seconds);
```
* This function causes the calling process to be suspended until either
	* The amount of wall clock time specified by seconds has elapsed.
	* A signal is caught by the process and the signal handler returns.

	In case 1, the return value is 0. When sleep returns early, because of some signal being caught (case 2), the return value is the number of unslept seconds

* For portability, you shouldn't make any assumptions about the implementation of sleep, but if you have any intentions of mixing calls to sleep with any other timing functions, you need to be aware of possible interactions.

```
static void
sig_alrm(int signo)
{
    /* nothing to do, just returning wakes up sigsuspend() */
}

unsigned int
sleep(unsigned int nsecs)
{
    struct sigaction    newact, oldact;
    sigset_t            newmask, oldmask, suspmask;
    unsigned int        unslept;

    /* set our handler, save previous information */
    newact.sa_handler = sig_alrm;
    sigemptyset(&newact.sa_mask);
    newact.sa_flags = 0;
    sigaction(SIGALRM, &newact, &oldact);

    /* block SIGALRM and save current signal mask */
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGALRM);
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);

    alarm(nsecs);

    suspmask = oldmask;
    sigdelset(&suspmask, SIGALRM);    /* make sure SIGALRM isn't blocked */
    sigsuspend(&suspmask);            /* wait for any signal to be caught */

    /* some signal has been caught,   SIGALRM is now blocked */

    unslept = alarm(0);
    sigaction(SIGALRM, &oldact, NULL);  /* reset previous action */

    /* reset signal mask, which unblocks SIGALRM */
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    return(unslept);
}
```
  为什么 ```alarm(nsecs)``` 前要阻塞sigalrm？如果没有阻塞 SIGALRM，则可能在调用 ```alarm(nsecs)``` 后， ```sigsuspend(&suspmask)``` 之前，alarm 信号已经发出，这样 sigsuspend 就会漏掉该 alarm 信号。
  一般 ```sigprocmask``` 和 ```sigsuspend``` 配合使用，以避免竞争条件。

## 10.20. Job-Control Signals
* POSIX.1 considers six to be job-control signals:
	* **SIGCHLD** Child process has stopped or terminated.
	* **SIGCONT** Continue process, if stopped.
	* **SIGSTOP** Stop signal (can't be caught or ignored).
	* **SIGTSTP** Interactive stop signal.
	* **SIGTTIN** Read from controlling terminal by member of a background process group.
	* **SIGTTOU** Write to controlling terminal by member of a background process group.

	Except for SIGCHLD, most application programs don't handle these signals: interactive shells usually do all the work required to handle these signals. When we type the suspend character (usually Control-Z), SIGTSTP is sent to all processes in the foreground process group. When we tell the shell to resume a job in the foreground or background, the shell sends all the processes in the job the SIGCONT signal. Similarly, if SIGTTIN or SIGTTOU is delivered to a process, the process is stopped by default, and the job-control shell recognizes this and notifies us.

* There are some interactions between the job-control signals. When any of the four stop signals (SIGTSTP, SIGSTOP, SIGTTIN, or SIGTTOU) is generated for a process, any pending SIGCONT signal for that process is discarded. Similarly, when the SIGCONT signal is generated for a process, any pending stop signals for that same process are discarded.

* When the program is started by a shell that doesn't support job control, the signal's disposition should be set to SIG_IGN. In fact, the shell doesn't explicitly ignore this signal; init sets the disposition of the three job-control signals (SIGTSTP, SIGTTIN, and SIGTTOU) to SIG_IGN. This disposition is then inherited by all login shells. Only a job-control shell should reset the disposition of these three signals to SIG_DFL.

* When we type the suspend character, the process receives the SIGTSTP signal, and the signal handler is invoked. At this point, we would do any terminal-related processing: move the cursor to the lower-left corner, restore the terminal mode, and so on. We then send ourself the same signal, SIGTSTP, after resetting its disposition to its default (stop the process) and unblocking the signal. We have to unblock it since we're currently handling that same signal, and the system blocks it automatically while it's being caught. At this point, the system stops the process.

```
static void
sig_tstp(int signo) /* signal handler for SIGTSTP */
{
    sigset_t    mask;

    /* ... move cursor to lower left corner, reset tty mode ... */

    /*
     * Unblock SIGTSTP, since it's blocked while we're handling it.
     */
    sigemptyset(&mask);
    sigaddset(&mask, SIGTSTP);
    sigprocmask(SIG_UNBLOCK, &mask, NULL);

    signal(SIGTSTP, SIG_DFL);   /* reset disposition to default */

    kill(getpid(), SIGTSTP);    /* and send the signal to ourself */

    /* we won't return from the kill until we're continued */

    signal(SIGTSTP, sig_tstp);  /* reestablish signal handler */

    /* ... reset tty mode, redraw screen ... */
}
```

## 10.21. Additional Features
* Some systems provide the array
```
extern char *sys_siglist[];
```
  The array index is the signal number, giving a pointer to the character string name of the signal.

* These systems normally provide the function psignal also:
```
void psignal(int signo, const char *msg);
```
  The string msg (which is normally the name of the program) is output to the standard error, followed by a colon and a space, followed by a description of the signal, followed by a newline. This function is similar to perror.

* Another common function is strsignal. This function is similar to strerror.
```
char *strsignal(int signo);
```
  Given a signal number, strsignal will return a string that describes the signal. This string can be used by applications to print error messages about signals received.

* Solaris provides a couple of functions to map a signal number to a signal name and vice versa.
```
int sig2str(int signo, char *str);
int str2sig(const char *str, int *signop);
```
  The caller must ensure that the memory is large enough to hold the longest string, including the terminating null byte. Solaris provides the constant SIG2STR_MAX in <signal.h> to define the maximum string length.

# Chapter 11. Threads
## 11.1. Introduction
* All threads within a single process have access to the same process components, such as file descriptors and memory.

## 11.2. Thread Concepts
* A thread consists of the information necessary to represent an execution context within a process. This includes a thread ID that identifies the thread within a process, a set of register values, a stack, a scheduling priority and policy, a signal mask, an errno variable (recall Section 1.7), and thread-specific data. Everything within a process is sharable among the threads in a process, including the text of the executable program, the program's global and heap memory, the stacks, and the file descriptors.

## 11.3. Thread Identification
* Unlike the process ID, which is unique in the system, the thread ID has significance only within the context of the process to which it belongs.
* Recall that a process ID, represented by the pid_t data type, is a non-negative integer. A thread ID is represented by the pthread_t data type. Implementations are allowed to use a structure to represent the pthread_t data type. So portable implementations can't treat them as integers. Therefore, a function must be used to compare two thread IDs.
```
int pthread_equal(pthread_t tid1, pthread_t tid2);
```

* A thread can obtain its own thread ID by calling the pthread_self function.
```
#include <pthread.h>
pthread_t pthread_self(void);
```

## 11.4. Thread Creation
* Additional threads can be created by calling the pthread_create function.
```
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg);

```
  The memory location pointed to by tidp is set to the thread ID of the newly created thread when pthread_create returns successfully. The attr argument is used to customize various thread attributes.
 
  The newly created thread starts running at the address of the start_rtn function. This function takes a single argument, arg, which is a typeless pointer. If you need to pass more than one argument to the start_rtn function, then you need to store them in a structure and pass the address of the structure in arg.

  When a thread is created, there is no guarantee which runs first: the newly created thread or the calling thread. The newly created thread has access to the process address space and inherits the calling thread's floating-point environment and signal mask; however, the set of pending signals for the thread is cleared.

  Note that the pthread functions usually return an error code when they fail. They don't set errno like the other POSIX functions. The per thread copy of errno is provided only for compatibility with existing functions that use it. With threads, it is cleaner to return the error code from the function, thereby restricting the scope of the error to the function that caused it, instead of relying on some global state that is changed as a side effect of the function.

* New thread should obtains its thread ID by calling pthread_self instead of reading it out of shared memory or receiving it as an argument to its thread-start routine. Recall that pthread_create will return the thread ID of the newly created thread through the first parameter (tidp). In our example, the main thread stores this in ntid, but the new thread can't safely use it. **If the new thread runs before the main thread returns from calling pthread_create, then the new thread will see the uninitialized contents of ntid instead of the thread ID.**

* The Linux thread IDs look more reasonable, but the process IDs don't match. This is an artifact of the Linux threads implementation, where the clone system call is used to implement pthread_create. The clone system call creates a child process that can share a configurable amount of its parent's execution context, such as file descriptors and memory.

## 11.5. Thread Termination
* If any thread within a process calls exit, _Exit, or _exit, then the entire process terminates. Similarly, when the default action is to terminate the process, a signal sent to a thread will terminate the entire process.
* A single thread can exit in three ways, thereby stopping its flow of control, without terminating the entire process:
	* The thread can simply return from the start routine. The return value is the thread's exit code.
	* The thread can be canceled by another thread in the same process.
	* The thread can call pthread_exit.

```
void pthread_exit(void *rval_ptr);
```
  The rval_ptr is a typeless pointer, similar to the single argument passed to the start routine. This pointer is available to other threads in the process by calling the pthread_join function.
```
int pthread_join(pthread_t thread, void **rval_ptr);
```
  The calling thread will block until the specified thread calls pthread_exit, returns from its start routine, or is canceled. If the thread simply returned from its start routine, rval_ptr will contain the return code. If the thread was canceled, the memory location specified by rval_ptr is set to PTHREAD_CANCELED.

  By calling pthread_join, we automatically place a thread in the detached state (discussed shortly) so that its resources can be recovered. If the thread was already in the detached state, calling pthread_join fails, returning EINVAL.

* One thread can request that another in the same process be canceled by calling the pthread_cancel function.
```
int pthread_cancel(pthread_t tid);
```
  Note that pthread_cancel doesn't wait for the thread to terminate. It merely makes the request.

* A thread can arrange for functions to be called when it exits, the functions are known as thread cleanup handlers. More than one cleanup handler can be established for a thread. The handlers are recorded in a stack, which means that they are executed in the reverse order from that with which they were registered.
```
void pthread_cleanup_push(void (*rtn)(void *), void *arg);
void pthread_cleanup_pop(int execute);
```

* The pthread_cleanup_push function schedules the cleanup function, rtn, to be called with the single argument, arg, when the thread performs one of the following actions:
	* Makes a call to pthread_exit
	* Responds to a cancellation request
	* Makes a call to pthread_cleanup_pop **with a nonzero** execute argument.

* A restriction with these functions is that, because they can be implemented as macros, they must be used in matched pairs within the same scope in a thread. The macro definition of pthread_cleanup_push can include a { character, in which case the matching } character is in the pthread_cleanup_pop definition.

* We can detach a thread by calling pthread_detach. A thread's underlying storage can be reclaimed immediately on termination if that thread has been detached.
```
int pthread_detach(pthread_t tid);
```

## 11.6. Thread Synchronization
* In modern computer systems, memory accesses take multiple bus cycles, and multiprocessors generally interleave bus cycles among multiple processors, so we aren't guaranteed that our data is sequentially consistent.
* We can protect our data and ensure access by only one thread at a time by using the pthreads mutual-exclusion interfaces. A mutex is basically a lock that we set (lock) before accessing a shared resource and release (unlock) when we're done.
 
  If more than one thread is blocked when we unlock the mutex, then all threads blocked on the lock will be made runnable, and the first one to run will be able to set the lock.

 * A mutex variable is represented by the pthread_mutex_t data type. Before we can use a mutex variable, we must first initialize it by either setting it to the constant PTHREAD_MUTEX_INITIALIZER (for statically-allocated mutexes only) or calling pthread_mutex_init. If we allocate the mutex dynamically (by calling malloc, for example), then we need to call pthread_mutex_destroy before freeing the memory.

```
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```
  To lock a mutex, we call pthread_mutex_lock. If the mutex is already locked, the calling thread will block until the mutex is unlocked. To unlock a mutex, we call pthread_mutex_unlock.

```
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
  If a thread can't afford to block, it can use pthread_mutex_trylock to lock the mutex conditionally. If the mutex is unlocked at the time pthread_mutex_trylock is called, then pthread_mutex_trylock will lock the mutex without blocking and return 0. Otherwise, pthread_mutex_trylock will fail, returning EBUSY without locking the mutex.

* When a readerwriter lock is write-locked, all threads attempting to lock it block until it is unlocked. When a readerwriter lock is read-locked, all threads attempting to lock it in read mode are given access, but any threads attempting to lock it in write mode block until all the threads have relinquished their read locks. Although implementations vary, readerwriter locks usually block additional readers if a lock is already held in read mode and a thread is blocked trying to acquire the lock in write mode.

  Readerwriter locks are also called sharedexclusive locks. When a readerwriter lock is read-locked, it is said to be locked in shared mode. When it is write-locked, it is said to be locked in exclusive mode.

```
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                        const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

```
  To lock a readerwriter lock in read mode, we call pthread_rwlock_rdlock. To write-lock a readerwriter lock, we call pthread_rwlock_wrlock. Regardless of how we lock a readerwriter lock, we can call pthread_rwlock_unlock to unlock it.

* Condition variables are another synchronization mechanism available to threads. Condition variables provide a place for threads to rendezvous. When used with mutexes, condition variables allow threads to wait in a race-free way for arbitrary conditions to occur.

  A condition variable, represented by the pthread_cond_t data type, can be initialized in two ways. We can assign the constant PTHREAD_COND_INITIALIZER to a statically-allocated condition variable, but if the condition variable is allocated dynamically, we can use the pthread_cond_init function to initialize it.

  We use pthread_cond_wait to wait for a condition to be true. A variant is provided to return an error code if the condition hasn't been satisfied in the specified amount of time.

  ```
  int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);
  int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex,
                           const struct timespec *restrict timeout);
  ```

  The pthread_cond_timedwait function works the same as the pthread_cond_wait function with the addition of the timeout. The timeout value specifies how long we will wait. It is specified by the timespec structure, where a time value is represented by a number of seconds and partial seconds. Partial seconds are specified in units of nanoseconds:

  ```
  struct timespec {
      time_t tv_sec;   /* seconds */
      long   tv_nsec;  /* nanoseconds */
  };
  ```
  Using this structure, we need to specify how long we are willing to wait **as an absolute time instead of a relative time.**

  There are two functions to notify threads that a condition has been satisfied. The pthread_cond_signal function will wake up one thread waiting on a condition, whereas the pthread_cond_broadcast function will wake up all threads waiting on a condition.

  ```
  int pthread_cond_signal(pthread_cond_t *cond);
  int pthread_cond_broadcast(pthread_cond_t *cond);
  ```

  If the timeout expires without the condition occurring, pthread_cond_timedwait will reacquire the mutex and return the error ETIMEDOUT. When it returns from a successful call to pthread_cond_wait or pthread_cond_timedwait, a thread needs to reevaluate the condition, since another thread might have run and already changed the condition.

  ```
  void process_msg(void)
  {
    struct msg *mp;

    for (;;) {
        pthread_mutex_lock(&qlock);
        while (workq == NULL)
            pthread_cond_wait(&qready, &qlock);
        mp = workq;
        workq = mp->m_next;
        pthread_mutex_unlock(&qlock);
        /* now process the message mp */
    }
  }

  void enqueue_msg(struct msg *mp)
  {
    pthread_mutex_lock(&qlock);
    mp->m_next = workq;
    workq = mp;
    pthread_mutex_unlock(&qlock);
    pthread_cond_signal(&qready);
  }
  ```

# Chapter 12. Thread Control
## 12.3. Thread Attributes
* If we know that we don't need the thread's termination status at the time we create the thread, we can arrange for the thread to start out in the detached state by modifying the detachstate thread attribute in the pthread_attr_t structure. We can use the pthread_attr_setdetachstate function to set the detachstate thread attribute to one of two legal values: PTHREAD_CREATE_DETACHED to start the thread in the detached state or PTHREAD_CREATE_JOINABLE to start the thread normally, so its termination status can be retrieved by the application.

* If you run out of virtual address space for thread stacks, you can use malloc or mmap to allocate space for an alternate stack and use pthread_attr_setstack to change the stack location of threads you create. The address specified by the stackaddr parameter is the lowest addressable address in the range of memory to be used as the thread's stack, aligned at the proper boundary for the processor architecture.

  The stackaddr thread attribute is defined as the lowest memory address for the stack. This is not necessarily the start of the stack, however. If stacks grow from higher address to lower addresses for a given processor architecture, the stackaddr thread attribute will be the end of the stack instead of the beginning.

* The concurrency level controls the number of kernel threads or processes on top of which the user-level threads are mapped. If an implementation keeps a one-to-one mapping between kernel-level threads and user-level threads, then changing the concurrency level will have no effect, since it is possible for all user-level threads to be scheduled. If the implementation multiplexes user-level threads on top of kernel-level threads or processes, however, you might be able to improve performance by increasing the number of user-level threads that can run at a given time. The ```pthread_setconcurrency``` function can be used to provide a hint to the system of the desired level of concurrency.

  The pthread_getconcurrency function returns the current concurrency level. If the operating system is controlling the concurrency level, then pthread_getconcurrency will return 0.

  The concurrency level specified by pthread_setconcurrency is only a hint to the system. There is no guarantee that the requested concurrency level will be honored.

## 12.4. Synchronization Attributes
* The pthread_mutexattr_init function will initialize the pthread_mutexattr_t structure with the default mutex attributes. Two attributes of interest are the process-shared attribute and the type attribute.
* Within a process, multiple threads can access the same synchronization object. This is the default behavior, as we saw in Chapter 11. In this case, the process-shared mutex attribute is set to PTHREAD_PROCESS_PRIVATE.
  
  Access to shared data by multiple processes usually requires synchronization, just as does access to shared data by multiple threads. If the process-shared mutex attribute is set to PTHREAD_PROCESS_SHARED, a mutex allocated from a memory extent shared between multiple processes may be used for synchronization by those processes.

  The process-shared mutex attribute allows the pthread library to provide more efficient mutex implementations when the attribute is set to PTHREAD_PROCESS_PRIVATE, which is the default case with multithreaded applications. Then the pthread library can restrict the more expensive implementation to the case in which mutexes are shared among processes.

* The type mutex attribute controls the characteristics of the mutex.
    * The PTHREAD_MUTEX_NORMAL type is a standard mutex that doesn't do any special error checking or deadlock detection. 
    * The PTHREAD_MUTEX_ERRORCHECK mutex type provides error checking.
    * The PTHREAD_MUTEX_RECURSIVE mutex type allows the same thread to lock it multiple times without first unlocking it. A recursive mutex maintains a lock count and isn't released until it is unlocked the same number of times it is locked.
    * The PTHREAD_MUTEX_DEFAULT type can be used to request default semantics. 

  Recursive mutexes are useful when you need to adapt existing single-threaded interfaces to a multithreaded environment, but can't change the interfaces to your functions because of compatibility constraints. 

* The only attribute supported for reader–writer locks is the process-shared attribute. It is identical to the mutex process-shared attribute. 
* Just as with the other synchronization primitives, condition variables support the process-shared attribute.

## 12.5. Reentrancy
* Threads are similar to signal handlers when it comes to reentrancy. With both signal handlers and threads, multiple threads of control can potentially call the same function at the same time. If a function can be safely called by multiple threads at the same time, we say that the function is **thread-safe**.
* Implementations that support thread-safe functions will define the _POSIX_THREAD_SAFE_FUNCTIONS symbol in <unistd.h>.
* **If a function is reentrant with respect to multiple threads, we say that it is thread-safe. This doesn't tell us, however, whether the function is reentrant with respect to signal handlers.**
* POSIX.1 provides a way to manage FILE objects in a thread- safe way. You can use flockfile and ftrylockfile to obtain a lock associated with a given FILE object. This lock is recursive: you can acquire it again, while you already hold it, without deadlocking. 
* Although the standard I/O routines might be implemented to be thread-safe from the perspective of their own internal data structures, it is still useful to expose the locking to applications. This allows applications to compose multiple calls to standard I/O functions into atomic sequences. 
* If the standard I/O routines acquire their own locks, then we can run into serious performance degradation when doing character-at-a-time I/O. In this situation, we end up acquiring and releasing a lock for every character read or written. To avoid this overhead, unlocked versions of the character-based standard I/O routines are available. These unlocked versions functions should not be called unless surrounded by calls to flockfile (or ftrylockfile) and funlockfile. Otherwise, unpredictable results can occur.
* **If we make getenv_r thread-safe, that doesn't mean that it is reentrant with respect to signal handlers.** If we use a nonrecursive mutex, we run the risk that a thread will deadlock itself if it calls getenv_r from a signal handler. If the signal handler interrupts the thread while it is executing getenv_r, we will already be holding env_mutex locked, so another attempt to lock it will block, causing the thread to deadlock. Thus, we must use a recursive mutex to prevent other threads from changing the data structures while we look at them, and also prevent deadlocks from signal handlers.

## 12.6. Thread-Specific Data
* Thread-specific data, also known as thread-private data, is a mechanism for storing and finding data associated with a particular thread. The reason we call the data thread-specific, or thread-private, is that we'd like each thread to access its own separate copy of the data, without worrying about synchronizing access with other threads.
* The second reason for thread-private data is to provide a mechanism for adapting process-based interfaces to a multithreaded environment. An obvious example of this is errno. To make it possible for threads to use these same system calls and library routines, errno is redefined as thread-private data. Thus, one thread making a call that sets errno doesn't affect the value of errno for the other threads in the process.

  The key created is stored in the memory location pointed to by keyp. The same key can be used by all threads in the process, but each thread will associate a different thread-specific data address with the key. When the key is created, the data address for each thread is set to a null value.

  A thread can allocate multiple keys for thread-specific data. Each operating system implementation can place a limit on the number of keys a process can allocate (PTHREAD_KEYS_MAX).

  We can break the association of a key with the thread-specific data values for all threads by calling pthread_key_delete.

  Note that calling pthread_key_delete will not invoke the destructor function associated with the key. 

* If each thread calls pthread_once, the system guarantees that the initialization routine, initfn, will be called
only once, on the first call to ```pthread_once```. 
```
int pthread_once(pthread_once_t *initflag, void (*initfn)(void));
```
  The initflag must be a nonlocal variable (i.e., global or static) and initialized to PTHREAD_ONCE_INIT.

* Once a key is created, we can associate thread-specific data with the key by calling pthread_setspecific. We can obtain the address of the thread-specific data with pthread_getspecific.
   
## 12.7. Cancel Options
* Two thread attributes that are not included in the pthread_attr_t structure are the cancelability state and the cancelability type. These attributes affect the behavior of a thread in response to a call to pthread_cancel.
  
  The cancelability state attribute can be either PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE. A thread can change its cancelability state by calling pthread_setcancelstate.

  A call to pthread_cancel doesn't wait for a thread to terminate. In the default case, a thread will continue to execute after a cancellation request is made, until the thread reaches a cancellation point. A cancellation point is a place where the thread checks to see whether it has been canceled, and then acts on the request. 

  A thread starts with a default cancelability state of PTHREAD_CANCEL_ENABLE. When the state is set to PTHREAD_CANCEL_DISABLE, a call to pthread_cancel will not kill the thread. Instead, the cancellation request remains pending for the thread. When the state is enabled again, the thread will act on any pending cancellation requests at the next cancellation point.

* If your application doesn't call one of the functions in Figure 12.14 or Figure 12.15 for a long period of time (if it is compute-bound, for example), then you can call pthread_testcancel to add your own cancellation points to the program.
```
void pthread_testcancel(void);
```

  When you call pthread_testcancel, if a cancellation request is pending and if cancellation has not been disabled, the thread will be canceled. When cancellation is disabled, however, calls to pthread_testcancel have no effect.

* The default cancellation type we have been describing is known as deferred cancellation. We can change the cancellation type by calling ```pthread_setcanceltype```. The type parameter can be either PTHREAD_CANCEL_DEFERRED or PTHREAD_CANCEL_ASYNCHRONOUS. 

  Asynchronous cancellation differs from deferred cancellation in that the thread can be canceled at any time. The thread doesn't necessarily need to hit a cancellation point for it to be canceled.  


## 12.8. Threads and Signals
* Each thread has its own signal mask, but the signal disposition is shared by all threads in the process. This means that individual threads can block signals, but when a thread modifies the action associated with a given signal, all threads share the action. 
* Signals are delivered to a single thread in the process. If the signal is related to a hardware fault or expiring timer, the signal is sent to the thread whose action caused the event. Other signals, on the other hand, are delivered to an arbitrary thread.
* The behavior of sigprocmask is undefined in a multithreaded process. Threads have to use ```pthread_sigmask``` instead.
* A thread can wait for one or more signals to occur by calling sigwait. To avoid erroneous behavior, **a thread must block the signals it is waiting for before calling sigwait.** The sigwait function will atomically unblock the signals and wait until one is delivered. Before returning, sigwait will restore the thread's signal mask. If the signals are not blocked at the time that sigwait is called, then a timing window is opened up where one of the signals can be delivered to the thread before it completes its call to sigwait.

  The advantage to using sigwait is that it can simplify signal handling by allowing us to treat asynchronously- generated signals in a synchronous manner. We can prevent the signals from interrupting the threads by adding them to each thread's signal mask. Then we can dedicate specific threads to handling the signals. These dedicated threads can make function calls without having to worry about which functions are safe to call from a signal handler, because they are being called from normal thread context, not from a traditional signal handler interrupting a normal thread's execution.

  If multiple threads are blocked in calls to sigwait for the same signal, only one of the threads will return from sigwait when the signal is delivered. If a signal is being caught (the process has established a signal handler by using sigaction, for example) and a thread is waiting for the same signal in a call to sigwait, it is left up to the implementation to decide which way to deliver the signal. In this case, the implementation could either allow sigwait to return or invoke the signal handler, but not both.

* To send a signal to a thread, we call pthread_kill. 

  We can pass a signo value of 0 to check for existence of the thread. If the default action for a signal is to terminate the process, then sending the signal to a thread will still kill the entire process.

  Note that alarm timers are a process resource, and all threads share the same set of alarms. Thus, it is not possible for multiple threads in a process to use alarm timers without interfering (or cooperating) with one another.

## 12.9. Threads and fork
* When a thread calls fork, a copy of the entire process address space is made for the child. By inheriting a copy of the address space, the child also inherits the state of every mutex, reader–writer lock, and condition variable from the parent process. If the parent consists of more than one thread, the child will need to clean up the lock state if it isn't going to call exec immediately after fork returns.

* Inside the child process, only one thread exists. It is made from a copy of the thread that called fork in the parent. If the threads in the parent process hold any locks, the locks will also be held in the child process. The problem is that the child process doesn't contain copies of the threads holding the locks, so there is no way for the child to know which locks are held and need to be unlocked.
 
  This problem can be avoided if the child calls one of the exec functions directly after returning from fork. In this case, the old address space is discarded, so the lock state doesn't matter. This is not always possible, however, so if the child needs to continue processing, we need to use a different strategy.

  To clean up the lock state, we can establish fork handlers by calling the function pthread_atfork.
  ```
  int pthread_atfork(void (*prepare)(void), void (*parent)(void),
                   void (*child)(void));
  ```

    With pthread_atfork, we can install up to three functions to help clean up the locks. The prepare fork handler is called in the parent before fork creates the child process. This fork handler's job is to acquire all locks defined by the parent. The parent fork handler is called in the context of the parent after fork has created the child process, but before fork has returned. This fork handler's job is to unlock all the locks acquired by the prepare fork handler. The child fork handler is called in the context of the child process before returning from fork. Like the parent fork handler, the child fork handler too must release all the locks acquired by the prepare fork handler.

    When multiple fork handlers are used, the order in which the handlers are called differs. The parent and child fork handlers are called in the order in which they were registered, whereas the prepare fork handlers are called in the opposite order from which they were registered. This allows multiple modules to register their own fork handlers and still honor the locking hierarchy.

    If the lock is embedded in the condition variable data structure, then we can't use condition variables after calling fork, because there is no portable way to clean up its state. 

# Chapter 13. Daemon Processes
## 13.1. Introduction
* Daemons are processes that live for a long time. They are often started when the system is bootstrapped and terminate only when the system is shut down. Because they don't have a controlling terminal, we say that they run in the background.

## 13.2. Daemon Characteristics
* All the user-level daemons are process group leaders and session leaders and are the only processes in their process group and session. Finally, note that the parent of most of these daemons is the init process.

## 13.3. Coding Rules
* Some basic rules to coding a daemon prevent unwanted interactions from happening.
    * The first thing to do is call umask to set the file mode creation mask to 0. The file mode creation mask that's inherited could be set to deny certain permissions. If the daemon process is going to create files, it may want to set specific permissions.
    * Call fork and have the parent exit. First, if the daemon was started as a simple shell command, having the parent terminate makes the shell think that the command is done. Second, the child inherits the process group ID of the parent but gets a new process ID, so we're guaranteed that the child is not a process group leader. This is a prerequisite for the call to setsid that is done next.
    * Call setsid to create a new session. The process (a) becomes a session leader of a new session, (b) becomes the process group leader of a new process group, and (c) has no controlling terminal.
    * Change the current working directory to the root directory. The current working directory inherited from the parent could be on a mounted file system. Since daemons normally exist until the system is rebooted, if the daemon stays on a mounted file system, that file system cannot be unmounted.
    * Unneeded file descriptors should be closed. This prevents the daemon from holding open any descriptors that it may have inherited from its parent.
    * Some daemons open file descriptors 0, 1, and 2 to /dev/null so that any library routines that try to read from standard input or write to standard output or standard error will have no effect.

## 13.4. Error Logging
* There are three ways to generate log messages:
    * Kernel routines can call the log function. These messages can be read by any user process that opens and reads the /dev/klog device.
    * Most user processes (daemons) call the syslog(3) function to generate log messages. This causes the message to be sent to the UNIX domain datagram socket /dev/log.
    * A user process on this host, or on some other host that is connected to this host by a TCP/IP network, can send log messages to UDP port 514. Note that the syslog function never generates these UDP datagrams: they require explicit network programming by the process generating the log message.

* Normally, the syslogd daemon reads all three forms of log messages. On start-up, this daemon reads a configuration file, usually /etc/syslog.conf, which determines where different classes of messages are to be sent. 
* Calling openlog is optional. If it's not called, the first time syslog is called, openlog is called automatically. Calling closelog is also optional. Calling openlog lets us specify an ident that is added to each log message. This is normally the name of the program.

## 13.5. Single-Instance Daemons
* The file- and record-locking mechanism provides the basis for one way to ensure that only one copy of a daemon is running. 

  File and record locking provides a convenient mutual-exclusion mechanism. If the daemon obtains a write-lock on an entire file, the lock will be removed automatically if the daemon exits. 

## 13.6. Daemon Conventions
为什么在创建守护进程时需要忽略sighup？
先创建一个会话leader进程A，接着会用A创建子进程B，并退出A，以后所有进程从B创建，保证所有以后新创建进程都不是会话 
leader进程（这是为了防止取得终端而采取的保证措施），但是，由于有一个exit 进程A的操作，当A退出时，会对本会话的所有进程发送
SIGHUP信号，默认操作是全部退出，而此时是在创建守护进程过程中，必须防止B收到SIGHUP而退出，否则下面的操作就无法进行，所以这里必须对
SIGHUP进行忽略！

* Several common conventions are followed by daemons in the UNIX System:
  * If the daemon uses a lock file, the file is usually stored in /var/run. The name of the file is usually name.pid, where name is the name of the daemon or the service. 
  * If the daemon supports configuration options, they are usually stored in /etc. The configuration file is named name.conf, where name is the name of the daemon or the name of the service.
  * Daemons can be started from the command line, but they are usually started from one of the system initialization scripts (/etc/rc* or /etc/init.d/*). If the daemon should be restarted automatically when it exits, we can arrange for init to restart it if we include a respawn entry for it in /etc/inittab.
  * If a daemon has a configuration file, the daemon reads it when it starts, but usually won't look at it again. To avoid this, some daemons will catch SIGHUP and reread their configuration files when they receive the signal. 

## 13.7. Client–Server Model
* A common use for a daemon process is as a server process.


# Chapter 14. Advanced I/O
## 14.2. Nonblocking I/O
* System calls are divided into two categories: the "slow" ones and all the others. The slow system calls are those that can block forever. They include
  * Reads that can block the caller forever if data isn't present with certain file types (pipes, terminal devices, and network devices)
  * Writes that can block the caller forever if the data can't be accepted immediately by these same file types (no room in the pipe, network flow control, etc.)
  * Opens that block until some condition occurs on certain file types (such as an open of a terminal device that waits until an attached modem answers the phone, or an open of a FIFO for writing-only when no other process has the FIFO open for reading)
  * Reads and writes of files that have mandatory record locking enabled
  * Certain ioctl operations
  * Some of the interprocess communication functions 

  We also said that system calls related to disk I/O are not considered slow, even though the read or write of a disk file can block the caller temporarily.

  Nonblocking I/O lets us issue an I/O operation, such as an open, read, or write, and not have it block forever. If the operation cannot be completed, the call returns immediately with an error noting that the operation would have blocked.

  There are two ways to specify nonblocking I/O for a given descriptor:
  * If we call open to get the descriptor, we can specify the O_NONBLOCK flag.
  * For a descriptor that is already open, we call fcntl to turn on the O_NONBLOCK file status flag.

## 14.3. Record Locking
* In some applications, such as a database system, a process needs to be certain that it alone is writing to a file. To provide this capability for processes that need it, commercial UNIX systems provide record locking.
* The compatibility rule applies to lock requests made from different processes, not to multiple lock requests made by a single process. If a process has an existing lock on a range of a file, a subsequent attempt to place a lock on the same range by the same process will replace the existing lock with the new one. 
* To obtain a read lock, the descriptor must be open for reading; to obtain a write lock, the descriptor must be open for writing.
