---
layout: post
date: 2016-07-07T15:02:11+08:00
title: APUE 读书笔记
category: 读书笔记
---

# Chapter 1. UNIX System Overview

## 1.1. Introduction

* All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on.

## 1.2. UNIX Architecture

* An operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the **kernel**.
* The interface to the kernel is a layer of software called the **system calls**. Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications.

## 1.3. Logging In

* When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd which composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).

## 1.4. Files and Directories

* The UNIX file system is a hierarchical arrangement of directories and files. 
* Most implementations of UNIX file systems don't store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links.

## 1.5. Input and Output

* File descriptors are normally small non-negative integers that the kernel uses to identify the files being accessed by a particular process.
* By convention, all shells open three descriptors whenever a new program is run: **standard input**, **standard output**, and **standard error**.
* Unbuffered I/O is provided by the functions **open**, **read**, **write**, **lseek**, and **close**. These functions all work with file descriptors.
* The <unistd.h> header and the two constants **STDIN_FILENO** and **STDOUT_FILENO** are part of the POSIX standard
* The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O prevents us from having to worry about choosing optimal buffer sizes, such as the BUFFSIZE constant. Another advantage of using the standard I/O functions is that they simplify dealing with lines of input. The standard I/O constants stdin and stdout are defined in the <stdio.h> header and refer to the standard input and standard output.

## 1.6. Programs and Processes

* A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the six **exec** functions.
* The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer.
* There are three primary functions for process control: fork, exec, and waitpid.
* All the threads within a process share the same **address space**, **file descriptors**, **stacks**, and **process-related attributes**. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.
* Threads are identified by IDs, however, are **local to a process**.

## 1.7. Error Handling

* There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.
* Resource-related nonfatal errors include EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, ENOSR, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as a nonfatal error when it indicates that a shared resource is in use. Sometimes, EINTR can be treated as a nonfatal error when it interrupts a slow system call. The typical recovery action for a resource-related nonfatal error is to delay a little and try again later.

## 1.8. User Identification

* The user ID from our entry in the password file is a numeric value that identifies us to the system.
* Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group.
* There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.
* Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32- bit integers.

## 1.9. Signals

* Signals are a technique used to notify a process that some condition has occurred.
* The process has three choices for dealing with the signal.
    * Ignore the signal. This option isn't recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.
    * Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.
    * Provide a function that is called when the signal occurs (this is called "catching" the signal). By providing a function of our own, we'll know when the signal occurs and we can handle it as we wish.

* We have to be the owner of the other process (or the superuser) to be able to send it a signal.

1.10. Time Values

* UNIX systems have maintained two different time values:
    * Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970, Coordinated Universal Time (UTC). These time values are used to record the time when a file was last modified, for example.
        The primitive system data type time_t holds these time values.
    * Process time. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second.
        The primitive system data type clock_t holds these time values. 
        
* When we measure the execution time of a process, as in Section 3.9, we'll see that the UNIX System maintains three values for a process:
    * Clock time
    * User CPU time
    * System CPU time

    The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. 

## 1.11. System Calls and Library Functions

* All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls.
* The system call interface's definition is in the C language, regardless of the actual implementation technique used on any given system to invoke a system call.

# Chapter 2. UNIX Standardization and Implementations

## 2.5. Limits
* Two types of limits are needed:
    * Compile-time limits (e.g., what's the largest value of a short integer?)
    * Runtime limits (e.g., how many characters in a filename?)
    Compile-time limits can be defined in headers that any program can include at compile time. But runtime limits require the process to call a function to obtain the value of the limit.

* Additionally, some limits can be fixed on a given implementation—and could therefore be defined statically in a header—yet vary on another implementation and would require a runtime function call.
* To solve these problems, three types of limits are provided:
    * Compile-time limits (headers)
    * Runtime limits that are not associated with a file or directory (the sysconf function)
    * Runtime limits that are associated with a file or a directory (the pathconf and fpathconf functions)

* All the limits defined by ISO C are compile-time limits that are defined in the file <limits.h>. 
    *  ISO C defines the constant FOPEN_MAX, the minimum number of standard I/O streams that the implementation guarantees can be open at once. This value is in the <stdio.h> header, and its minimum value is 8. The POSIX.1 value STREAM_MAX, if defined, must have the same value as FOPEN_MAX.
    * ISO C also defines the constant TMP_MAX in <stdio.h>. It is the maximum number of unique filenames generated by the tmpnam function.

* sysconf / pathconf / fpathconf
    * All three functions return –1 and set errno to EINVAL if the name isn't one of the appropriate constants. The third column in Figures 2.10 and 2.11 lists the limit constants we'll deal with throughout the rest of this book.
    * Some names can return either the value of the variable (a return value 0) or an indication that the value is indeterminate. An indeterminate value is indicated by returning –1 and not changing the value of errno.
    * The value returned for _SC_CLK_TCK is the number of clock ticks per second, for use with the return values from the times function (Section 8.16).


# Chapter 3. File I/O

## 3.1. Introduction
* Most file I/O on a UNIX system can be performed using only five functions: ```open```, ```read```, ```write```, ```lseek```, and ```close```.

## 3.2. File Descriptors
* To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. 
* UNIX System shells associate **file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error**. This convention is used by the shells and many applications; it is not a feature of the UNIX kernel.
* The magic numbers 0, 1, and 2 should be replaced in POSIX-compliant applications with the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO. These constants are defined in the <unistd.h> header.

## 3.3. open Function
```
int open(const char *pathname, int oflag, ... /* mode_t mode */ );
```

* This function has a multitude of options, which are specified by the oflag argument. This argument is formed by ORing together one or more of the following constants from the <fcntl.h> header:
    * O_RDONLY: Open for reading only. 
    * O_WRONLY: Open for writing only.   
    * O_RDWR:   Open for reading and writing.

    One and only one of these three constants must be specified. The following constants are optional:
    * O_APPEND:     Append to the end of file on each write.
    * O_CREAT:      Create the file if it doesn't exist. This option requires a third argument to the open function, the mode, which specifies the access permission bits of the new file. 
    * O_EXCL:       Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn't exist is an atomic operation. 
    * O_TRUNC:      If the file exists and if it is successfully opened for either write-only or read–write, truncate its length to 0.
    * O_NOCTTY:     If the pathname refers to a terminal device, do not allocate the device as the controlling terminal for this process. 
    * O_NONBLOCK:   If the pathname refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. 

    
    The following three flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1):
    * O_DSYNC:  Have each write wait for physical I/O to complete, but don't wait for file attributes to be updated if they don't affect the ability to read the data just written.
    * O_RSYNC:  Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.
    * O_SYNC:   Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. 

    The O_DSYNC and O_SYNC flags are similar, but subtly different. The O_DSYNC flag affects a file's attributes only when they need to be updated to reflect a change in the file's data. With the O_SYNC flag, data and attributes are always updated synchronously. When overwriting an existing part of a file opened with the O_DSYNC flag, the file times wouldn't be updated synchronously.

* **The file descriptor returned by open is guaranteed to be the lowest-numbered unused descriptor.**

## 3.4. creat Function
```
int creat(const char *pathname, mode_t mode);
```

* Note that this function is equivalent to ```open (pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);```
* Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn't already exist. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.
* One deficiency with creat is that the file is opened **only for writing**.

## 3.5. close Function
```
int close(int filedes);
```

* Closing a file also releases any record locks that the process may have on the file.
* When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don't explicitly close open files.

## 3.6. lseek Function
```off_t lseek(int filedes, off_t offset, int whence);```
* Every open file has an associated "current file offset," normally a non-negative integer that measures the number of bytes from the beginning of the file. 
* Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.
* The interpretation of the offset depends on the value of the whence argument.
    * If whence is SEEK_SET, the file's offset is set to offset bytes from the beginning of the file.
    * If whence is SEEK_CUR, the file's offset is set to its current value plus the offset. The offset can be positive or negative.
    * If whence is SEEK_END, the file's offset is set to the size of the file plus the offset. The offset can be positive or negative.

* Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset. This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns –1.
* The character l in the name lseek means **"long integer"**.
* For regular files, the offset must be non-negative. It is possible, however, that certain devices could allow negative offsets. We should be careful to compare the return value from lseek as being equal to or not equal to –1 and not test if it's less than 0.
* The file's offset can be greater than the file's current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.
* A hole in a file isn't required to have storage backing it on disk. When you write after seeking past the end of the file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.

## 3.7. read Function
```ssize_t read(int filedes, void *buf, size_t nbytes);```
* If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned.
* The read operation starts at the file's current offset. **Before a successful return, the offset is incremented by the number of bytes actually read.**

## 3.8. write Function
```ssize_t write(int filedes, const void *buf, size_t nbytes);```
* The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process.
* After a successful write, the file's offset is incremented by the number of bytes actually written.

## 3.9. I/O Efficiency
* The operating system will try to cache the file incore.
* Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. 

## 3.10. File Sharing
* The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.
    * Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are
        * The file descriptor flags (close-on-exec)
        * A pointer to a file table entry
    * The kernel maintains a file table for all open files. Each file table entry contains
        * The file status flags for the file, such as read, write, append, sync, and nonblocking
        * The current file offset
        * A pointer to the v-node table entry for the file
    * Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on.

* The v-node was invented to provide support for multiple file system types on a single computer system. 

* After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset

* If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file.

* If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry.

* The lseek function modifies only the current file offset in the file table entry. No I/O takes place.

* It is possible for more than one file descriptor entry to point to the same file table entry, as we'll see when we discuss the dup function. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor.

* Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry.

## 3.12. dup and dup2 Functions
```
int dup(int filedes);
int dup2(int filedes, int filedes2);
```

* The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. 
* With dup2, we specify the value of the new descriptor with the filedes2 argument. If filedes2 is already open, it is first closed. If filedes equals filedes2, then dup2 returns filedes2 without closing it.
* Each descriptor has its own set of file descriptor flags. They share the same file status flags—read, write, append, and so on—and the same current file offset.

## 3.13. sync, fsync, and fdatasync Functions
```
int fsync(int filedes);
int fdatasync(int filedes);
```
* Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called **delayed write**.
* To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.
* The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel's block buffers. The command sync(1) also calls the sync function.
* The function fsync refers only to a single file, specified by the file descriptor filedes, and waits for the disk writes to complete before returning.
* The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file's attributes are also updated synchronously.

## 3.14. fcntl Function
```
int fcntl(int filedes, int cmd, ... /* int arg */ );
```
* The fcntl function can change the properties of a file that is already open.
* The fcntl function is used for five different purposes.
    * Duplicate an existing descriptor (cmd = F_DUPFD)
    * Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)
    * Get/set file status flags (cmd = F_GETFL or F_SETFL)
    * Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)
    * Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)

* First seven of these ten cmd values:
    * F_DUPFD: Duplicate the file descriptor filedes. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open. The new descriptor **shares the same file table entry** as filedes. But **the new descriptor has its own set of file descriptor flags**, and its FD_CLOEXEC file descriptor flag is cleared.
    * F_GETFD: Return the file descriptor flags for filedes as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag.
    * F_SETFD: Set the file descriptor flags for filedes. The new flag value is set from the third argument.
    * F_GETFL: Return the file status flags for filedes as the value of the function. We must first use the **O_ACCMODE mask** to obtain the access-mode bits and then compare the result against any of the three values.
    * F_SETFL: Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC.
    * F_GETOWN: Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals.
    * F_SETOWN: Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg.

* All commands return –1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first returns the new file descriptor, the next two return the corresponding flags, and the final one returns a positive process ID or a negative process group ID.

## 3.15. ioctl Function
```
int ioctl(int filedes, int request, ...);
```
* The ioctl function has always been the catchall for I/O operations. Anything that couldn't be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. 

## 3.16. /dev/fd
* Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.
* The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames.

# Chapter 4. Files and Directories
## 4.2. stat, fstat, and lstat Functions
```
int stat(const char *restrict pathname, struct stat *restrict buf); 
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```

```
struct stat {
    mode_t      st_mode;        /* file type & mode (permissions) */
    ino_t       st_ino;         /* i-node number (serial number) */
    dev_t       st_dev;         /* device number (file system) */
    dev_t       st_rdev;        /* device number for special files */
    nlink_t     st_nlink;       /* number of links */
    uid_t       st_uid;         /* user ID of owner */
    gid_t       st_gid;         /* group ID of owner */
    off_t       st_size;        /* size in bytes, for regular files */
    time_t      st_atime;       /* time of last access */
    time_t      st_mtime;       /* time of last modification */
    time_t      st_ctime;       /* time of last file status change */
    blksize_t   st_blksize;     /* best I/O block size */
    blkcnt_t    st_blocks;      /* number of disk blocks allocated */  
};
```

* The lstat function is similar to stat, but when the named file is a symbolic link, lstat returns information about the symbolic link, not the file referenced by the symbolic link.

## 4.3. File Types
* The types are:

    * Regular file
        The most common type of file, which contains data of some form. There is no distinction to the UNIX kernel whether this data is text or binary.

        One notable exception to this is with binary executable files. To execute a program, the kernel must understand its format. All binary executable files conform to a format that allows the kernel to identify where to load a program's text and data.

    * Directory file
        A file that contains the names of other files and pointers to information on these files.

    * Block special file
        A type of file providing buffered I/O access in fixed-size units to devices such as disk drives.

    * Character special file
        A type of file providing unbuffered I/O access in variable-sized units to devices. All devices on a system are either block special files or character special files.

    * FIFO
        A type of file used for communication between processes. It's sometimes called a named pipe. 

    * Socket
        A type of file used for network communication between processes. A socket can also be used for non-network communication between processes on a single host.

    * Symbolic link 
        A type of file that points to another file.

* The type of a file is encoded in the **st_mode** member of the stat structure. 
* Most systems define S_IFMT and S_IFxxx in the file <sys/stat.h>. If we examine this file, we'll find the S_ISDIR macro defined something like ```#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)```
* POSIX.1 allows implementations to represent interprocess communication (IPC) objects, such as message queues and semaphores, as files. 

## 4.4. Set-User-ID and Set-Group-ID
* Every process has six or more IDs associated with it:
    * real user ID / real group ID: who we really are
    * effective user ID / effective group ID / supplementary group IDs: used for file access permission checks
    * saved set-user-ID / saved set-group-ID: saved by exec functions

* The real user ID and real group ID identify who we really are. These two fields are taken from our entry in the password file when we log in. Normally, these values don't change during a login session.
* The effective user ID, effective group ID, and supplementary group IDs determine our file access permissions.
* The saved set-user-ID and saved set-group-ID contain copies of the effective user ID and the effective group ID when a program is executed. An application can test for the constant _POSIX_SAVED_IDS at compile time or can call sysconf with the _SC_SAVED_IDS argument at runtime, to see whether the implementation supports this feature.
* Normally, the effective user ID equals the real user ID, and the effective group ID equals the real group ID.
* Every file has an owner and a group owner. The owner is specified by the st_uid member of the stat
structure; the group owner, by the st_gid member.