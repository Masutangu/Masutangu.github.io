---
layout: post
date: 2016-10-05T15:59:32+08:00
title: 现代操作系统
category: 读书笔记
---

# 第一章 引论

## 1.1 什么是操作系统
* 从自顶向下的观点来看，操作系统是向应用程序提供基本抽象的概念。从自底向上的观点，操作系统则用来管理一个复杂系统的各个部分，其任务是在相互竞争的程序之间有序的控制对处理器、存储器以及其他 I/O 接口设备的分配。

  资源管理包括用以下两种不同方式实现多路复用（共享）资源：在时间上复用（轮流使用 CPU)和在空间上复用（分割内存供不同的程序使用）。

## 1.3 计算机硬件介绍
* 一台简单的个人计算机可以抽象为：CPU、内存以及 I/O 设备都由一条系统总线连接起来并通过总线与其他设备通信。

### 1.3.1 处理器
* CPU 是计算机的大脑，从内存中取出指令并执行之。在每个 CPU 基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，执行然后取指，解码并执行下一条指令。

  由于访问内存的时间比执行指令花费的时间长得多，因此 CPU 内部都有一些用来保存关键变量和临时数据的寄存器。

  除了用来保存变量和临时结果的寄存器，还有一些对程序员可见的专门寄存器：
  
  * 程序计数器：保存了将要取出的下一条指令的内存地址。
  * 堆栈指针：指向内存中当前栈的栈顶。
  * 程序状态字（PSW)：包含了条件码位（由比较指令设置）、CPU 优先级、模式（用户台或内核态）

  每次停止一个运行的程序时，操作系统必须保存所有的寄存器，稍后该程序被重新运行时，可以将这些寄存器重新载入。

  为了改善性能，现代 CPU 具有同时取出多条指令的机制，一个 CPU 有分开的取指单元、解码单元和执行单元。当它执行指令 n 时，还可以对指令 n+1 解码，并读取指令 n+2。这样的机制成为流水线。

  比流水线更先进的设计是一种超标量 CPU。指令被取出、解码并装入保持缓冲区中，多个执行单元从保持缓冲区中取出指令并执行。这种设计有个隐含作用，即程序的指令经常不按顺序执行。多数情况下由硬件负责保证运算结果与顺序执行结果相同。

  PSW 中有个二进制位控制内核态和用户态这两种模式。用户态仅允许执行整个指令集的一个子集。

  为了从操作系统中获得服务，用户程序必须通过系统调用来陷入内核。

### 1.3.2 存储器
存储器系统的顶层是 CPU 中的寄存器。其典型的存储容量在 32 位 CPU 中为 32\*32 位，而在 64 位 CPU 中为 64\*64位。程序必须在软件中自行管理寄存器。

下一层是高速缓存，多数由硬件控制。主存被分割成高速缓存行（cache line），其典型大小为 64 个字节，地址 0 至 63 对应高速缓存行 0，地址 64 至 127 对应高速缓存行 1。最常用的高速缓存行放置在 CPU 内部或非常接近 CPU 的高速缓存中。高速缓存命中通常需要两个时间周期，未命中则必须访问内存。有些机器具有两级甚至三级高速缓存。 

> [<每个程序员都应该了解的 CPU 高速缓存>](https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2?print)

现代 CPU 设计了两个缓存，第一级缓存（L1）总在 CPU 中，通常用来将已解码的指令调入 CPU 的执行引擎。多数芯片还安排有第二个 L1 缓存用以缓存常用数据字。典型的 L1 缓存大小为 16 KB。二级缓存（L2）用来存放使用过的内存字。L1 与 L2 的差别在于访问速度，访问 L1 缓存不存在耗时，访问 L2 则会有 1 到 2 个时钟周期。

再往下一层是主存，即随机访问存储器（RAM）。另外还有非易失性随机访问存储器，电源切断后不会丢失内容。只读存储器（ROM）用于存放启动计算机的引导加载模块。

还有一类存储器是 CMOS，它是易失性的，用于保持当前时间和日期，其消耗电能非常少。

### 1.3.3 磁盘
下一个层次是磁盘。同 RAM 相比，随机访问数据大概慢了三个数量级，因为磁盘是一种机械装置。

在任意给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把给定臂的位置上所有磁道合并起来，组成了一个柱面。每个磁道划分为若干扇区，扇区的典型值是 512 字节。机械臂从一个柱面移到相邻的柱面大约需要 1 ms。而随机移到一个柱面的典型时间为 5 ms至 10 ms。一旦磁臂移到正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，这就增加了 5 ms至 10 ms的时延。

### 1.3.5 I/O 设备
实现输入输出有三种方式：

* 忙等待
  用户程序发出一个系统调用，内核翻译成对设备驱动程序的调用。设备驱动程序启动 I/O 并在一个 busy loop 中检查该设备。I/O 结束后设备驱动程序将数据存放在指定地方，操作系统将控制权返回给调用者。

* 中断
  I/O 的过程：

  * 设备驱动程序通过写设备寄存器来通知设备控制器需要做什么，然后设备控制器启动该设备。
  * 一旦设备控制器已经读写完所需字节后，通过特定总线发信号给中断控制芯片。
  * 如果中断控制器已经准备接收中断，它会发送电信号通知 CPU 芯片。并把该设备的编号放在总线上，这样 CPU 读总线就知道哪个设备完成了操作。

  一旦 CPU 决定取中断，程序计数器和 PSW 就被压入当前堆栈中，并且 CPU 切换到内核态。设备编号用以寻找该设备中断处理程序的地址。当中断处理程序开始执行后，它取出之前压入在栈中的程序计数器和 PSW 并保存。当中断处理程序执行完后，返回之前被中断的用户程序继续执行。

  > linux 内核设计与实现，第七章：留意 do_IRQ 函数

* 直接存储器访问（DMA)芯片
  CPU 设置 DMA 芯片，告知需要传送的字节数，有关设备和内存地址以及操作方向，接着启动 DMA。DMA 可以控制内存和控制器之间的位流而无需 CPU 干预。当 DMA 完成后引发一个中断。

## 1.5 操作系统的概念
虚拟内存使程序可以在运行时动态地链接库，而不需要在编译时静态的链接。（没理解）
  
