---
layout: post
date: 2016-05-04T09:00:39+08:00
title: TCP/IP详解读书笔记1
draft: true
category: 读书笔记
---

# Chapter 1. Introduction
## Layering
不同层次的网络协议负责不同方面的通信。TCP/IP由四层不同的网络协议构成：

* **数据链路层（data-link layer or network interface layer）**：处理硬件接口细节
* **网络层（network layer）**：处理packets在网络中的运转，例如packets的路由。
* **传输层（transport layer）**：提供两台主机间的数据传输。
* **应用层（application layer）**：处理应用程序的细节。

应用层之下的三层通常处于内核态。应用层关注应用程序的细节，链路层关注通信媒介的细节，但是传输层和网络层的界限看起来比较模糊，划分为两层的原因如下：
构造互联网最简单的方法是把多个网络通过路由器进行连接，路由器的好处在于为不同的物理网络提供连接。
看看下面的例子，通过路由器将以太网和令牌环网连接起来：

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-1.png" alt="示例1" title="示例1" width="800" />

从图中可以看出，应用层和传输层使用端到端（end-to-end）协议，路由器中没有这两层，只有端系统才有。网络层和链路层使用逐跳（hop-by-hop）协议，端系统和路由器都有。TCP/IP协议族的网络层：IP,提供的是不可靠服务。TCP则在不可靠的IP层上，通过超时、重传和确认机制来提供可靠的服务。可见传输层和网络层的功能并不相同。

## IP地址
互联网的每一个接口都需要有唯一的IP地址，IP地址有一定的结构，可以由第一个十进制整数来区分各类别的IP。多接口主机具备多个IP。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-2.png" alt="示例2" title="示例2" width="800" />

IP地址由网络号和主机号构成。接口的网络号由Internet Network Information Center统一分配，主机号则由系统管理员分配。
有三种类型的IP地址：单播地址，广播地址和多播地址。

## 封装
TCP层发送给IP层的数据称之为TCP段（TCP segment），IP层发送给链路层的数据称之为IP数据报（IP datagram），通过以太网传输的比特流称之为帧（frame）。
以太网数据帧的大小必须在46～1500字节之间。

*准确的说，IP层和链路层之间的数据单元是分组（packet），分组既可以是IP数据报，也可以是IP数据报的一个分片*

IP会接收到来自TCP, UDP, ICMP和IGMP的数据，因此IP header中的协议域（protocol field）字段会存储数据报所属的上层协议。 1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。
类似的，不同应用程序都会使用TCP/UDP来发送数据，传输层会在头部保存应用程序的identifier。TCP/UDP采用16-bit的端口号来表示不同的应用程序，源端口和目标端口都会保存在头部。
相应的，以太网数据帧也有个16-bit的identifier来标识是IP、ARP还是RARP生成的数据。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-3.png" alt="示例3" title="示例3" width="800" />

## The Internet
Internet的含义取决于首字母是否大写。internet表示使用共同的协议族将多个网络连接在一起，Internet表示世界上通过TCP/IP互相通信的主机集合。Internet是一个internet，但internet不是Internet。

## 总结

* The four layers in the TCP/IP protocol suite are the **link layer, network layer, transport layer, and application layer**.
* In TCP/IP the distinction between the network layer and the transport layer is critical: the network layer (IP) provides a **hop-by-hop** service while the transport layers (TCP and UDP) provide an **end-to-end** service.
* An internet is a collection of networks. The common building block for an internet is **a router that connects the networks at the IP layer**. 
* On an internet each interface is identified by **a unique IP address**. The **Domain Name System** provides a dynamic mapping between hostnames and IP addresses. **Port numbers** are used to identify the applications communicating with each other.

# Chapter 2. Link Layer

## 以太网和IEEE 802的封装
两种帧格式都采用48-bit的目的地址和源地址，这就是在本书中所称的**硬件地址**。ARP和RARP协议对32-bit的IP地址和48-bit的硬件地址做映射。
接下来的2个字节，在802标准定义的帧格式中，该字段为**长度**，标记后续数据的字节长度（不包括CRC校验码）。以太网中该字段为**类型**，定义了后续数据的类型。802帧格式中，**类型**字段由后续的子网接入协议（SNAP）的头部给出。
在以太网帧格式中，类型字段之后就是数据。802帧格式中，后续则是3字节的802.2 LLC和5字节的802.2 SNAP。目的服务访问点（Destination Service Access Point, DSAP）和源服务访问点（Source Service Access Point, SSAP）的值都设为0xaa。Ctrl字段的值设为3。随后的3个字节的orgcode字段置为0。再接下来的2个字节的类型字段和以太网帧格式一样。
CRC字段用于数据校验。
802.3标准定义的帧和以太网的帧都有最小长度要求。802.3规定数据部分必须至少为38字节，以太网至少为46字节。长度不够时会插入填充字节（pad）。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-4.png" alt="示例4" title="示例4" width="800" />


## SLIP: Serial Line IP
SLIP是一种在串行线路上对IP数据报进行封装的简单形式。

* IP数据报以一个特殊的字符END（0xc0）结束。为了防止数据包之前的线路噪声被当成数据报内容,大多数实现在数据报的开始处也传一个END字符。
* 如果数据报中含有END字符，会被替换为0xdb，0xdc这两个字节。0xdb是SLIP的ESC字符。
* 如果数据报中含有SLIP的ESC字符，会被替换称0xdb和0xdd。

SLIP有如下缺陷：

* 每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。
* 数据帧中没有类型字段，只支持IP协议。如果一条串行线路用于SLIP，无法同时使用其他协议。 
* SLIP没有数据校验字段，依赖上层协议做数据校验。

## PPP: Point-to-Point
弥补了SLIP的所有缺陷，包含下面三个部分：

* 在串行线路上封装IP数据报的方法。
* 用于建立、配置和测试数据链路连接的协议（LCP）
* 针对不同的网络层协议的网络控制协议体系。

PPP的数据帧都以0x7e开始和结束。紧接着开始字符的是值为0xff的地址字节，然后是0x03的控制字节。之后是协议字段，类似于以太网帧的类型字段，值为0x0021表示信息字段为IP数据报，值为0xc021表示信息字段为链路控制数据，值为0x8021为网络控制数据。CRC为数据校验字段。
由于0x7e是标识位，因此信息字段如果出现了该字符需要进行转码。同步链路可以通过比特填充（bit stuffing）的硬件技术来实现。在异步链路中，特殊字符0x7d用作转义字符。当它出现在PPP数据帧时，那么紧接着的字符的第6个比特要取其补码，具体实现过程如下:
1）当遇到字符0x7e时，需连续传送两个字符: 0x7d和0x5e，以实现标志字符的转义。
2）当遇到转义字符0x7d时,需连续传送两个字符：0x7d和0x5d，以实现转义字符的转义。 
3）默认情况下，如果字符小于0x20（比如，一个ASCII控制字符），一般都要进行转义。例如，遇到字符0x01时需连续传送0x7d和0x21两个字符（这时，第6个比特取补码后变为1，而前面两种情况均把它变为0）。

## Loopback Interface
大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。大多数系统把127.0.0.1分配给该接口，命名为localhost。传给环回接口的IP数据报不能在任何网络出现。
一般来说，一旦传输层检测到目的端地址是环回地址时，应该可以省略部分传输层和所有网络层的逻辑操作。但是大多数的产品还是照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。

下图是环回接口处理IP数据报的简单过程：

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-5.png" alt="示例5" title="示例5" width="800" />

图中需要指出的关键点是:

* 传给环回地址(一般是127.0.0.1)的任何数据均作为IP输入。
* 传给广播地址或多播地址的数据报复制一份传给环回接口,然后送到以太网上。这是因为广播传送和多播传送的定义包含主机本身。
* 任何传给该主机IP地址的数据均送到环回接口。
看上去用传输层和IP层的方法来处理环回数据效率不高，但其简化了设计，因为回接口可以被看作是网络层下面的另一个链路层。网络层把一份数据报传送给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到IP的输入队列中。
在上图中，另一个隐含的意思是发送给主机自身IP地址的IP数据报一般不会出现在相应的网络上。

## MTU
MTU表示链路层的最大传输单元。如果IP层的数据报超过链路层的MTU，IP层会把数据报进行分片。

## 路径MTU
如果两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的MTU。重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。
两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选择的路由不一定是对称的（从A到B的路由可能与从B到A的路由不同）, 因此路径MTU在两个方向可能不一致。


# Chapter 3. IP: Internet Protocol

## Introduction
IP是**不可靠（unreliable）**的，仅提供最好的传输服务，不能保证IP数据报能成功到达目的地。如果发送了错误，IP有简单的错误处理算法：将数据报丢弃并发送ICMP消息报给源。
IP是**无链接（connectionless）**的，不维护数据报的状态信息。每个数据报的处理是互相独立的，因此IP数据报在传输过程有可能乱序。

## IP Header
IP数据报格式如下图：

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-6.png" alt="示例6" title="示例6" width="800" />

普通IP数据报头部大小为20字节，除非有选项字段。
4个字节的32-bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作**big endian字节序**。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作**网络字节序**。

* 长度字段：4-bit，表示协议头具有32位字长的数量。协议头最小值为5。因为该字段占4bit，其最大值为15，因此IP头部最大占用60字节。
* 服务类型：8-bit，包含3-bit优先权子字段（现已被忽略），4-bit的TPS子字段，1-bit未用但必须为0。4-bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用，其中只有一位能够被置为1，如果都是0表示是普通服务。
* 总长度：16-bit，整个IP数据报的长度，以字节为单位。最长可达65535。
  尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片。而且，主机也要求不能接收超过576字节的数据报。UDP限制用户数据报长度为512字节，小于576字节。但事实上现在大多数的实现（特别是那些支持网络文件系统NFS的实现）允许超过8192字节的IP数据报。
  总长度字段是IP首部中必要的内容，因为一些数据链路(如以太网)需要填充一些数据以达到最小长度。尽管以太网的最小帧长为46字节，但是IP数据可能会更短。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容。 
* 标识字段：16-bit，唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。
* TTL（time-to-live）：8位，设置了数据报可以经过的最多路由器数，初始值由源主机设置（通常为32或64），经过一个处理它的路由器就减1，为0时就被丢弃，并发送ICMP通知源主机。
* 协议字段：8位，标记如何demultiplex数据报。
* 检验和（checksum）字段：根据IP头部计算的检验和码。它不对头部后面的数据进行计算。 ICMP、IGMP、UDP、TCP在它们各自的头部中都有同时覆盖头部和数据的检验和码。
  如果接收时校验失败，该数据报会被丢弃，但是不生成错误报文，由上层去发现丢失的数据报并进行重传。
* 源地址 & 目的地址：32-bit

## IP路由
IP路由选择是简单的，特别对于主机来说。如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多数的主机都是采用这种简单机制。
在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报（即在本地生成的数据报）并进行发送，或从一个网络接口接收数据报（待转发的数据报）并进行发送。IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么：

1. 如果IP层被设置为路由器的功能，那么就对数据报进行转发
2. 否则，数据报被丢弃 

路由表中的每一项都包含下面这些信息：

* 目的地址：既可以是一个完整的主机地址，也可以是一个网络地址，由该表中的标志字段来指定。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0,以指定网络中的所有主机。
* 下一站（next-hop router）路由器的IP地址，或者直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。
* 标志：其中一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器还是一个直接相连的接口。
* 为数据报的传输指定一个网络接口。

IP路由选择是逐跳（hop-by-hop）进行的。IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。
IP路由选择主要完成以下功能：

* 搜索路由表，寻找能与目的IP地址完全匹配的表目（**网络号和主机号都要匹配**）。如果找到，则把报文发送给该表目指定的下一站路由器或直接相连的网络接口（取决于标志字段的值）
* 搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接相连的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。这种匹配方法必须考虑可能的子网掩码。
* 搜索路由表，寻找标为默认的表目。如果找到，则把报文发送给该表目指定的下一站路由器。 如果这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自主机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。

**为一个网络指定一个路由器,而不必为每个主机指定一个路由器,这是IP路由选择机制的另一个基本特性。这样做可以极大地缩小路由表的规模。**

## 子网寻址
现在所有的主机都要求支持子网编址。IP地址不仅单纯的由一个网络号和一个主机号组成，主机号还能再分成一个子网号和一个主机号。
这样做的原因是因为A类和B类地址为主机号分配了太多的空间,可分别容纳的主机数为2^24-2和2^16-2。事实上, 一个网络中不需要这么多的主机。（由于全0或全1的主机号都是无效的,因此把总数减去2。）
在InterNIC获得某类IP网络号后，就由当地的系统管理员来进行分配，由他来决定是否建立子网，以及分配多少比特给子网号和主机号。
子网对外部路由器来说**隐藏了内部网络组织（一个校园或公司内部）的细节**。
与30个C类地址相比，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。B类地址140.252被划分为若干子网的事实对于所有子网以外的Internet路由器都是透明的。为了到达IP地址开始部分为140.252的主机，外部路由器只需要知道通往IP地址140.252.104.1的路径。这就是说，对于网络140.252只需一个路由表目，而如果采用30个C类地址，则需要30个路由表目。因此，**子网划分缩减了路由表的规模**。
**子网对于子网内部的路由器是不透明的。**

## 子网掩码
子网掩码是一个32-bit的值,其中值为1的比特留给网络号和子网号，为0的比特留给主机号。
给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：

* 本子网上的主机
* 本网络中其他子网中的主机
* 其他网络上的主机

## ifconfig命令
配置和查询网络接口的命令。ifconfig命令一般在引导时运行，以配置主机上的每个接口。

## netstat命令
netstat命令提供系统上的接口信息。-i参数将打印出接口信息，-n参数则打印出IP地址，而不是主机名字。
这个命令打印出每个接口的MTU、输入分组数、输入错误、输出分组数、输出错误、冲突以及当前的输出队列长度。

# Chapter 4. ARP: Address Resolution Protocol
当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时,是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。
地址解析为这两种不同的地址形式提供映射: 32-bit的IP地址和数据链路层使用的任何类型的地址。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-7.png" alt="示例7" title="示例7" width="800" />

ARP为IP地址到对应的硬件地址之间提供动态映射。这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。
RARP是被那些没有磁盘驱动器的系统使用，它需要系统管理员进行手工设置。

## 例子
任何时候我们敲入下面这个形式的命令：
    % ftp bsdi
都会进行以下这些步骤：

1. 应用程序FTP客户端调用函数gethostbyname把主机名（bsdi）转换成32-bit的IP地址。 这个函数在DNS（域名系统）中称作解析器。这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts）。
2. FTP客户端请求TCP用得到的IP地址建立连接。
3. TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报
4. 如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么 IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那么就通过IP路由函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。在这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。
5. 假定是一个以太网，那么发送端主机必须把32-bit的IP地址变换成48-bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译。这就是ARP的功能。ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。
6. ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。ARP请求数据帧中包含目的主机的IP地址（主机名为 bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”
7. 目的主机的 ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。
8. 收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。
9. 发送IP数据报到目的主机。

在ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48-bit的值，标识不同的以太网或令牌环网络接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，TCP/IP有自己的地址：32-bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。 ARP的功能是在32-bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。
点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。

## ARP高速缓存
ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了近期Internet地址到硬件地址之间映射记录。

## ARP的分组格式

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-8.png" alt="示例8" title="示例8" width="800" />

* 以太网报头中的前两个字段是以太网的源地址和目的地址。目的地址为全1的特殊地址是广播地址，电缆上的所有以太网接口都要接收广播的数据帧。两个字节长的以太网帧类型表示后面数据的类型。对于ARP请求或应答来说，该字段的值为0x0806。
* 硬件类型字段表示硬件地址的类型，值为1即表示以太网地址。协议类型字段表示要映射的协议地址类型，值为0x0800表示IP地址。
* 接下来的两个1字节的字段，硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。
* 操作字段指出四种操作类型： ARP请求：1，ARP应答：2，RARP请求：3，RARP应答：4。这个字段是必须的，因为ARP请求和ARP应答的帧类型字段值是相同的。

对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把应尽地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。

# Chapter 17. TCP: Transmission Control Protocol

## TCP的服务
TCP提供**面向连接的**、**可靠**的**字节流**服务。
面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP。

TCP通过下列方式来提供可靠性：
* 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的UDP数据报长度将保持不变。由TCP传递给IP的信息单位称为**报文段**或**段（segment）**
* 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
* 当TCP收到来自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。
* TCP将保持它首部和数据的检验和。这是一个**端到端的检验和**，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
* 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，**TCP将对收到的数据进行重新排序**，将收到的数据以正确的顺序交给应用层。
* 既然IP数据报会发生重复，TCP的接收端必须**丢弃重复的数据**。
* TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。**TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据**。这将防止较快主机致使较慢主机的缓冲区溢出。
两个应用程序通过TCP连接交换8bit字节构成的字节流。TCP不在字节流中插入记录标识符。我们将这称为字节流服务（bytestreamservice）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。
TCP对字节流的内容不作任何解释。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层完成。
*这种对字节流的处理方式与Unix操作系统对文件的处理方式很相似。Unix的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对Unix的内核来说，它无法区分一个二进制文件与一个文本文件。*

## TCP头部

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-9.png" alt="示例9" title="示例9" width="800" />

* 每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端的应用进程。端口加上IP头部的IP地址唯一确定一个TCP连接。
  一个IP地址和一个端口号也称为一个**插口（socket）**，后来也表示伯克利版的编程接口。插口对（socket pair）可唯一确定互联网中每个TCP连接。
* 序号用以标识从TCP发送端向接收方发送的数据字节流，它表示在这个报文段中的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32-bit的无符号数，序号到达2^32-1后从0开始。
  当建立一个新的连接时，SYN标志变 1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加 1 ,因为SYN标志消耗了一个序号。
  既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。 因此，确认序号应当是上次已成功收到数据的字节序号加1。只有ACK标识为1时，确认序号字段才有效。 
  发送ACK无需任何代价，因为32-bit的确认序号字段和ACK标志一样是TCP头部的一部分。因此一个连接一旦建立起来，这个字段总是被设置，ACK标志也总是被设置为1。
  TCP为应用层提供全双工服务，数据能在两个方向上独立地传输。因此连接的每一端必须保持每个方向上传输数据序号。
* 长度字段给出头部中32-bit字的数目，因为任选字段的长度是可变的。这个字段占4bit，因此TCP最多有60字节的首部。如果没有任选字段，正常的长度是20字节。
* 在TCP头部中有6个标志比特。它们中的多个可同时被设置为1。 这里先简单介绍下用法：
  * URG：紧急指针有效
  * ACK：确认序号有效
  * PSH：接收方应该尽快将这个报文段交给应用层
  * RST：重建连接
  * SYN：同步序号用以发起一个连接
  * FIN：发送端完成发送任务

* TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段的值，这个值是接受端期望接收的字节。
* 检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性字段，由发送端计算和设置，并由收端进行验证。
* 只有当URG标识为1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式（urgent pointer）是发送端向另一端发送紧急数据的一种方式。
* 最常见的可选字段是最长报文大小，又称为**MSS（Maximum Segment Size）**。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。
* TCP报文段中的数据部分是可选的，一个连接建立或终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也会使用没有任何数据的头部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

# Chapter 18. TCP Connection Establishment and Termination

## 三次握手
为了建立一条TCP连接：
1. 客户端发送SYN段指定要连接的服务器的端口，以及初始序号（ISN）。
2. 服务器端发回包含服务器端的初始序号的SYN报文段作为应答。同时将确认序号设置为客户端的ISN加1以对客户端的SYN报文段进行确认。
3. 客户端必须酱确认序号设置为服务端的ISN加1以对服务端的SYN报文端进行确认。
发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。RFC 793指出ISN可看作是一个32-bit的计数器，每4ms加1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个已存在的连接对它作错误的解读。

## 四次挥手
建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭（half－close）造成的。TCP连接是全双工的，因此每个方向必须单独关闭。当一方完成数据发送任务后就发送FIN来终止这个方向的连接，当一端收到FIN，必须通知应用层另外一端已经终止了数据传输。发送FIN通常是应用层进行关闭的结果。

## 连接建立的超时
通过tcpdump抓包显示，第二个SYN与第一个的间隔是5.8秒，而第三个与第二个的间隔是24秒。客户端一般在第三个分组发出后48秒后放弃连接。

### 第一次超时时间
在上面抓包结果中一个令人困惑的问题是第一次超时时间为5.8秒，接近6秒。相比之下第二个超时时间几乎准确为24秒。这是因为BSD版的TCP软件采用一种500ms的定时器，这种定时器用于确定本章中所有各类型的TCP超时。当我们键入telnet命令时将建立一个6秒的定时器（12个时钟滴答），但它会在设置后的第一个0～500ms内任意时刻减1。从那之后，定时器大约每隔500ms减1，但第一个500ms内是可变的。

## 最大报文段长度
最大报文段长度（MSS）表示TCP传往另一端的最大数据块的长度。
当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文段中）。如果一方没有接收到来自另一方的MSS值，则MSS就定为默认值536字节。

在本章见到的涉及BSD/386和SVR4的MSS为1024，这是因为许多BSD的实现版本需要MSS为512的倍数。其他系统，当双方都在一个本地以太网时都规定MSS为1460。如果目的IP地址为“非本地的”，MSS通常的默认值为536。而区分地址是否为本地非常简单，如果目的IP地址的网络号与子网号都和我们相同，则是本地的；如果目的IP地址的网络号与我们不同，则是非本地的。如果目的IP地址的网络号与我们相同而子网号不同，则可能是本地也可能是非本地的。大多数TCP实现版都提供了一个配置选项，让系统管理员说明不同的子网是属于本地还是非本地。
MSS让主机限制另一端发送数据报的长度，主机自身也能控制发送数据报的长度，这使得主机在连接到较小MTU的网络时避免分段。

只有当主机直接连接到MTU小于576字节的网络时，才能以这种方式避免分段。如果两端的主机都连接到以太网上，都采用536的MSS，但是中间网络采用296的MTU，也会出现分段。解决这个问题的唯一办法是MTU发现机制。

## TCP的状态变迁图

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-10.png" alt="示例10" title="示例10" width="800" />

## 2MSL等待状态
TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。MSL是任何报文段被丢弃前在网络内的最长时间。
当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。
这种2MSL等待的另一个作用是当TCP连接在2MSL等待期间，定义这个连接的插口（客户端的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。只能在2MSL结束后才能使用。
对于同一连接的前一个替身，这个具体实现中的特性让客户程序和服务器程序能连续地重用每一端的相同端口号，但这只有在服务器执行主动关闭才有效。

## 平静时间的概念
如果使用处于 2 M S L 等待端口的主机出现故障,它会在MSL秒内重现启动，并立即使用故障前扔处于2MSL的插口对来建立一个新的连接吗？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号,都会发生这种情况。为了防止这种情况发生，RFC 793指出TCP在在重启后的MSL秒内不能建立任何连接，这就称为**平静时间**。

## 复位报文段

### 到不存在的端口的连接请求
产生复位的一种常见情况是当连接请求到达时，目的端口没有进程在监听。对于UDP来说，将产生一个ICMP端口不可达的信息。而TCP则使用复位。

### 异常终止一个连接
终止一个连接的正常方式是一方发送FIN，通常也称为**有序释放（orderly release）**，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。
但也有可能发送一个复位报文段而不是FIN来中途释放一个连接，有时称为**异常释放（abortive release）**。

异常终止一个连接对应用程序来说有两个特点：

* 丢弃任何待发数据并立即发送复位报文段。
* RST的接收方会区分另一端执行的是异常关闭还是正常关闭。应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。

RST报文段中包含一个序号和确认序号。需要注意的是RST报另一端不会回复ack确认。收到RST的一方将终止该连接，并通知应用层连接复位。

### 检测半打开连接
如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的 。
半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机。这可能发生在使用PC机作为Telnet的客户主机上，例如，用户在一天工作结束时关闭PC机的电源。当关闭PC机电源时，如果已不再有要向服务器发送的数据，服务器将永远不知道客户端程序已经消失来。当用户第二天开机，启动新的Telnet客户端程序时，在服务器主机上会启动一个新的服务器程序。这样会导致服务器主机中产生许多半打开的TCP连接。

如果是客户端向重新启动TCP的服务器发数据包，由于服务器丢失重启之前连接的所有信息，因此它不知道数据报文段中提到的连接。 TCP的处理原则是接收方以复位作为应答。

## 同时打开
两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。这又称为**同时打开（simultaneous open）**。
TCP是特意设计为了可以处理同时打开，对于同时打开它仅建立一条连接而不是两条连接。
当出现同时打开的情况时,状态变迁与之前的状态变迁图所示的不同。两端几乎在同时发送SYN，并进入SYN_SENT状态。当一端收到SYN时，状态变为SYN_RCVD，同时它们都再发SYN并对收到的SYN进行确认。当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-11.png" alt="示例11" title="示例11" width="800" />

## 同时关闭
双方都执行主动关闭也是可能的，TCP协议也允许这样的同时关闭（simultaneous close）。
当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1。这将导致双方各发送一个FIN，两个FIN经过网络传送后分别到达另一端。收到FIN后，状态由FIN_WAIT_1变迁为CLOSING，并发送最后的ACK。当收到最后的ACK时，状态变化为TIME_WAIT。

<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-12.png" alt="示例12" title="示例12" width="800" />

## TCP 服务器的设计

### 呼入连接请求队列
一个并发服务器调用一个新的进程来处理每个客户请求，因此处于被动连接请求的服务器应该始终准备处理下一个呼入的连接请求。那正是使用并发服务器的根本原因。但仍有可能出现当服务器在创建一个新的进程时，或操作系统正忙于处理优先级更高的进程时，到达多个连接请求。当服务器正处于忙时，TCP是如何处理这些呼入的连接请求？
在伯克利的TCP实现中采用以下规则：
1. 正在等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受（三次握手已经完成），但还没被应用层所接受。注意这里的区别在于TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
2. 应用层将指明该队列的最大长度，这个值通常称为**积压值（backlog）**。它的取值范围是0～5之间的整数，包块0和5。
3. 当一个连接请求（即SYN）到达时，TCP使用一个算法，根据当前连接队列的连接数来确定是否接收这个连接。
   <img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-13.png" alt="示例13" title="示例13" width="800" />
   在这个图中，Solaris系统规定的值正如我们所期望的。而传统的BSD系统，将这个值（由于某些原因）设置为积压值乘3除以2，再加1。
4. 如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接。另外，当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列）。
5. 如果对于新的连接请求，连接队列已经没有空间，TCP将不理会收到的SYN，也不发回任何报文段（即不发回RST）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户端的主动打开最终将超时。

# Chapter 19. TCP Interactive Data Flow

## Delayed Acknowledgments
通常TCP在接收到数据时并不立即发送ACK。相反，它推迟发送以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带（**piggyback**）ACK）。绝大多数实现采用的时延为200ms，也就是说TCP将以最大200ms的时延等待是否有数据一起发送。

## Nagle算法
Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。小数据被TCP收集，并在ACK到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的：确认到达得越快，数据也就发送得越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。

# Chapter 20. TCP Bulk Data Flow

## 滑动窗口
下图用可视化的方法显示了滑动窗口协议：
<img src="/assets/images/the-protocols-tcp-ip-illustrated-note1/illustration-14.png" width="800" />

## 窗口大小
由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。
Socket API允许进程设置发送和接收缓存的大小。接收缓存的大小是该连接上所能够通告的最大窗口大小。有一些应用程序通过修改socket缓存大小来增加性能。

## PUSH标志
发送方使用PUSH标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。
通过允许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP不用等待额外数据，而是马上向服务器发送报文段。类似地，服务器TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程，而不是等待额外数据。
然而目前大多数API没有提供设置PUSH标志的方法。

如果待发送的数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。
由于源于伯克利的实现一般从不将接收到的数据推迟交付给应用程序，因此它们忽略所接收的PUSH标志。

## 慢启动
慢启动，是传输控制协议（TCP）使用的一种阻塞控制机制。 慢启动为发送方的TCP增加了另一个窗口：**拥塞窗口（congestion window）**，记为cwnd。
当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。
   
# Chapter 21. TCP Timeout and Retransmission
TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。

TCP管理4种不同的定时器：
* 重传定时器：当希望收到另一端的确认时使用。
* 坚持定时器：使窗口信息保持不断流动，即使另一端关闭了其接收窗口。
* 保活定时器：检测一个空闲连接的另一端何时崩溃或重启。
* 2MSL定时器：测量一个连接处于TIME_WATI状态的时间。