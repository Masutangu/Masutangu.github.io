<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Masutangu</title>
    <description>ä¹Ÿè¨±æˆ‘é€™ä¸€ç”Ÿã€€å§‹çµ‚åœ¨è¿½é€é‚£é¡†ä¹è™Ÿçƒ</description>
    <link>http://masutangu.com/</link>
    <atom:link href="http://masutangu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 05 Jul 2018 13:46:43 +0800</pubDate>
    <lastBuildDate>Thu, 05 Jul 2018 13:46:43 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>etcd-raft æºç å­¦ä¹ ç¬”è®°ï¼ˆLinearizable Read ç¯‡ï¼‰</title>
        <description>&lt;p&gt;è¿™ç¯‡æ–‡ç« ä»‹ç» etcd-raft å¦‚ä½•å®ç° linearizable readï¼ˆlinearizable read ç®€å•çš„è¯´å°±æ˜¯ä¸è¿”å› stale æ•°æ®ï¼Œå…·ä½“å¯ä»¥çœ‹è¿™ç¯‡æ–‡ç«  &lt;a href=&quot;https://aphyr.com/posts/313-strong-consistency-models&quot;&gt;ã€ŠStrong consistency modelsã€‹&lt;/a&gt;ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;raft è®ºæ–‡ç¬¬ 8 èŠ‚é˜è¿°äº†æ€è·¯ï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;åœ¨æ”¶åˆ°è¯»è¯·æ±‚æ—¶ï¼Œleader èŠ‚ç‚¹ä¿å­˜ä¸‹å½“å‰çš„ commit indexï¼Œå¹¶å¾€ peers å‘é€å¿ƒè·³ã€‚å¦‚æœç¡®å®šè¯¥èŠ‚ç‚¹ä¾ç„¶æ˜¯ leaderï¼Œåˆ™åªéœ€è¦ç­‰åˆ°è¯¥ commit index çš„ log entry è¢« apply åˆ°çŠ¶æ€æœºæ—¶å°±å¯ä»¥è¿”å›å®¢æˆ·ç«¯ç»“æœã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘ä»¬å…ˆé€šè¿‡ä½äº etcd/etcdserver ç›®å½•ä¸‹çš„æ ·ä¾‹æ¥çœ‹çœ‹åº”ç”¨å±‚æ˜¯å¦‚ä½•ä½¿ç”¨ ReadIndex æ¥ä¿è¯ linearizable read çš„ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// v3_server.go

type RaftKV interface {
    Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)
    Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)
    DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)
    Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)
    Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
}

func (s *EtcdServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
    var resp *pb.RangeResponse
    var err error

    if !r.Serializable {
        err = s.linearizableReadNotify(ctx)  // ç­‰å¾… linearizableReadNotify è¿”å› æ‰èƒ½ç»§ç»­å¾€ä¸‹èµ°
        if err != nil {
            return nil, err
        }
    }
    // è¯»å–æ•°æ®é€»è¾‘ çœç•¥..
    ...
    return resp, err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;åœ¨è¯»è¯·æ±‚ &lt;code&gt;Range&lt;/code&gt; æ‰§è¡Œå‰ï¼Œè°ƒç”¨äº† &lt;code&gt;linearizableReadNotify&lt;/code&gt;ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *EtcdServer) linearizableReadNotify(ctx context.Context) error {
    s.readMu.RLock()
    nc := s.readNotifier
    s.readMu.RUnlock()

    // signal linearizable loop for current notify if it hasn&amp;#39;t been already
    select {
    case s.readwaitc &amp;lt;- struct{}{}:
    default:
    }

    // wait for read state notification
    select {
    case &amp;lt;-nc.c:
        return nc.err
    case &amp;lt;-ctx.Done():
        return ctx.Err()
    case &amp;lt;-s.done:
        return ErrStopped
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;linearizableReadNotify&lt;/code&gt; å¾€ &lt;code&gt;readwaitc&lt;/code&gt; å‘é€ä¸ªç©ºçš„ç»“æ„ä½“ï¼Œå¹¶ä¸”ç­‰å¾… &lt;code&gt;nc.c&lt;/code&gt; çš„è¿”å›ã€‚&lt;code&gt;readwaitc&lt;/code&gt; æ˜¯åœ¨å¦å¤–çš„ goroutine &lt;code&gt;linearizableReadLoop&lt;/code&gt; é‡Œç›‘å¬çš„ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;
func (s *EtcdServer) linearizableReadLoop() {
    var rs raft.ReadState

    for {
        ctx := make([]byte, 8)
        binary.BigEndian.PutUint64(ctx, s.reqIDGen.Next())  // ctx å³è¯·æ±‚å”¯ä¸€æ ‡è¯† reqId

        select {
        case &amp;lt;-s.readwaitc:  // ç›‘å¬ readwaitc
        case &amp;lt;-s.stopping:
            return
        }

        nextnr := newNotifier()
        nr := s.readNotifier
        s.readNotifier = nextnr

        s.r.ReadIndex(cctx, ctx)  // è°ƒç”¨ ReadIndex æ¥å£ï¼Œå¾€ recvc channel å‘é€ type ä¸º pb.MsgReadIndex çš„è¯·æ±‚

        var (
            timeout bool
            done    bool
        )
        for !timeout &amp;amp;&amp;amp; !done {
            select {
            case rs = &amp;lt;-s.r.readStateC:  // æ”¶åˆ° ready å¯¹è±¡æ—¶ï¼Œä¼šå¾€ readStateC channel ä¼ å›æ¥ readStateï¼Œè§ etcd/etcdserver/raft.go æ–‡ä»¶çš„ func (r *raftNode) start(rh *raftReadyHandler)
                done = bytes.Equal(rs.RequestCtx, ctx)  // æ¯”è¾ƒä¸‹ reqId æ˜¯å¦ä¸€è‡´
            case &amp;lt;-time.After(s.Cfg.ReqTimeout()):
                nr.notify(ErrTimeout)
                timeout = true
            case &amp;lt;-s.stopping:
                return
            }
        }
        if !done {
            continue
        }

        // ç­‰å¾… readState é‡Œçš„ indexï¼Œä¹Ÿå°±æ˜¯æ”¶åˆ° pb.MsgReadIndex è¯·æ±‚æ—¶ï¼Œleader èŠ‚ç‚¹å½“å‰çš„ commit index è¢« apply åˆ°çŠ¶æ€æœºæ—¶ï¼Œæ­¤æ—¶è°ƒç”¨ nr.notify(nil) é€šçŸ¥åº”ç”¨å±‚å¯ä»¥è¯»å–çŠ¶æ€æœºé‡Œçš„æ•°æ®äº†ï¼Œç¡®ä¿è¯»åˆ°çš„ä¸æ˜¯ stale æ•°æ®
        if ai := s.getAppliedIndex(); ai &amp;lt; rs.Index {
            select {
            case &amp;lt;-s.applyWait.Wait(rs.Index):
            case &amp;lt;-s.stopping:
                return
            }
        }
        // unblock all l-reads requested at indices before rs.Index
        nr.notify(nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;åœ¨ &lt;code&gt;linearizableReadLoop&lt;/code&gt; è°ƒç”¨ &lt;code&gt;nr.notify&lt;/code&gt; åï¼Œ&lt;code&gt;linearizableReadNotify&lt;/code&gt; ä» select é˜»å¡ä¸­è¿”å›ï¼Œæ­¤æ—¶å°±å¯ä»¥ç»§ç»­èµ° &lt;code&gt;Range&lt;/code&gt; çš„é€»è¾‘ï¼Œè¯»å–æ•°æ®ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯ã€‚&lt;/p&gt;

&lt;p&gt;ä»ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬äº†è§£äº†åº”ç”¨å±‚å¦‚ä½•ä½¿ç”¨ Node çš„ &lt;code&gt;ReadIndex&lt;/code&gt; æ¥å£æ¥å®ç° linearizable readã€‚ä¸‹é¢æˆ‘ä»¬æ¥ä»‹ç» &lt;code&gt;ReadIndex&lt;/code&gt; è¿™ä¸ªæ–°æ¥å£ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()

    // ReadIndex request a read state. The read state will be set in the ready.
    // Read state has a read index. Once the application advances further than the read
    // index, any linearizable read requests issued before the read request can be
    // processed safely. The read state will have the same rctx attached.
    ReadIndex(ctx context.Context, rctx []byte) error
}

func (n *node) ReadIndex(ctx context.Context, rctx []byte) error {
    return n.step(ctx, pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;ä¸Šç¯‡æ–‡ç«  &lt;a href=&quot;http://masutangu.com/2018/07/etcd-raft-note-2/&quot;&gt;ã€Šetcd-raft æºç å­¦ä¹ ç¬”è®°ï¼ˆæ¦‚è§ˆç¯‡ï¼‰ã€‹&lt;/a&gt; æåˆ°å½“èŠ‚ç‚¹ä¸º leader æ—¶ï¼Œ&lt;code&gt;step&lt;/code&gt; è¢«è®¾ç½®ä¸º &lt;code&gt;stepLeader&lt;/code&gt; ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹ &lt;code&gt;stepLeader&lt;/code&gt; æ˜¯å¦‚ä½•å¤„ç† type ä¸º pb.MsgReadIndex çš„ readIndexReq çš„ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgReadIndex:
        // raft 5.4 safty æ£€æŸ¥
        if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
            // Reject read only request when this leader has not committed any log entry at its term.
            return nil
        }

        // thinking: use an interally defined context instead of the user given context.
        // We can express this in terms of the term and index instead of a user-supplied value.
        // This would allow multiple reads to piggyback on the same message.
        switch r.readOnly.option {
        case ReadOnlySafe:
            r.readOnly.addRequest(r.raftLog.committed, m)  // æŠŠ readIndexReq ä¿å­˜èµ·æ¥
            r.bcastHeartbeatWithCtx(m.Entries[0].Data)  // å¹¿æ’­å¿ƒè·³åŒ…
        }
        return nil
    }
    return nil
}


&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;æ”¶åˆ° readIndexReq åï¼Œé¦–å…ˆè°ƒç”¨ &lt;code&gt;r.readOnly.addRequest&lt;/code&gt; ä¿å­˜ä¸‹æ¥ï¼Œç„¶åè°ƒç”¨ &lt;code&gt;bcastHeartbeatWithCtx&lt;/code&gt; å¹¿æ’­å¿ƒè·³åŒ…ï¼Œ ctx å³å”¯ä¸€æ ‡è¯† readIndexReq çš„ reqIdã€‚å†çœ‹çœ‹ &lt;code&gt;stepLeader&lt;/code&gt; å¦‚ä½•å¤„ç†å¿ƒè·³å›åŒ…ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgHeartbeatResp:
        pr.RecentActive = true
        pr.resume()

        if r.readOnly.option != ReadOnlySafe || len(m.Context) == 0 {
            return nil
        }

        ackCount := r.readOnly.recvAck(m)
        if ackCount &amp;lt; r.quorum() {  // åˆ¤æ–­æ˜¯å¦æ”¶åˆ° quorum çš„å¿ƒè·³å›åŒ…
            return nil
        }

        // æ”¶åˆ° quorum çš„å¿ƒè·³å›åŒ…äº†ï¼ŒæŠŠ readIndexReq ä¾æ¬¡ append r.readStates ä¸­ï¼Œè¿”å› ready å¯¹è±¡æ—¶ä¼šåŒ…å« r.readStates
        rss := r.readOnly.advance(m)
        for _, rs := range rss {
            req := rs.req
            if req.From == None || req.From == r.id { // from local member
                r.readStates = append(r.readStates, ReadState{Index: rs.index, RequestCtx: req.Entries[0].Data})
            } else {
                r.send(pb.Message{To: req.From, Type: pb.MsgReadIndexResp, Index: rs.index, Entries: req.Entries})
            }
        }
    return nil
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;è°ƒç”¨ &lt;code&gt;r.readOnly.recvAck&lt;/code&gt;ï¼Œæ ¹æ® readIndeReq çš„ reqId ç»Ÿè®¡æ”¶åˆ°å¿ƒè·³å›åŒ…çš„æ•°é‡ï¼Œå¦‚æœè¶…è¿‡ quonum è¡¨ç¤ºè¯¥èŠ‚ç‚¹ä¾ç„¶æ˜¯ leaderï¼Œæ­¤æ—¶ä» &lt;code&gt;r.readOnly.advance&lt;/code&gt; æ‹¿åˆ°ä¿å­˜çš„ readIndexReqï¼Œappend åˆ° &lt;code&gt;r.readStates&lt;/code&gt; ä¸­ã€‚ä¹‹åè°ƒç”¨ &lt;code&gt;newReady&lt;/code&gt; ä¼šæŠŠ &lt;code&gt;r.readStates&lt;/code&gt; è¿”å›ç»™åº”ç”¨å±‚ï¼Œåº”ç”¨å±‚å–å‡º readIndexReq ä¸­çš„ commit indexï¼Œç­‰åˆ°å…¶è¢« apply åˆ°çŠ¶æ€æœºå°±å¯ä»¥å…è®¸è¯»æ“ä½œäº†ã€‚&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    ...

    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates  // é™„ä¸Š r.readStates
    }
    ...
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 05 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-3/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-3/</guid>
        
        
        <category>æºç é˜…è¯»</category>
        
      </item>
    
      <item>
        <title>etcd-raft æºç å­¦ä¹ ç¬”è®°ï¼ˆæ¦‚è§ˆç¯‡ï¼‰</title>
        <description>&lt;p&gt;è¿™ç¯‡æ–‡ç« ä¸»è¦æ•´ä½“ä¸Šä»‹ç» etcd-raft åº“ï¼ŒåŒ…æ‹¬å„ä¸ªç±»çš„ä½œç”¨ï¼Œç±»ä¹‹é—´çš„ä¸²è”ã€‚ä¸æ¶‰åŠ raft ç®—æ³•ã€‚å…ˆæ¥çœ‹çœ‹ etcd-raft å‡ ä¸ªç»“æ„ä½“çš„å®šä¹‰ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raft struct {
    id uint64

    Term uint64
    Vote uint64

    // the log
    raftLog *raftLog

    state StateType

    // isLearner is true if the local raft node is a learner.
    isLearner bool

    votes map[uint64]bool

    msgs []pb.Message

    // the leader id
    lead uint64

    tick func()
    step stepFunc
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raftLog struct {
    // storage contains all stable entries since the last snapshot.
    storage Storage

    // unstable contains all unstable entries and snapshot.
    // they will be saved into storage.
    unstable unstable

    // committed is the highest log position that is known to be in
    // stable storage on a quorum of nodes.
    committed uint64
    // applied is the highest log position that the application has
    // been instructed to apply to its state machine.
    // Invariant: applied &amp;lt;= committed
    applied uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// unstable.entries[i] has raft log position i+unstable.offset.
// Note that unstable.offset may be less than the highest log
// position in storage; this means that the next write to storage
// might need to truncate the log before persisting unstable.entries.
type unstable struct {
    // the incoming unstable snapshot, if any.
    snapshot *pb.Snapshot
    // all entries that have not yet been written to storage.
    entries []pb.Entry
    offset  uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// node is the canonical implementation of the Node interface
type node struct {
    propc      chan msgWithResult
    recvc      chan pb.Message
    readyc     chan Ready
    advancec   chan struct{}
    tickc      chan struct{}
    done       chan struct{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Ready encapsulates the entries and messages that are ready to read,
// be saved to stable storage, committed or sent to other peers.
// All fields in Ready are read-only.
type Ready struct {
    // The current volatile state of a Node.
    // SoftState will be nil if there is no update.
    // It is not required to consume or store SoftState.
    *SoftState

    // The current state of a Node to be saved to stable storage BEFORE
    // Messages are sent.
    // HardState will be equal to empty state if there is no update.
    pb.HardState

    // ReadStates can be used for node to serve linearizable read requests locally
    // when its applied index is greater than the index in ReadState.
    // Note that the readState will be returned when raft receives msgReadIndex.
    // The returned is only valid for the request that requested to read.
    ReadStates []ReadState

    // Entries specifies entries to be saved to stable storage BEFORE
    // Messages are sent.
    Entries []pb.Entry

    // Snapshot specifies the snapshot to be saved to stable storage.
    Snapshot pb.Snapshot

    // CommittedEntries specifies entries to be committed to a
    // store/state-machine. These have previously been committed to stable
    // store.
    CommittedEntries []pb.Entry

    // Messages specifies outbound messages to be sent AFTER Entries are
    // committed to stable storage.
    // If it contains a MsgSnap message, the application MUST report back to raft
    // when the snapshot has been received or has failed by calling ReportSnapshot.
    Messages []pb.Message

    // MustSync indicates whether the HardState and Entries must be synchronously
    // written to disk or if an asynchronous write is permissible.
    MustSync bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;è¿™å‡ ä¸ªç»“æ„ä½“çš„å…³ç³»å¦‚ä¸‹å›¾ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;RaftLog çš„ &lt;code&gt;Storage&lt;/code&gt; å’Œ RaftNode çš„ &lt;code&gt;raftStorage&lt;/code&gt; éƒ½æ˜¯æŒ‡å‘åŒä¸€ä¸ª Storage å¯¹è±¡ï¼ˆè™šçº¿è¡¨ç¤ºæŒ‡é’ˆï¼‰ã€‚Storage åœ¨ kvstore çš„ç¤ºä¾‹ä¸­çš„å®ç°ä¸º MemoryStorageï¼Œå¯ä»¥ç†è§£ä¸º WAL çš„ä¸€ä¸ªå†…å­˜ç¼“å­˜ã€‚é‡å¯æ—¶ä¼šä» WAL æ¢å¤ MemoryStorage çš„æ•°æ®ã€‚æ•´ä¸ªé€»è¾‘ç”± Node çš„ &lt;code&gt;run&lt;/code&gt; æ–¹æ³•çš„ for loop é©±åŠ¨ï¼Œä» &lt;code&gt;recvc&lt;/code&gt; channel æ¥æ”¶è¯·æ±‚ï¼Œè°ƒç”¨ raft çš„ &lt;code&gt;Step&lt;/code&gt; å‡½æ•°è¿›è¡Œå¤„ç†ã€‚&lt;code&gt;Step&lt;/code&gt; å‡½æ•°ä¼šè°ƒç”¨ &lt;code&gt;step&lt;/code&gt;ï¼Œ&lt;code&gt;step&lt;/code&gt; æ˜¯å‡½æ•°æŒ‡é’ˆï¼Œåœ¨èŠ‚ç‚¹æˆä¸º leader æ—¶å°†å…¶è®¾ç½®ä¸º &lt;code&gt;stepLeader&lt;/code&gt;ï¼ŒèŠ‚ç‚¹å˜æˆ follower æ—¶è®¾ç½®ä¸º &lt;code&gt;stepFollower&lt;/code&gt;ã€‚&lt;code&gt;step&lt;/code&gt; å¤„ç† append è¯·æ±‚æ—¶ï¼Œä¼šè°ƒç”¨ raftLog çš„ &lt;code&gt;maybeAppend&lt;/code&gt; æ–¹æ³•ï¼Œæœ€ç»ˆä¼šæŠŠ entries append åˆ° &lt;code&gt;unstable&lt;/code&gt; ä¸­ã€‚&lt;/p&gt;

&lt;p&gt;åœ¨ Node &lt;code&gt;run&lt;/code&gt; æ–¹æ³•çš„ for loop ä¸­ï¼Œä¼šå®šæœŸé€šè¿‡ &lt;code&gt;newReady&lt;/code&gt; å‡½æ•°æ„é€  Ready å¯¹è±¡ã€‚Ready åŒ…æ‹¬å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HardState å³ raft èŠ‚ç‚¹çš„ persistent state &lt;/li&gt;
&lt;li&gt;SoftState å³ raft èŠ‚ç‚¹çš„ volatile state &lt;/li&gt;
&lt;li&gt;CommittedEntries å³å·²ç» commit çš„ log entriesï¼Œéœ€è¦åº”ç”¨å±‚ apply åˆ°çŠ¶æ€æœº&lt;/li&gt;
&lt;li&gt;Entries å³ unstable ä¸­çš„ log entriesï¼ˆæœªè½ç›˜çš„ log entriesï¼‰&lt;/li&gt;
&lt;li&gt;Snapshot å³éœ€è¦æŒä¹…åŒ–çš„ snapshot&lt;/li&gt;
&lt;li&gt;Messages å³ mailboxï¼Œæ‰€æœ‰è¿˜æœªå‘é€çš„æ¶ˆæ¯&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ„é€ å¥½çš„ &lt;code&gt;Ready&lt;/code&gt; å¯¹è±¡å‘é€åˆ° &lt;code&gt;readyc&lt;/code&gt; channelï¼ŒRaftNode å–å‡ºåä¼šåšå¦‚ä¸‹å¤„ç†ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;æŒä¹…åŒ– HardStateã€Entriesã€Snapshot åˆ° Storage å’Œ WAL (&lt;code&gt;raftStorage.ApplySnapshot()&lt;/code&gt;ã€&lt;code&gt;raftStorage.Append()&lt;/code&gt; å’Œ &lt;code&gt;wal.Save(rd.HardState, rd.Entries)&lt;/code&gt; å¯ä»¥çœ‹å‡º memoryStorage æ˜¯ wal çš„ç¼“å­˜ï¼Œå†™ wal çš„åŒæ—¶ä¹Ÿå†™ memoryStorage)&lt;/li&gt;
&lt;li&gt;apply CommittedEntries åˆ°çŠ¶æ€æœº&lt;/li&gt;
&lt;li&gt;å¹¿æ’­ Messages &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å¤„ç†å®Œåè°ƒç”¨ Node.Advance() é€šçŸ¥ Node Ready å¯¹è±¡å¤„ç†å®Œæ¯•ï¼Œå‡†å¤‡å¥½æ¥æ”¶ä¸‹ä¸€ä¸ªã€‚&lt;/p&gt;

&lt;p&gt;æœ€åçœ‹çœ‹é©±åŠ¨æ•´ä¸ªé€»è¾‘çš„ &lt;code&gt;run&lt;/code&gt; æ–¹æ³•ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (n *node) run(r *raft) {
    var propc chan msgWithResult
    var readyc chan Ready
    var advancec chan struct{}
    var prevLastUnstablei, prevLastUnstablet uint64
    var havePrevLastUnstablei bool
    var prevSnapi uint64
    var rd Ready

    lead := None
    prevSoftSt := r.softState()
    prevHardSt := emptyState

    for {
        if advancec != nil {
            readyc = nil
        } else {
            // åº”ç”¨å±‚é€šçŸ¥ä¸Šä¸€ä¸ª ready å¯¹è±¡å·²ç»å¤„ç†å®Œæ¯•äº† æ­¤æ—¶ advancec ä¸º nil 
            rd = newReady(r, prevSoftSt, prevHardSt)
            if rd.containsUpdates() { // æœ‰æ›´æ–°æ‰æŠŠ readyc è®¾ä¸º éç©º
                readyc = n.readyc
            } else {
                readyc = nil
            }
        }

        select {
        case m := &amp;lt;-n.recvc:
            // filter out response message from unknown From.
            if pr := r.getProgress(m.From); pr != nil || !IsResponseMsg(m.Type) {
                r.Step(m)
            }
        case &amp;lt;-n.tickc:
            r.tick()
        case readyc &amp;lt;- rd:
            if rd.SoftState != nil {
                prevSoftSt = rd.SoftState
            }
            if len(rd.Entries) &amp;gt; 0 {
                prevLastUnstablei = rd.Entries[len(rd.Entries)-1].Index
                prevLastUnstablet = rd.Entries[len(rd.Entries)-1].Term
                havePrevLastUnstablei = true
            }
            if !IsEmptyHardState(rd.HardState) {
                prevHardSt = rd.HardState
            }
            if !IsEmptySnap(rd.Snapshot) {
                prevSnapi = rd.Snapshot.Metadata.Index
            }

            r.msgs = nil
            r.readStates = nil
            advancec = n.advancec
        case &amp;lt;-advancec:
            if prevHardSt.Commit != 0 {
                r.raftLog.appliedTo(prevHardSt.Commit)
            }
            // åº”ç”¨å±‚å¤„ç†å®Œäº† è¡¨ç¤º unstable çš„ä¸œè¥¿ä¸éœ€è¦äº† è¯¥æ¸…ç†å°±æ¸…ç†
            if havePrevLastUnstablei {
                r.raftLog.stableTo(prevLastUnstablei, prevLastUnstablet)
                havePrevLastUnstablei = false
            }
            r.raftLog.stableSnapTo(prevSnapi)
            advancec = nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;è¿˜æœ‰æ„é€  Ready å¯¹è±¡çš„ &lt;code&gt;newReady&lt;/code&gt; å‡½æ•°ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    if softSt := r.softState(); !softSt.equal(prevSoftSt) {
        rd.SoftState = softSt
    }
    if hardSt := r.hardState(); !isHardStateEqual(hardSt, prevHardSt) {
        rd.HardState = hardSt
    }
    if r.raftLog.unstable.snapshot != nil {
        rd.Snapshot = *r.raftLog.unstable.snapshot
    }
    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates
    }
    rd.MustSync = MustSync(rd.HardState, prevHardSt, len(rd.Entries))
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Wed, 04 Jul 2018 13:33:35 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-2/</guid>
        
        
        <category>æºç é˜…è¯»</category>
        
      </item>
    
      <item>
        <title>etcd-raft æºç å­¦ä¹ ç¬”è®°ï¼ˆç¤ºä¾‹ç¯‡ï¼‰</title>
        <description>&lt;p&gt;æœ¬ç³»åˆ—æ–‡ç« ä¸º &lt;a href=&quot;https://github.com/coreos/etcd/tree/master/raft&quot;&gt;etcd-raft&lt;/a&gt; æºç é˜…è¯»ç¬”è®°ï¼Œé‡‡ç”¨è‡ªé¡¶å‘ä¸‹çš„æ–¹å¼ã€‚è¿™ç¯‡æ˜¯å¼€ç¯‡ï¼Œé¦–å…ˆæ¥çœ‹çœ‹ etcd æä¾›çš„åŸºäº raft åº“å®ç°çš„ kv store ç¤ºä¾‹ï¼Œä»£ç ç›®å½•ä½äº contrib/raftexampleã€‚&lt;/p&gt;

&lt;p&gt;ä» main å‡½æ•°å¼€å§‹è¯»èµ·ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
    ...
    proposeC := make(chan string)
    defer close(proposeC)

    var kvs *kvstore
    getSnapshot := func() ([]byte, error) { return kvs.getSnapshot() }
    commitC, errorC, snapshotterReady := newRaftNode(*id, strings.Split(*cluster, &amp;quot;,&amp;quot;), *join, getSnapshot, proposeC, confChangeC)

    kvs = newKVStore(&amp;lt;-snapshotterReady, proposeC, commitC, errorC)
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;getSnapshot&lt;/code&gt; ä¸ºåº”ç”¨å±‚ kv æä¾›çš„ snapshot æ–¹æ³•ï¼Œåœ¨ raft ä¸­è°ƒç”¨è¯¥æ–¹æ³•è¿›è¡Œ snapshotã€‚&lt;code&gt;proposeC&lt;/code&gt; æ˜¯åº”ç”¨å±‚ kv å‘ raftNode å‘é€è¯·æ±‚çš„ channelï¼Œ&lt;code&gt;commitC&lt;/code&gt; ä¸º raftNode é€šçŸ¥åº”ç”¨å±‚ kv å·²ç»æäº¤çš„è¯·æ±‚çš„ channelã€‚&lt;/p&gt;

&lt;p&gt;å…ˆçœ‹çœ‹ &lt;code&gt;newKVStore&lt;/code&gt; çš„å®ç°ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newKVStore(snapshotter *snap.Snapshotter, proposeC chan&amp;lt;- string, commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) *kvstore {
    s := &amp;amp;kvstore{proposeC: proposeC, kvStore: make(map[string]string), snapshotter: snapshotter}
    // replay log into key-value map
    s.readCommits(commitC, errorC)
    // read commits from raft into kvStore map until error
    go s.readCommits(commitC, errorC)
    return s
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;readCommits&lt;/code&gt; æ–¹æ³•ä» &lt;code&gt;commitC&lt;/code&gt; ä¸­è¯»å–å·²ç»æäº¤çš„è¯·æ±‚è¿›è¡Œå¤„ç†ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *kvstore) readCommits(commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) {
    for data := range commitC {
        var dataKv kv
        dec := gob.NewDecoder(bytes.NewBufferString(*data))  // decode 
        s.mu.Lock()
        s.kvStore[dataKv.Key] = dataKv.Val  // æ›´æ–° kv
        s.mu.Unlock()
    }
    if err, ok := &amp;lt;-errorC; ok {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;å†çœ‹çœ‹ &lt;code&gt;newRaftNode&lt;/code&gt; ï¼Œå…¶ä¼šè°ƒç”¨ &lt;code&gt;startRaft&lt;/code&gt; å¯åŠ¨åº•å±‚ raftï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) startRaft() {
    oldwal := wal.Exist(rc.waldir)
    rc.wal = rc.replayWAL()

    rpeers := make([]raft.Peer, len(rc.peers))
    for i := range rpeers {
        rpeers[i] = raft.Peer{ID: uint64(i + 1)}
    }
    c := &amp;amp;raft.Config{
        ID:              uint64(rc.id),
        ElectionTick:    10,
        HeartbeatTick:   1,
        Storage:         rc.raftStorage,
        MaxSizePerMsg:   1024 * 1024,
        MaxInflightMsgs: 256,
    }

    if oldwal {
        rc.node = raft.RestartNode(c)
    } else {
        startPeers := rpeers
        if rc.join {
            startPeers = nil
        }
        rc.node = raft.StartNode(c, startPeers)
    }

    go rc.serveRaft()  // ç›‘å¬ http 
    go rc.serveChannels()  // ç›‘å¬ proposeC channelï¼Œè¯»å–åº”ç”¨å±‚è¯·æ±‚ è¿›è¡Œå¤„ç†
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;serveChannels&lt;/code&gt; å°±åšäº†ä¸¤ä¸ªäº‹ï¼Œ1. å¦èµ·ä¸€ä¸ª goroutineï¼Œæ¥æ”¶ proposeC é‡Œå‘é€è‡ªåº”ç”¨å±‚çš„è¯·æ±‚ï¼Œé€šè¿‡ &lt;code&gt;Propose&lt;/code&gt; æ–¹æ³•äº¤ç»™åº•å±‚ raft å¤„ç†ï¼›2. è°ƒç”¨ &lt;code&gt;Ready&lt;/code&gt; æ–¹æ³•ï¼Œæ¥æ”¶å‘é€è‡ª raft çš„ ready å¯¹è±¡ï¼Œè°ƒç”¨ &lt;code&gt;publishEntries&lt;/code&gt; å°†å·²ç»æäº¤çš„ entries å‘é€åˆ° &lt;code&gt;commitC&lt;/code&gt; channelï¼Œäº¤ç”±åº”ç”¨å±‚å¤„ç†ï¼Œå†è°ƒç”¨ &lt;code&gt;Advance&lt;/code&gt; æ–¹æ³•é€šçŸ¥åº•å±‚ raft å‡†å¤‡å¥½æ¥æ”¶ä¸‹ä¸€ä¸ª ready å¯¹è±¡äº†ã€‚&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) serveChannels() {
    defer rc.wal.Close()

    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    // send proposals over raft
    go func() {
        var confChangeCount uint64 = 0

        for rc.proposeC != nil &amp;amp;&amp;amp; rc.confChangeC != nil {
            select {
            case prop, ok := &amp;lt;-rc.proposeC:
                if !ok {
                    rc.proposeC = nil
                } else {
                    // blocks until accepted by raft state machine
                    rc.node.Propose(context.TODO(), []byte(prop))  // è°ƒç”¨ Propose å‘é€ç»™ raft è¯·æ±‚
                }
            }
        }
        // client closed channel; shutdown raft if not already
        close(rc.stopc)
    }()

    // event loop on raft state machine updates
    for {
        select {
        case &amp;lt;-ticker.C:
            rc.node.Tick()

        // store raft entries to wal, then publish over commit channel
        case rd := &amp;lt;-rc.node.Ready():  // åº”ç”¨å±‚è°ƒç”¨ Ready() è·å– ready å¯¹è±¡
            if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
                rc.stop()
                return
            }
            rc.node.Advance()  // åº”ç”¨å±‚è°ƒç”¨ Advance() é€šçŸ¥ raft å·²ç»å¤„ç†å®Œ ready å¯¹è±¡ 

        case &amp;lt;-rc.stopc:
            rc.stop()
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;publishEntries&lt;/code&gt; å°† ready å¯¹è±¡é‡Œçš„ &lt;code&gt;CommittedEntries&lt;/code&gt; å‘é€åˆ° &lt;code&gt;commitC&lt;/code&gt;ï¼Œç”±åº”ç”¨å±‚ kv å¤„ç†ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// publishEntries writes committed log entries to commit channel and returns
// whether all entries could be published.
func (rc *raftNode) publishEntries(ents []raftpb.Entry) bool {
    for i := range ents {
        switch ents[i].Type {
        case raftpb.EntryNormal:
            if len(ents[i].Data) == 0 {
                // ignore empty messages
                break
            }
            s := string(ents[i].Data)
            select {
            case rc.commitC &amp;lt;- &amp;amp;s:  // å‘é€åˆ° commitC channel
            case &amp;lt;-rc.stopc:
                return false
            }
        }

        // after commit, update appliedIndex
        rc.appliedIndex = ents[i].Index

        // special nil commit to signal replay has finished
        if ents[i].Index == rc.lastIndex {
            select {
            case rc.commitC &amp;lt;- nil:
            case &amp;lt;-rc.stopc:
                return false
            }
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;æ•´ä½“æ¶æ„å¦‚ä¸‹ï¼ŒRaftNode çš„è§’è‰²ä¸ºåº”ç”¨å±‚å’Œåº•å±‚ raft çš„æ¡¥æ¢ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-1/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;å¯ä»¥çœ‹å‡ºï¼Œåº”ç”¨å±‚ä¸»è¦ç”¨åˆ° raft.Node çš„ &lt;code&gt;Propose&lt;/code&gt;ã€&lt;code&gt;Ready&lt;/code&gt;ã€&lt;code&gt;Advance&lt;/code&gt;ä¸‰ä¸ªæ¥å£ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Tue, 03 Jul 2018 13:21:23 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-1/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-1/</guid>
        
        
        <category>æºç é˜…è¯»</category>
        
      </item>
    
      <item>
        <title>Libco ä¹‹ coctx_swap</title>
        <description>&lt;h1&gt;å‰è¨€&lt;/h1&gt;

&lt;p&gt;åœ¨ä¹‹å‰çš„æ–‡ç« &lt;a href=&quot;http://masutangu.com/2016/10/learn-libco/&quot;&gt;ã€Šæµ…è¯» Libcoã€‹&lt;/a&gt; ç²—ç•¥çš„ä»‹ç»äº† libcoï¼Œè¿™ç¯‡æ–‡ç« åˆ™é‡ç‚¹å…³æ³¨åç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å®ç°ç»†èŠ‚ï¼ˆcoctx_swap.Sï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;é¦–å…ˆå›é¡¾ä¸‹å‡½æ•°è°ƒç”¨çš„ stack frame layoutï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/learn-libco-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;è°ƒç”¨å­å‡½æ•°æ—¶ï¼Œçˆ¶å‡½æ•°ä»å³åˆ°å·¦å°†å‡½æ•°å…¥æ ˆï¼Œæœ€åå°†è¿”å›åœ°å€å…¥æ ˆä¿å­˜åï¼Œè·³åˆ°å­å‡½æ•°çš„åœ°å€æ‰§è¡Œã€‚å­å‡½æ•°å‹æ ˆä¿å­˜çˆ¶å‡½æ•°çš„ %ebpï¼Œå¹¶å°† %ebp è®¾ç½®ä¸ºå½“å‰ %espã€‚å­å‡½æ•°é€šè¿‡ %ebp + 4 è¯»å–å‚æ•°1ï¼Œ%ebp + 8 è¯»å–å‚æ•°2ï¼Œä¾æ¬¡ç±»æ¨ã€‚&lt;/p&gt;

&lt;h1&gt;co_resume&lt;/h1&gt;

&lt;p&gt;åœ¨ä¹‹å‰çš„æ–‡ç« æåˆ°åç¨‹çš„æŒ‚èµ·å’Œæ¢å¤é€šè¿‡ co_resume æ¥å®ç°ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;static int CoRoutineFunc( stCoRoutine_t *co,void * )
{
    if( co-&amp;gt;pfn )
    {
        co-&amp;gt;pfn( co-&amp;gt;arg );
    }
    co-&amp;gt;cEnd = 1;

    stCoRoutineEnv_t *env = co-&amp;gt;env;

    co_yield_env( env );

    return 0;
}

void co_resume( stCoRoutine_t *co )   // æ¢å¤ co åç¨‹
{
    stCoRoutineEnv_t *env = co-&amp;gt;env;
    stCoRoutine_t *lpCurrRoutine = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 1 ];
    if( !co-&amp;gt;cStart )
    {
        coctx_make( &amp;amp;co-&amp;gt;ctx,(coctx_pfn_t)CoRoutineFunc,co,0 );
        co-&amp;gt;cStart = 1;
    }
    env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize++ ] = co;  // æ‰§è¡Œåç¨‹çš„æ—¶å€™å‹å…¥ pCallStack æ ˆä¸­
    coctx_swap( &amp;amp;(lpCurrRoutine-&amp;gt;ctx),&amp;amp;(co-&amp;gt;ctx) );  // æ¢å¤ co åç¨‹çš„ä¸Šä¸‹æ–‡
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;è¿™é‡Œ coctx_make å‡½æ•°åˆ›å»ºæ–°åç¨‹çš„ä¸Šä¸‹æ–‡ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;// å¯¹åº” CoRoutineFunc çš„ä¸¤ä¸ªå‚æ•°ï¼Œs1 å³ stCoRoutine_t *coï¼Œs2 å³ void*
struct coctx_param_t
{
    const void *s1;
    const void *s2;
};
struct coctx_t
{
#if defined(__i386__)
    void *regs[ 8 ];
#else
    void *regs[ 14 ];
#endif
    size_t ss_size;
    char *ss_sp;
};

int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 )
{
    // make room for coctx_param
    char *sp = ctx-&amp;gt;ss_sp + ctx-&amp;gt;ss_size - sizeof(coctx_param_t);
    sp = (char*)((unsigned long)sp &amp;amp; -16L); // 16å­—èŠ‚å¯¹é½

    coctx_param_t* param = (coctx_param_t*)sp ;
    param-&amp;gt;s1 = s;
    param-&amp;gt;s2 = s1;

    memset(ctx-&amp;gt;regs, 0, sizeof(ctx-&amp;gt;regs));

    ctx-&amp;gt;regs[ kESP ] = (char*)(sp) - sizeof(void*);  // 32ä½ä¸‹ regs[ kESP ] å³ regs[7]ï¼Œ(char*)(sp) - sizeof(void*) é¢„ç•™äº†è¿”å›åœ°å€çš„ç©ºé—´

    /*
     ss_sp æ˜¯åœ¨å †ä¸Šåˆ†é…çš„ï¼Œåœ°å€ä»ä½åˆ°é«˜å¢é•¿ï¼Œè€Œæ ˆæ˜¯ä»é«˜åˆ°ä½å¢é•¿ï¼Œè¿™é‡Œè¦è½¬ä¸‹

     é«˜åœ°å€  ------  &amp;lt;- ss_sp + ss_size 
           |pading| 
           |s2    |
           |s1    | 
            ------  &amp;lt;- sp
           |void* | è¿™ä¸ªè¿”å›åœ°å€åªæ˜¯é¢„ç•™ç©ºé—´ï¼Œä¸éœ€è¦å¡«ã€‚å› ä¸º CoRoutineFunc å‡½æ•°æ‰§è¡Œå®Œäº†è¡¨ç¤ºè¯¥åç¨‹å·²ç»è·‘å®Œï¼Œå°†å…¶ end æ ‡è®°ä½ç½®1ï¼ˆco-&amp;gt;cEnd = 1ï¼‰å¹¶è°ƒç”¨ co_yield_env åˆ‡å‡ºã€‚ä¸éœ€è¦å†å›åˆ°è¯¥åç¨‹æ¥æ‰€ä»¥ä¹Ÿä¸éœ€è¦è®°å½•è°ƒç”¨ CoRoutineFunc åçš„è¿”å›åœ°å€äº†
            ------  &amp;lt;- ctx-&amp;gt;regs[ kESP ] è¿™é‡Œä¸ºè¿”å›åœ°å€é¢„ç•™ç©ºé—´çš„ç›®çš„åœ¨äºï¼šå‚ç…§å‰è¨€ä¸­å‡½æ•°è°ƒç”¨çš„ stack frame layout å›¾ã€‚å‡½æ•°è°ƒç”¨å‹å…¥å‚æ•°åè¿˜éœ€è¦å‹å…¥è¿”å›åœ°å€ï¼Œè¿™æ ·æ‰èƒ½æŒ‰ç…§çº¦å®š ebp + 4 è¯»å–å‚æ•°1ï¼Œebp + 8 è¯»å–å‚æ•°2         
           |      |
     ä½åœ°å€  ------  &amp;lt;- ss_sp

                */

    ctx-&amp;gt;regs[ kEIP ] = (char*)pfn;  // 32ä½ä¸‹ regs[ kEIP ] å³ regs[0] ä¿å­˜ pfn çš„åœ°å€ ä¹Ÿå°±æ˜¯ CoRoutineFunc 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;co_swap è°ƒç”¨ coctx_swap æ¥æŒ‚èµ·å’Œä¿å­˜ curr åç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œæ¢å¤ pending åç¨‹çš„ä¸Šä¸‹æ–‡å¹¶åˆ‡æ¢æ‰§è¡Œæµç¨‹è‡³ pending åç¨‹ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void co_swap(stCoRoutine_t* curr, stCoRoutine_t* pending_co)
{
    //swap context
    coctx_swap(&amp;amp;(curr-&amp;gt;ctx),&amp;amp;(pending_co-&amp;gt;ctx) );

    //stack buffer may be overwrite, so get again;
    stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;è¿›å…¥ coctx_swap å‰ stack frame layout å¦‚ä¸‹å›¾ï¼š
&lt;img src=&quot;/assets/images/learn-libco-2/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;coctx_swap&lt;/h1&gt;

&lt;p&gt;ä¸‹é¢æ˜¯ coctx_swap çš„æ±‡ç¼–ä»£ç ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;leal 4(%esp), %eax     // ç”±ä¸Šå›¾å¯ä»¥çœ‹å‡ºæ­¤æ—¶ esp æŒ‡å‘è¿”å›åœ°å€ï¼Œesp + 4  å³è¿”å›åœ°å€ + 4ï¼ˆä¹ŸæŒ‡å‘ curr-&amp;gt;ctx çš„åœ°å€ï¼‰ï¼Œä¿å­˜åœ¨ %eax                                    
movl 4(%esp), %esp     // å°† esp ç§»åˆ°æŒ‡å‘ curr-&amp;gt;ctx    

/*
æ­¤æ—¶stack layoutå¦‚ä¸‹ï¼š
å¯¹åº”çš„ESPåœ°å€,æ­¤æ—¶ESPå·²ç»æŒ‡å‘äº†ç¬¬ä¸€ä¸ªå‚æ•° curr-&amp;gt;ctxï¼Œä¸º coctx_t ç»“æ„

| *ss_sp  |
| ss_size |
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
---------- &amp;lt;---ESP
*/   

leal 32(%esp), %esp    // å°†espä¸Šç§» 32 ä¸ªå­—èŠ‚

/*
| *ss_sp  |
| ss_size |
----------- &amp;lt;---ESP
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
*/     

pushl %eax         //  curr-&amp;gt;ctx-&amp;gt;regs[7] = %eax ä¿å­˜è¿”å›åœ°å€ + 4
pushl %ebp         //  curr-&amp;gt;ctx-&amp;gt;regs[6] = %ebp
pushl %esi         //  curr-&amp;gt;ctx-&amp;gt;regs[5] = %esi
pushl %edi         //  curr-&amp;gt;ctx-&amp;gt;regs[4] = %edi
pushl %edx         //  curr-&amp;gt;ctx-&amp;gt;regs[3] = %edx
pushl %ecx         //  curr-&amp;gt;ctx-&amp;gt;regs[2] = %ecx
pushl %ebx         //  curr-&amp;gt;ctx-&amp;gt;regs[1] = %ebx
pushl -4(%eax)     //  curr-&amp;gt;ctx-&amp;gt;regs[0] = è¿”å›åœ°å€ æ³¨ï¼š%eax - 4 = %old_esp å³è¿”å›åœ°å€

/*
ä¿å­˜å¯„å­˜å™¨åçš„ stack layout
| *ss_sp  |
| ss_size |
| regs[7] |  %eax
| regs[6] |  %ebp
| regs[5] |  %esi
| regs[4] |  %edi
| regs[3] |  %edx
| regs[2] |  %ecx
| regs[1] |  %ebx
| regs[0] |  è¿”å›åœ°å€
----------- &amp;lt;---ESP
*/     

movl 4(%eax), %esp // å°† esp ç§»åˆ° curr-&amp;gt;ctx å‘ä¸Šåç§» 4 ä¸ªå­—èŠ‚çš„åœ°å€ï¼Œä¹Ÿå³ pending_co-&amp;gt;ctx çš„åœ°å€ï¼Œ

/*
æ­¤æ—¶çš„ stack layoutï¼ˆpending_co-&amp;gt;ctxï¼‰
| *ss_sp  |
| ss_size |
| regs[7] | 
| regs[6] | 
| regs[5] |
| regs[4] |
| regs[3] | 
| regs[2] |
| regs[1] |
| regs[0] |
----------- &amp;lt;---ESP  æŒ‡å‘ç¬¬äºŒä¸ªå‚æ•° pending_co-&amp;gt;ctx-&amp;gt;regs[0]
*/     

// ä¾æ¬¡æ¢å¤å¯„å­˜å™¨
popl %eax  // pop from regs[0] regs[0] ä¿å­˜è¿”å›åœ°å€
popl %ebx  // pop from regs[1]
popl %ecx  // pop from regs[2]
popl %edx  // pop from regs[3]
popl %edi  // pop from regs[4]
popl %esi  // pop from regs[5]
popl %ebp  // pop from regs[6]
popl %esp  // pop from regs[7] æ­¤æ—¶ espæŒ‡å‘ regs[7] å³è¿”å›åœ°å€ + 4 çš„ä½ç½®


/*
æ­¤æ—¶çš„å †æ ˆ
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP
| è¿”å›åœ°å€ |

*/

// ä¸‹é¢è¿™è¡Œæœ‰ç‚¹ticky, esp æ­¤æ—¶æŒ‡å‘çš„æ˜¯è¿”å›åœ°å€ + 4çš„ä½ç½®ï¼Œæ‰€ä»¥è¿™é‡Œ push %eaxï¼Œå…¥æ ˆ %eax ä¸­ä¿å­˜çš„è¿”å›åœ°å€ï¼Œesp åˆšå¥½ä¹ŸæŒ‡å‘å­˜æ”¾è¯¥è¿”å›åœ°å€çš„ä½ç½®
pushl %eax

/*
æ­¤æ—¶çš„å †æ ˆ
|   s2    |
|   s1    |
|  void*  | 
| è¿”å›åœ°å€ |
---------- &amp;lt;- ESP
*/


xorl %eax, %eax

ret // ret æŒ‡ä»¤å¼¹å‡ºè¿”å›åœ°å€ï¼Œæ­¤æ—¶ %esp += 4 å¹¶è·³è½¬åˆ°è¯¥åœ°å€ç»§ç»­æ‰§è¡Œ

/*
æ­¤æ—¶çš„å †æ ˆ
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP / EBP
| è¿”å›åœ°å€ | å¼¹å‡ºè¿”å›åœ°å€

åœ¨ coctx_make çš„æƒ…å†µä¸‹ï¼Œå°†è·³è½¬åˆ° pfn æ‰§è¡Œï¼Œesp æ‰§è¡Œé¢„ç•™çš„è¿”å›åœ°å€ void*ï¼Œæ­¤æ—¶stack frame layout å’Œå¹³å°å‡½æ•°è°ƒç”¨ä¸€æ ·ï¼ŒåŒæ ·é€šè¿‡ %ebp + 4 è®¿é—®å‚æ•°1ï¼Œ%ebp + 8 è®¿é—®å‚æ•°2
*/

&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;å‚è€ƒæ–‡çŒ®&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://kaiyuan.me/2017/07/10/libco/&quot;&gt;ã€Šlibco åˆ†æ(ä¸Š)ï¼šåç¨‹çš„å®ç°ã€‹&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27409164&quot;&gt;ã€Šlibcoåç¨‹åº“ä¸Šä¸‹æ–‡åˆ‡æ¢åŸç†è¯¦è§£ã€‹&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27339191&quot;&gt;ã€Šx86-64 ä¸‹å‡½æ•°è°ƒç”¨åŠæ ˆå¸§åŸç†ã€‹&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rangechow.com/2016/09/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86.html&quot;&gt;ã€Šå‡½æ•°è°ƒç”¨åŸç†ã€‹&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 20:57:21 +0800</pubDate>
        <link>http://masutangu.com/2018/04/learn-libco-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/learn-libco-2/</guid>
        
        
        <category>æºç é˜…è¯»</category>
        
      </item>
    
      <item>
        <title>Programming Language Part B è¯¾ç¨‹ç¬”è®°</title>
        <description>&lt;p&gt;æœ¬æ–‡æ˜¯å­¦ä¹ &lt;a href=&quot;https://www.coursera.org/learn/programming-languages-part-b/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;è¯¾ç¨‹çš„å­¦ä¹ ç¬”è®°ï¼Œæ–‡ç« å†…å®¹åŠä»£ç å‡å–è‡ªè¯¾ç¨‹ææ–™ã€‚&lt;/p&gt;

&lt;h1&gt;Interpreter or Compiler&lt;/h1&gt;

&lt;p&gt;å®ç°ç¼–ç¨‹è¯­è¨€çš„ workflow å¦‚ä¸‹å›¾ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/programming-language-b/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Parser è¯»å–ç¨‹åºæ–‡æœ¬ï¼Œæ£€æŸ¥ syntaxï¼Œå¦‚æœè¯­æ³•æ­£ç¡®åˆ™è¾“å‡º ASTï¼ˆabstract syntax treeï¼‰ã€‚å¦‚æœè¯¥ç¼–ç¨‹è¯­è¨€æœ‰ type checkerï¼Œåˆ™å°† AST ä¸¢ç»™ type checker æ£€æŸ¥ï¼Œé€šè¿‡ type check åï¼Œå°±ç”± interpreter æˆ– compile æ¥è¿è¡Œç¨‹åºå¹¶è¾“å‡ºç»“æœã€‚&lt;/p&gt;

&lt;p&gt;åœ¨å®ç°ç¼–ç¨‹è¯­è¨€ B é€šå¸¸æœ‰ä¸‹é¢ä¸¤ç§åŠæ³•ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ä½¿ç”¨å¦ä¸€ç§ç¼–ç¨‹è¯­è¨€ A æ¥å®ç° interpreterï¼ˆå‘½åä¸º evaluator æˆ– executor æ›´æ°å½“ï¼‰ï¼Œè¾“å…¥ B è¯­è¨€å†™çš„ä»£ç ï¼Œè¾“å‡ºç»“æœ&lt;/li&gt;
&lt;li&gt;ä½¿ç”¨å¦ä¸€ç§ç¼–ç¨‹è¯­è¨€ A å®ç° compilerï¼ˆå‘½åä¸º translator æ›´æ°å½“ï¼‰ï¼Œå°† B ç¿»è¯‘æˆç¬¬ä¸‰ç§ç¼–ç¨‹è¯­è¨€ C&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Skipping Parsing&lt;/h1&gt;

&lt;p&gt;å¦‚æœåŸºäºç¼–ç¨‹è¯­è¨€ A æ¥å®ç°ç¼–ç¨‹è¯­è¨€ Bï¼Œå°±å¯ä»¥è·³è¿‡ parsing é˜¶æ®µï¼š&lt;strong&gt;Have B programmers write ASTs directly in PL A&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ML from a Racket perspective&lt;/h1&gt;

&lt;p&gt;ML is like a well-defined subset of Racket&lt;/p&gt;

&lt;h1&gt;Racket from an ML Perspective&lt;/h1&gt;

&lt;p&gt;One way to describe Racket is that &lt;strong&gt;it has â€œone big datatypeâ€&lt;/strong&gt;ï¼šall values have this type.&lt;/p&gt;

&lt;p&gt;æˆ‘çš„ç†è§£ç”±äº Racket æ˜¯ dynamic typingï¼Œæ‰€ä»¥ ML ç¨‹åºå‘˜çœ‹æ¥ Racket åªæœ‰ä¸€ä¸ªç±»å‹ï¼ˆè¿™æ · static type check éƒ½èƒ½æˆåŠŸï¼‰&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constructors are applied implicitly (&lt;strong&gt;values are tagged&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;42 is really like Int 42&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Primitives implicitly check tags and extract data, raising errors for wrong constructors&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun car v = case v of Pair(a,b) =&amp;gt; a | _ =&amp;gt; raise â€¦

fun pair? v = case v of Pair _ =&amp;gt; true | _ =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Weak Typing&lt;/h1&gt;

&lt;p&gt;There exist programs that, by definition, must pass static checking but then when run can &amp;quot;set the computer on fire&amp;quot;?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ease of language implementation: Checks left to the programmer&lt;/li&gt;
&lt;li&gt;Performance: Dynamic checks take time&lt;/li&gt;
&lt;li&gt;Lower level: Compiler does not insert information like array sizes, so it cannot do the checks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Racket is not weakly typed&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It just checks most things dynamically*&lt;/li&gt;
&lt;li&gt;Dynamic checking is the definition â€“ if the implementation can analyze the code to ensure some checks are not needed, then it can optimize them away&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 19:10:35 +0800</pubDate>
        <link>http://masutangu.com/2018/04/programing-language-b/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/programing-language-b/</guid>
        
        
        <category>è¯»ä¹¦ç¬”è®°</category>
        
      </item>
    
      <item>
        <title>The Part-Time Parliament è®ºæ–‡ç¬”è®°</title>
        <description>&lt;h1&gt;èƒŒæ™¯&lt;/h1&gt;

&lt;p&gt;Paxos å²›å…¼èŒè®®ä¼šç±»ä¼¼å®¹é”™å¼åˆ†å¸ƒå¼ç³»ç»Ÿé¢å¯¹çš„é—®é¢˜ï¼š&lt;strong&gt;è®®å‘˜å¯¹åº”åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„è¿›ç¨‹ï¼Œè®®å‘˜ç¼ºå¸­å¯¹åº”è¿›ç¨‹æŒ‚æ‰ã€‚Paxos è®¾è®¡çš„è®®ä¼šåè®®åœ¨è®®å‘˜ç»å¸¸ç¼ºå¸­çš„æƒ…å†µä¸‹å¯ä»¥ä¿è¯æ³•ä»¤çš„ä¸€è‡´æ€§ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;The Single-Decree Synod&lt;/h1&gt;

&lt;p&gt;å•ä¸€æ³•ä»¤çš„ç¥ä¼šåè®®çš„æ¼”åŒ–å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;é¦–å…ˆç”±å‡ ä¸ª&lt;strong&gt;èƒ½ä¿è¯ä¸€è‡´æ€§å’Œå…è®¸è¿›å±•æ€§çš„çº¦æŸ&lt;/strong&gt;æ¨å¯¼å‡º&lt;strong&gt;åˆçº§åè®®ï¼ˆpreliminary protocol)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preliminary protocol&lt;/strong&gt;çš„çº¦æŸç‰ˆæœ¬å¾—åˆ°&lt;strong&gt;åŸºæœ¬åè®®ï¼ˆbasic protocolï¼‰&lt;/strong&gt;ï¼Œå…¶æ»¡è¶³ä¸€è‡´æ€§ä½†ä¸ä¿è¯è¿›å±•æ€§&lt;/li&gt;
&lt;li&gt;è¿›ä¸€æ­¥çº¦æŸ&lt;strong&gt;basic protocol&lt;/strong&gt;å¾—åˆ°å®Œæ•´çš„ç¥ä¼šåè®®ï¼Œæ—¢æ»¡è¶³ä¸€è‡´æ€§åˆä¿è¯è¿›å±•æ€§&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ¥ä¸‹æ¥å››å°èŠ‚å…ˆè®²è§£ä¿è¯ä¸€è‡´æ€§çš„çº¦æŸï¼Œå†ä¾æ¬¡å¾—å‡º preliminary protocolã€basic protocol å’Œå®Œæ•´çš„ç¥ä¼šåè®®ã€‚&lt;/p&gt;

&lt;h2&gt;ä¸€è‡´æ€§çš„çº¦æŸæ¡ä»¶&lt;/h2&gt;

&lt;p&gt;ç¥ä¼šæ³•ä»¤é€šè¿‡å¤šè½®å¸¦ç¼–å·çš„&lt;strong&gt;è¡¨å†³ï¼ˆballotï¼‰&lt;/strong&gt;é€‰å‡ºã€‚æ¯ä¸€è½® ballot æ˜¯å¯¹å•ä¸€æ³•ä»¤çš„æŠ•ç¥¨ã€‚æ¯è½® ballot ç‰§å¸ˆåªèƒ½é€‰æ‹©æŠ•ç¥¨ï¼ˆè¡¨ç¤ºèµæˆï¼‰æˆ–ä¸æŠ•ç¥¨ï¼ˆè¡¨ç¤ºä¸èµæˆï¼‰ã€‚æ¯è½® ballot éƒ½å…³è”ä¸€ä¸ª&lt;strong&gt;æ³•å®šäººæ•°é›†ï¼ˆquorumï¼‰&lt;/strong&gt;çš„ç‰§å¸ˆé›†åˆã€‚åªæœ‰å½“ quorum ä¸­çš„æ¯ä¸€ä½ç‰§å¸ˆéƒ½æŠ•ç¥¨ï¼Œè¿™è½® ballot æ‰ç®—æˆåŠŸã€‚ä¸€è½® ballot B åŒ…æ‹¬ä»¥ä¸‹å››ä¸ªå…ƒç´ ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B(dec): è¢«æŠ•ç¥¨çš„æ³•ä»¤&lt;/li&gt;
&lt;li&gt;B(qrm): è¯¥è½® ballot çš„ quorum&lt;/li&gt;
&lt;li&gt;B(vot): æŠ•ç¥¨çš„ç‰§å¸ˆé›†åˆ&lt;/li&gt;
&lt;li&gt;B(bal): ballot çš„ç¼–å·&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;å½“ä¸”ä»…å½“ B(qrm) âŠ† B(vot) æ—¶ï¼Œè¿™è½® ballot æ‰ç®—æˆåŠŸã€‚&lt;strong&gt;B(bal) å€¼çš„å¤§å°å’Œè¿›è¡Œ ballot çš„é¡ºåºæ— å…³ï¼ŒB(bal) æ¯”è¾ƒå¤§çš„ ballot æœ‰å¯èƒ½åœ¨ B(bal) æ¯”è¾ƒå°çš„ ballot ä¹‹å‰å‘ç”Ÿã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Paxos æ•°å­¦å®¶åœ¨ç”±å¤šè½® ballot ç»„æˆçš„é›†åˆ ğœ· ä¸Šå®šä¹‰äº†ä¸‰ä¸ªçº¦æŸæ¡ä»¶ï¼Œå¦‚æœé›†åˆä¸­çš„ ballot éƒ½æ»¡è¶³è¿™äº›æ¡ä»¶ï¼Œåˆ™å¯ä»¥ä¿è¯ä¸€è‡´æ€§ä¼šï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(ğœ·): ğœ· ä¸­çš„æ¯ä¸€è½® ballot éƒ½æ‹¥æœ‰å”¯ä¸€çš„ç¼–å·&lt;/li&gt;
&lt;li&gt;B2(ğœ·): ğœ· ä¸­ä»»æ„ä¸¤è½® ballot çš„ quorum è‡³å°‘æœ‰ä¸€ä¸ªå…¬å…±æˆå‘˜&lt;/li&gt;
&lt;li&gt;B3(ğœ·): ğœ· ä¸­ä»»æ„ä¸€è½® ballot Bï¼Œå¦‚æœ B(qrm) ä¸­ä»»ä½•ä¸€ä¸ªç‰§å¸ˆåœ¨ ğœ· ä¸­æ›´æ—©çš„ ballot ä¸­æŠ•è¿‡ç¥¨ï¼Œåˆ™ B(dec) ä¸æ‰€æœ‰æ›´æ—©çš„ ballots ä¸­æœ€åé‚£è½® ballot çš„æ³•ä»¤ç›¸åŒ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ä¸‹å›¾æ˜¯å¯¹ B3(ğœ·) çš„å›¾è§£ã€‚äº”è½® ballot ç»„æˆé›†åˆ ğœ·ï¼ŒAã€Bã€Î“ã€âˆ† å’Œ E è¡¨ç¤ºäº”ä½ç‰§å¸ˆï¼Œæ–¹æ¡†åœˆèµ·çš„è¡¨ç¤ºæŠ•ç¥¨çš„ç‰§å¸ˆã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ç¼–å· 2 æ˜¯æœ€æ—©çš„ä¸€è½® ballotï¼Œå› æ­¤æ˜¾è€Œæ˜“è§ä¸‰ä¸ªæ¡ä»¶éƒ½æ»¡è¶³ï¼ˆæ²¡æœ‰æ¯”ä»–æ›´æ—©çš„ ballotäº†ï¼‰&lt;/li&gt;
&lt;li&gt;ç¼–å· 5 çš„ ballotï¼Œå››ä½ quorum éƒ½æ²¡æœ‰åœ¨æ›´æ—©çš„ ballot ä¸­æŠ•è¿‡ç¥¨ï¼Œå› æ­¤ä¸‰ä¸ªæ¡ä»¶ä¹Ÿæ»¡è¶³&lt;/li&gt;
&lt;li&gt;ç¼–å· 14 çš„ ballot ä¸­ï¼Œâˆ† æ˜¯ quorum ä¸­å”¯ä¸€ä¸€ä½åœ¨æ›´æ—©çš„ ballot ä¸­æŠ•è¿‡ç¥¨çš„ï¼Œå› æ­¤è¿™ä¸€è½®çš„æ³•ä»¤å¿…é¡»å’Œç¼–å·ä¸º 2 çš„ ballot ä¸€è‡´ï¼Œéƒ½ä¸º ğœ¶&lt;/li&gt;
&lt;li&gt;ç¼–å· 27 æ˜¯ä¸€è½®æˆåŠŸçš„ ballotï¼ŒAã€Î“ å’Œ âˆ† ä¸ºè¯¥è½®çš„ quorum æˆå‘˜ã€‚Î“ åœ¨ç¼–å· 5 çš„ ballot ä¸­æŠ•è¿‡ç¥¨ï¼Œâˆ† åœ¨ç¼–å·ä¸º 2 çš„ ballot ä¸­æŠ•è¿‡ç¥¨ï¼Œæ ¹æ® B3(ğœ·)ï¼Œè¿™ä¸€è½®çš„æ³•ä»¤å¿…é¡»å’Œç¼–å· 5 çš„æ³•ä»¤ä¸€è‡´ï¼ˆç¼–å· 5 æ¯”ç¼–å· 2 æ›´æ–°ï¼‰&lt;/li&gt;
&lt;li&gt;ç¼–å· 29 çš„ quorum æˆå‘˜ä¸º Bã€Î“ å’Œ âˆ†ã€‚B åœ¨ç¼–å· 14 çš„ ballot æŠ•è¿‡ç¥¨ï¼ŒÎ“ åœ¨ç¼–å· 5 å’Œ 27 çš„ ballots éƒ½æŠ•è¿‡ç¥¨ï¼Œâˆ† åœ¨ç¼–å·ä¸º 2 å’Œ 27 çš„ballots ä¹ŸæŠ•è¿‡ç¥¨ï¼Œè¿™äº› ballots ä¸­æœ€æ–°çš„ç¼–å·ä¸º 27ï¼Œå› æ­¤è¿™è½® ballot çš„æ³•ä»¤å¿…é¡»å’Œç¼–å· 27 çš„æ³•ä»¤ä¸€è‡´&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ä¸‹é¢ç»™å‡º B1(ğœ·) B2(ğœ·) B3(ğœ·) çš„æ•°å­¦å®šä¹‰ï¼š&lt;/p&gt;

&lt;p&gt;ç¬¦å· v è¡¨ç¤ºä¸€æ¬¡æŠ•ç¥¨ï¼Œå…¶ä¸­ v(pst) è¡¨ç¤ºæŠ•ç¥¨çš„ç‰§å¸ˆï¼Œv(bal) è¡¨ç¤ºæŠ•ç¥¨çš„ç¼–å·ï¼Œv(dec) è¡¨ç¤ºæŠ•ç¥¨çš„æ³•ä»¤ã€‚é›†åˆ Votes(ğœ·) è¡¨ç¤ºæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æŠ•ç¥¨ v çš„é›†åˆï¼šv(pst) âˆˆ B(vot)ï¼Œv(bal) = B(bal)ï¼Œv(dec) = B(dec)ï¼ŒB âˆˆ ğœ·ã€‚å®šä¹‰ p ä¸ºç‰§å¸ˆï¼Œb ä¸º ballot ç¼–å·ï¼Œåˆ™ MaxVote(b, p, ğœ·) è¡¨ç¤ºé›†åˆ &lt;strong&gt;{ v âˆˆ Votes(B): (v(pst) = p) âˆ§ (v(bal) &amp;lt; b) } âˆª { null(p) }&lt;/strong&gt; ä¸­ ballot æœ€å¤§çš„æŠ•ç¥¨ã€‚&lt;em&gt;æ³¨ï¼šnull(p) è¡¨ç¤º null æŠ•ç¥¨ï¼Œå³ v(bal) ä¸º-âˆ, v(dec) ä¸º BLANK ä¸” v(pst) = p&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;å¯¹ä»»æ„éç©ºçš„ç‰§å¸ˆé›†åˆ Qï¼ŒMaxVote(b, Q, ğœ·) å®šä¹‰ä¸º Q ä¸­çš„æ‰€æœ‰ç‰§å¸ˆ p çš„ MaxVote(b, p, ğœ·) çš„æœ€å¤§å€¼ã€‚&lt;em&gt;æ³¨ï¼šç¿»è¯‘å¾—ä¸å¤ªå¦¥å½“ï¼ŒåŸæ–‡ï¼šFor any nonempty set Q of priests, MaxVote(b, Q, B) was defined to equal the maximum of all votes MaxVote(b, p, B) with p in Q.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;B1(ğœ·) B2(ğœ·) B3(ğœ·) çš„æ•°å­¦å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(ğœ·) â‰œ âˆ€B, B&amp;#39; âˆˆ ğœ· : (B â‰  B&amp;#39;) â‡’ (B(bal) â‰  B&amp;#39;(bal))&lt;/li&gt;
&lt;li&gt;B2(ğœ·) â‰œ âˆ€B, B&amp;#39; âˆˆ ğœ· : B(qrm) âˆ© B&amp;#39;(qrm) â‰  âˆ…&lt;/li&gt;
&lt;li&gt;B3(ğœ·) â‰œ âˆ€B âˆˆ ğœ· : (MaxVote(B(bal) , B(qrm), ğœ·)bal â‰  âˆ’âˆ) â‡’ (B(dec) = MaxVote(B(bal) , B(qrm) , ğœ·)dec)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;å¼•ç†ï¼šå¦‚æœæ»¡è¶³ B1(ğœ·) B2(ğœ·) B3(ğœ·)ï¼Œåˆ™ ((B(qrm) âŠ† B(vot)) âˆ§ (B&amp;#39;(bal) &amp;gt; B(bal))) â‡’ (B(dec) = B&amp;#39;(dec))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;å¼•ç†è¯æ˜å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;å¯¹ ğœ· ä¸­ä»»æ„ ballot Bï¼Œå®šä¹‰ Î¨(B, ğœ·) è¡¨ç¤º ğœ· ä¸­æ‰€æœ‰ç¼–å·å¤§äº B(bal) ä¸”æ³•ä»¤ä¸ç­‰äº B(dec) çš„ ballot çš„é›†åˆï¼š&lt;strong&gt;Î¨(B, ğœ·) â‰œ {B&amp;#39; âˆˆ ğœ· : (B&amp;#39;(bal) &amp;gt; B(bal) âˆ§ (B&amp;#39;(dec) â‰  B(dec))}&lt;/strong&gt;ã€‚å¦‚æœè¯æ˜ B(qrm) âŠ† B(vot) åˆ™ Î¨(B, ğœ·) ä¸ºç©ºï¼Œå¼•ç†å³æˆç«‹ã€‚ä¸‹é¢æ˜¯åè¯æ³•ï¼Œå‡è®¾å­˜åœ¨ B æ»¡è¶³ B(qrm) âŠ† B(vot) ä¸” Î¨(B, ğœ·) ä¸ä¸ºç©ºï¼Œä¸‹é¢æ¨å¯¼å¾—å‡ºçŸ›ç›¾çš„ç»“è®ºï¼š&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;é€‰æ‹© C âˆˆ Î¨(B, B) æ»¡è¶³ C(bal) = min{ B&amp;#39;(bal) : B&amp;#39; âˆˆ Î¨(B, ğœ·)}&lt;/li&gt;
&lt;li&gt;C(bal) &amp;gt; B(bal)ï¼šç”± 1 å’Œ Î¨(B, ğœ·) çš„å®šä¹‰å¾—å‡º&lt;/li&gt;
&lt;li&gt;B(vot) âˆ© C(qrm) â‰  âˆ…ï¼šç”± B2(ğœ·) å’Œ B(qrm) âŠ† B(vot) å¾—å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·)bal â‰¥ B(bal)ï¼šç”± 2ã€3 å’Œ MaxVote çš„å®šä¹‰å¾—å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·) âˆˆ Votes(B)ï¼šç”± 4 çŸ¥é“ MaxVote(C(bal), C(qrm) , ğœ·) ä¸æ˜¯ null æŠ•ç¥¨&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·)dec = C(dec)ï¼šç”± 5 å’Œ B3(ğœ·) å¾—å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·)dec â‰  B(dec)ï¼šç”± 6ã€1 å’Œ Î¨(B, ğœ·) çš„å®šä¹‰å¾—å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·)bal &amp;gt; B(bal)ï¼šç”± 4 7 å’Œ B1(ğœ·) çš„å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·) âˆˆ Votes(Î¨(B, ğœ·))ï¼šç”± 7 8 å’Œ Î¨(B, ğœ·) çš„å®šä¹‰å¾—å‡º&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), ğœ·)bal &amp;lt; C(bal)ï¼šç”± MaxVote(C(bal), C(qrm), ğœ·) çš„å®šä¹‰å¾—å‡º&lt;/li&gt;
&lt;li&gt;ç”± 9 10 1 å¾—å‡ºçŸ›ç›¾ï¼Œå› ä¸º 1 ä¸­å®šä¹‰äº† C(bal) æ˜¯ Î¨(B, ğœ·) ä¸­ç¼–å·æœ€å°çš„ï¼Œç”± 9 çŸ¥é“ MaxVote(C(bal), C(qrm), ğœ·) å±äº Votes(Î¨(B, ğœ·))ï¼Œé‚£ä¹ˆ MaxVote(C(bal), C(qrm), ğœ·) å¿…é¡»å¤§äºç­‰äº C(bal)ï¼Œè¿™ä¸ 10 å¾—åˆ°çš„ MaxVote(C(bal), C(qrm), ğœ·)bal &amp;lt; C(bal) çŸ›ç›¾&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ç”±å¼•ç†å¾—å‡ºï¼Œå¦‚æœæ»¡è¶³ B1(ğœ·) B2(ğœ·) B3(ğœ·)ï¼Œåˆ™ä»»æ„ä¸¤è½®æˆåŠŸçš„ ballots éƒ½æ˜¯ç›¸åŒçš„æ³•ä»¤ï¼Œæ•°å­¦è¡¨ç¤ºï¼š&lt;strong&gt;((B(qrm) âŠ† B(vot)) âˆ§ (B&amp;#39;(qrm) âŠ† B&amp;#39;(vot))) â‡’ (B&amp;#39;dec = Bdec)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;The Preliminary Protocol&lt;/h2&gt;

&lt;p&gt;ä¸ºäº†éµå®ˆ B3(ğœ·)ï¼Œç‰§å¸ˆåœ¨å‘èµ·è¡¨å†³å‰éœ€è¦å…ˆç¡®å®š MaxVote(b, Q, ğœ·)decï¼Œå› æ­¤éœ€è¦ç¡®å®š Q ä¸­çš„æ¯ä¸€ä¸ª p çš„ MaxVote(b, q, ğœ·)decã€‚Preliminary protocol çš„å‰ä¸¤æ­¥å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;(1) ç‰§å¸ˆ p é€‰æ‹©æ–°çš„ ballot number bï¼Œå‘é€ä¸€æ¡ NextBallot(b) æ¶ˆæ¯ç»™æŸäº›ç‰§å¸ˆ&lt;/p&gt;

&lt;p&gt;(2) ç‰§å¸ˆ q æ”¶åˆ° NextBallot(b) æ¶ˆæ¯åï¼Œå‘é€ LastVote(b, v) æ¶ˆæ¯ç»™ pï¼Œv ä¸º MaxVote(b, q, ğœ·)&lt;/p&gt;

&lt;p&gt;å‘é€å®Œ LastVote(b, v)ï¼Œ&lt;strong&gt;q æ‰¿è¯ºä¸å†ç»™ç¼–å·åœ¨ [v(bal), b] åŒºé—´çš„è¡¨å†³æŠ•ç¥¨ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;æ³¨ï¼šè¿™ä¸ªæ‰¿è¯ºæ˜¯ä¸ºäº†è§£å†³ä¹±åºçš„é—®é¢˜ï¼Œ ballot ç¼–å·å¤§çš„æŠ•ç¥¨å‘ç”Ÿåœ¨ç¼–å·å°çš„ä¹‹å‰æ—¶ï¼Œå¦‚ä¸‹å›¾ï¼ŒB å’Œ C æŠ•ç¥¨çš„æ³•ä»¤å‡ºç°äº†ä¸ä¸€è‡´ï¼»å‚è€ƒè‡ª&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21438357&quot;&gt;Paxosç†è®ºä»‹ç»(1): æœ´ç´ Paxosç®—æ³•ç†è®ºæ¨å¯¼ä¸è¯æ˜&lt;/a&gt;ï¼½ï¼š&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;æ¥ä¸‹æ¥ä¸¤ä¸ªæ­¥éª¤æ˜¯ï¼š&lt;/p&gt;

&lt;p&gt;(3) åœ¨æ”¶åˆ° majority çš„ LastVote(b, v) ä¹‹åï¼Œp å‘èµ·ä¸€è½®ç¼–å·ä¸º bï¼Œquorum ä¸º Q ä¸”æ³•ä»¤ä¸º dï¼ˆd éœ€è¦æ»¡è¶³B3(ğœ·)ï¼‰çš„è¡¨å†³ï¼Œç»™ Q ä¸­æ¯ä¸€ä¸ªç‰§å¸ˆå‘é€ BeginBallot(b, d) æ¶ˆæ¯&lt;/p&gt;

&lt;p&gt;(4) åœ¨æ”¶åˆ° BeginBallot(b, d) æ¶ˆæ¯åï¼Œq å†³å®šæ˜¯å¦æŠ•ç¥¨ï¼Œå¦‚æœå¯ä»¥æŠ•ç¥¨ï¼ˆä¸è¿èƒŒä¸Šé¢çš„æ‰¿è¯ºï¼‰ï¼Œåˆ™å‘é€ Voted(b, q) æ¶ˆæ¯ç»™ p&lt;/p&gt;

&lt;p&gt;æ­¥éª¤ 3 å°†è¡¨å†³ B åŠ å…¥åˆ°é›†åˆ ğœ· ä¸­ï¼Œå…¶ä¸­ B(bal) = bï¼ŒB(qrm) = Qï¼ŒB(vot) = âˆ…ã€‚æ­¥éª¤ 4 ä¸­ï¼Œå¦‚æœç‰§å¸ˆ q æŠ•ç¥¨äº†ï¼Œåˆ™å°† q åŠ å…¥ B(vot) ä¸­ã€‚&lt;/p&gt;

&lt;p&gt;åè®®çš„å‰©ä½™æ­¥éª¤å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;(5) å¦‚æœ p æ”¶åˆ°äº† Q ä¸­æ¯ä¸€ä¸ª q çš„ Voted(b, q) æ¶ˆæ¯ï¼Œé‚£ä¹ˆ p åœ¨å¾‹ç°¿ä¸Šè®°å½•ä¸‹æ³•ä»¤ dï¼Œå¹¶ä¸”å‘é€ Success(d) ç»™æ¯ä¸€ä¸ªç‰§å¸ˆ&lt;/p&gt;

&lt;p&gt;(6) ç‰§å¸ˆ q æ”¶åˆ° Success(d) æ¶ˆæ¯åï¼Œå°†æ³•ä»¤ d è®°å½•åœ¨è‡ªå·±çš„å¾‹ç°¿ä¸Š&lt;/p&gt;

&lt;h2&gt;The Basic Protocol&lt;/h2&gt;

&lt;p&gt;åœ¨ preliminary protocol ä¸­ï¼Œæ¯ä¸€ä¸ªç‰§å¸ˆéƒ½å¿…é¡»è®°å½• &lt;strong&gt;(i) ä»–å‘èµ·çš„æ¯ä¸€ä¸ªballot number (ii) ä»–æŠ•è¿‡çš„æ¯ä¸€æ¬¡ç¥¨ (iii) ä»–å‘é€è¿‡çš„æ¯ä¸€ä¸ª LastVote æ¶ˆæ¯&lt;/strong&gt;ã€‚è¦è®°å½•è¿™ä¹ˆå¤šä¿¡æ¯æ˜¯éå¸¸å›°éš¾çš„ï¼Œå› æ­¤ Paxos äººå¯¹ preliminary protocol åšäº†è¿›ä¸€æ­¥çº¦æŸï¼Œå¾—åˆ°æ›´å®ç”¨çš„ basic protocolï¼Œæ¯ä¸ªç‰§å¸ˆåªéœ€è¦åœ¨å¾‹ç°¿ä¸Šè®°å½•ä¸‹é¢ä¸‰ä¸ªä¿¡æ¯ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lastTried[p]&lt;/strong&gt;ï¼šp å‘èµ·çš„æœ€åä¸€ä¸ªè¡¨å†³çš„ç¼–å·&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prevVote[p]&lt;/strong&gt;ï¼šp æŠ•è¿‡çš„æ‰€æœ‰è¡¨å†³ä¸­ç¼–å·æœ€å¤§çš„é‚£æ¬¡æŠ•ç¥¨&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextBal[p]&lt;/strong&gt;ï¼šp å‘è¿‡çš„æ‰€æœ‰ LastVote(b, v) æ¶ˆæ¯ä¸­ b çš„æœ€å¤§å€¼&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preliminary protocol å…è®¸ç‰§å¸ˆå¹¶è¡Œç®¡ç†ä»»æ„æ•°é‡çš„è¡¨å†³ï¼Œbasic protocol ä¸­ç‰§å¸ˆåœ¨ä¸€ä¸ªæ—¶é—´å†…åªç®¡ç†ä¸€ä¸ªè¡¨å†³ï¼Œç¼–å·ä¸º lastTried[p]ï¼Œå¿½ç•¥å’Œä¹‹å‰å‘èµ·çš„è¡¨å†³ç›¸å…³çš„æ¶ˆæ¯ã€‚Basic protocol ä¸­å¯¹ LastVote åšäº†æ›´å¼ºçš„æ‰¿è¯ºï¼š&lt;strong&gt;ä¸å†å¯¹ç¼–å·å°äº b çš„è¡¨å†³è¿›è¡ŒæŠ•ç¥¨ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basic protocol æ­¥éª¤å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;(1) ç‰§å¸ˆ p é€‰æ‹©æ–°çš„ ballot number bï¼Œå¿…é¡»å¤§äº lastTried[p]ï¼Œå¹¶æ›´æ–° lastTried[p] ç½®ä¸º bï¼Œç„¶åå‘é€ NextBallot(b) æ¶ˆæ¯ç»™æŸäº›ç‰§å¸ˆ&lt;/p&gt;

&lt;p&gt;(2) ç‰§å¸ˆ q æ”¶åˆ° NextBallot(b) æ¶ˆæ¯ï¼Œå¦‚æœ b å¤§äº nextBal(q)ï¼Œåˆ™æ›´æ–° nextBal(q) ç½®ä¸º b å¹¶å‘é€ LastVote(b, v) æ¶ˆæ¯ç»™ pï¼Œv å³ prevVote[q]ã€‚å¦‚æœ b å°äºç­‰äº nextBal(q) åˆ™å¿½ç•¥è¯¥ NextBallot æ¶ˆæ¯ã€‚&lt;/p&gt;

&lt;p&gt;(3) åœ¨æ”¶åˆ° majority çš„ LastVote(b, v) æ¶ˆæ¯åï¼Œå¦‚æœ b ç­‰äº lastTried[p]ï¼Œåˆ™ p å‘èµ·ä¸€è½®æ–°çš„è¡¨å†³ï¼ŒæŒ‡å®šç¼–å·ä¸º bï¼Œquorum ä¸º Qï¼Œæ³•ä»¤ä¸º dï¼Œd éœ€è¦æ»¡è¶³ B3(ğœ·)ã€‚p å‘é€ BeginBallot(b, d) æ¶ˆæ¯ç»™ Q ä¸­æ‰€æœ‰ç‰§å¸ˆã€‚&lt;/p&gt;

&lt;p&gt;(4) åœ¨æ”¶åˆ° BeginBallot(b, d) æ¶ˆæ¯åï¼Œå¦‚æœ b ç­‰äº nextBal[q]ï¼Œç‰§å¸ˆ q æŠ•ç¥¨ï¼Œå¹¶å°† prevVote[q] è®¾ç½®ä¸ºæœ¬æ¬¡æŠ•ç¥¨ï¼Œç„¶åå‘é€ Voted(b, q) æ¶ˆæ¯ç»™ pã€‚å¦‚æœ b ä¸ç­‰äº nextBal[q]ï¼Œåˆ™å¿½ç•¥è¯¥ BeginBallot æ¶ˆæ¯&lt;/p&gt;

&lt;p&gt;(5) å¦‚æœ p æ”¶åˆ° Q ä¸­æ‰€æœ‰ç‰§å¸ˆçš„ Voted(b, q) æ¶ˆæ¯ï¼Œå¹¶ä¸” b ç­‰äº lastTried[p]ï¼Œä»–åœ¨å¾‹ç°¿ä¸Šè®°å½•ä¸‹æ³•ä»¤ dï¼Œå¹¶å‘é€ Success(d) æ¶ˆæ¯ç»™æ‰€æœ‰çš„ç‰§å¸ˆã€‚&lt;/p&gt;

&lt;p&gt;(6) åœ¨æ”¶åˆ° Success(d) æ¶ˆæ¯åï¼Œç‰§å¸ˆåœ¨å¾‹ç°¿ä¸Šè®°å½•ä¸‹æ³•ä»¤ d&lt;/p&gt;

&lt;p&gt;Basic protocol æ˜¯ preliminary protocol çš„çº¦æŸç‰ˆæœ¬ï¼Œpreliminary protocol æ»¡è¶³ä¸€è‡´æ€§çš„æ¡ä»¶ï¼Œé‚£ä¹ˆ basic protocol ä¹Ÿä¸€å®šæ»¡è¶³ã€‚ä¸è¿‡å’Œ preliminary protocol ä¸€æ ·ï¼Œbasic protocol ä¹Ÿæ²¡è¦æ±‚å¿…é¡»æ‰§è¡ŒæŸä¸ªæ“ä½œï¼Œå› æ­¤åŒæ ·æ²¡æœ‰è§£å†³è¿›å±•æ€§çš„é—®é¢˜ã€‚&lt;/p&gt;

&lt;h2&gt;The Complete Synod Protocol&lt;/h2&gt;

&lt;p&gt;ä¸ºäº†ä¿è¯è¿›å±•æ€§ï¼Œ&lt;strong&gt;å…³é”®åœ¨äºå†³å®šç‰§å¸ˆä»€ä¹ˆæ—¶å€™åº”è¯¥å‘èµ·è¡¨å†³&lt;/strong&gt;ã€‚æ°¸è¿œä¸å‘èµ·è¡¨å†³å’Œå¤ªé¢‘ç¹çš„å‘èµ·è¡¨å†³éƒ½ä¼šå½±å“è¿›å±•æ€§ã€‚å®Œæ•´çš„ç¥ä¼šåè®®åœ¨ basic protocol çš„åŸºç¡€ä¸Šæ–°å¢ä¸€ä¸ªæµç¨‹æ¥é€‰æ‹©å”¯ä¸€çš„ç‰§å¸ˆ--æ€»ç»Ÿï¼Œæ¥å‘èµ·è¡¨å†³ã€‚è¿™éƒ¨åˆ†ç»†èŠ‚å‚ç…§è®ºæ–‡çš„ 2.4 èŠ‚ã€‚&lt;/p&gt;

&lt;h1&gt;The Multi-Decree Parliament&lt;/h1&gt;

&lt;h2&gt;The Protocol&lt;/h2&gt;

&lt;p&gt;Paxos è®®ä¼šéœ€è¦é€šè¿‡ä¸€ç³»åˆ—æ³•ä»¤è€Œä¸ä»…ä»…å•ä¸€ä¸€ä¸ªæ³•ä»¤ã€‚æ³•ä»¤æè®®ç»™æ€»ç»Ÿï¼Œç”±æ€»ç»Ÿèµ‹äºˆ ballot number å¹¶å°è¯•é€šè¿‡å®ƒã€‚åè®®å¯¹æ¯ä¸ªæ³•ä»¤ä½¿ç”¨ä¸åŒå®ä¾‹çš„ Complete Synod Protocolï¼Œä½†è¿™ç³»åˆ—å®ä¾‹åªéœ€è¦ä¸€ä½æ€»ç»Ÿæ¥è´Ÿè´£ï¼Œå¹¶ä¸”ç¥ä¼šåè®®çš„å‰ä¸¤æ­¥åªéœ€è¦æ‰§è¡Œä¸€æ¬¡ã€‚&lt;/p&gt;

&lt;p&gt;åœ¨ç¥ä¼šåè®®ä¸­ï¼Œæ€»ç»Ÿåœ¨ç¬¬ä¸‰æ­¥ä¹‹å‰ä¸ä¼šé€‰æ‹©æ³•ä»¤å’Œ quorumï¼Œå› æ­¤æ€»ç»Ÿå¯ä»¥ä¸ºæ‰€æœ‰å®ä¾‹å‘é€ä¸€æ¡ NextBallot(b) æ¶ˆæ¯ï¼Œè®®å‘˜å›å¤ä¸€æ¡ LastVote æ¶ˆæ¯ï¼Œè§„åˆ™å’Œå•ä¸€æ³•ä»¤çš„åè®®ç›¸åŒï¼Œåªæ˜¯æŠŠæ‰€æœ‰å¾…è¡¨å†³çš„å®ä¾‹ä¿¡æ¯åŒ…å«åœ¨ä¸€æ¡ LastVote ä¿¡æ¯é‡Œã€‚&lt;/p&gt;

&lt;p&gt;å½“æ€»ç»Ÿæ”¶åˆ° majority çš„å›å¤åï¼Œå°±ä¸ºæ¯ä¸ªå¾…è¡¨å†³çš„å®ä¾‹æ‰§è¡Œ Complete Synod Protocol çš„ç¬¬ä¸‰æ­¥ã€‚&lt;/p&gt;

&lt;p&gt;å› æ­¤ Paxon çš„è®®ä¼šåè®®å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;å·²ç»çŸ¥é“ç»“æœçš„è¡¨å†³ä¸å†éœ€è¦å†èµ°ä¸€é Complete Synod Protocol çš„æµç¨‹ï¼Œå› æ­¤å½“æ–°é€‰ä¸¾çš„æ€»ç»Ÿ p åœ¨å¾‹ç°¿ä¸Šå·²ç»è®°å½•æœ‰ç¼–å·å°äºç­‰äº n çš„æ³•ä»¤ï¼Œé‚£ä»–å°†å‘é€ NextBallot(b, n) ä»£æ›¿ä¹‹å‰çš„ NextBallot(b) æ¶ˆæ¯ã€‚è®®å‘˜æ”¶åˆ° NextBallot æ¶ˆæ¯åï¼Œå°†ä»–å¾‹ç°¿ä¸Šæ‰€æœ‰ç¼–å·å¤§äº n çš„æ³•ä»¤è¿”å›ç»™ pï¼Œå¹¶ä¸”å‘Šè¯‰ p ä»–ç¼ºå¤±çš„ç¼–å·å°äºç­‰äº n çš„æ³•ä»¤ã€‚&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Properties of the Protocol&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;åœ¨æ€»ç»Ÿæè®®ä»»ä½•æ³•ä»¤ä¹‹å‰ï¼Œå¿…é¡»å…ˆå‘ majority å­¦ä¹ ä»–ä»¬å·²ç»æŠ•è¿‡ç¥¨çš„æ³•ä»¤ã€‚&lt;/strong&gt;ä»»ä½•ä¸€ä¸ªå·²ç»é€šè¿‡çš„æ³•ä»¤ä¸€å®šè¢«è‡³å°‘ä¸€ä¸ªå¤šæ•°é›†åˆä¸­çš„è®®å‘˜æŠ•è¿‡ç¥¨ã€‚è¿™æ ·å°±ä¿è¯äº†æ€»ç»Ÿåœ¨æè®®æ–°æ³•ä»¤å‰å¾‹ç°¿ä¸Šä¸ä¼šæœ‰ç©ºç¼ºã€‚&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 20:36:16 +0800</pubDate>
        <link>http://masutangu.com/2018/03/the-part-time-parliament-note/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/the-part-time-parliament-note/</guid>
        
        
        <category>è¯»ä¹¦ç¬”è®°</category>
        
      </item>
    
      <item>
        <title>å¤šæ’è¡Œæ¦œæ•°æ®åˆ·æ–°æ–¹æ¡ˆ</title>
        <description>&lt;h2&gt;ä¸€. èƒŒæ™¯&lt;/h2&gt;

&lt;p&gt;æœ€è¿‘å·¥ä½œé‡åˆ°ä¸€ä¸ªæ£˜æ‰‹çš„é—®é¢˜ï¼š&lt;strong&gt;å¤šä¸ªä¸åŒçš„æ’è¡Œæ¦œçš„ç©å®¶ä¿¡æ¯å¦‚ä½•ä¿æŒä¸€è‡´&lt;/strong&gt;ã€‚ç®€å•æè¿°ä¸‹åœºæ™¯ï¼Œä»¥å°æ¸¸æˆè·³ä¸€è·³ä¸ºä¾‹å­ï¼Œä¸€å¼€å§‹æ¸¸æˆåªæœ‰ä¸€ä¸ªå¥½å‹æ’è¡Œæ¦œï¼Œå¥½å‹æ’è¡Œæ¦œä»¥ç©å®¶çš„æœ€é«˜åˆ†æ•°è¿›è¡Œæ’åºï¼Œè¿™æ ·å¥½å¤„ç†ï¼Œæ­ä¸€ä¸ªå…³ç³»é“¾svrï¼Œè¯¥ svr ä¸Šç¼“å­˜ç©å®¶å¥½å‹çš„ä¿¡æ¯ï¼ˆé¿å…æ¯æ¬¡å» DB æŸ¥è¯¢ï¼‰ï¼Œå¹¶ä½¿ç”¨ç©å®¶ä¿¡æ¯ä¸­çš„æœ€é«˜åˆ†æ•°è¿›è¡Œæ’åºã€‚å®¢æˆ·ç«¯è¯·æ±‚æ—¶ä¸‹æ–¹ç›¸åº”çš„æ’åå’Œç©å®¶ä¿¡æ¯ï¼ŒåŒ…æ‹¬æœ€é«˜åˆ†æ•°ä¿¡æ¯ï¼ˆå®¢æˆ·ç«¯éœ€è¦å±•ç¤ºï¼‰å³å¯ã€‚ä½†å¦‚æœæˆ‘ä»¬è¦æ–°å¢ä¸€ä¸ªå…¨å›½æ’è¡Œæ¦œï¼Œå…¨å›½æ’è¡Œæ¦œä»¥ç©å®¶çš„æœ€é«˜æ­¥æ•°ï¼‹è€—æ—¶è¿›è¡Œæ’è¡Œã€‚è¿™æ—¶éœ€è¦æ­ä¸€ä¸ªå…¨å›½æ’è¡Œæ¦œsvrï¼Œè¯¥svrä¸ŠåŒæ ·ç¼“å­˜è¿›å…¥å…¨å›½æ’è¡Œæ¦œçš„ç©å®¶çš„ä¿¡æ¯ï¼Œä½¿ç”¨ç©å®¶ä¿¡æ¯ä¸­çš„æœ€é«˜åˆ†æ•°ï¼‹è€—æ—¶è¿›è¡Œæ’åºã€‚åŒæ ·çš„åœ¨å®¢æˆ·ç«¯è¯·æ±‚æ—¶ä¸‹å‘ç›¸åº”çš„æ’åå’Œç©å®¶ä¿¡æ¯ã€‚&lt;/p&gt;

&lt;p&gt;&lt;em&gt;æ–¹æ¡ˆä¸€ï¼šå„ä¸ªæ’è¡Œæ¦œæœ‰è‡ªå·±çš„ç©å®¶ç¼“å­˜ï¼š&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;äºŒ. é—®é¢˜&lt;/h2&gt;

&lt;p&gt;ä½†é—®é¢˜æ¥äº†ï¼Œ&lt;strong&gt;å¦‚ä½•ä¿è¯å‡ºç°åœ¨ä¸¤ä¸ªæ¦œå•çš„åŒä¸€ç©å®¶æ•°æ®æ˜¯ä¸€è‡´çš„ï¼Ÿ&lt;/strong&gt;ï¼ˆä¸ä¸€è‡´æ˜¯å› ä¸ºä¸¤ä¸ªæ’è¡Œ svr åˆ†åˆ«ç¼“å­˜äº†ç©å®¶çš„ä¿¡æ¯ï¼Œæ¯ä¸ªsvrçš„æ’è¡Œæ•°æ®ç¼“å­˜åˆ·æ–°å‘¨æœŸä¹Ÿä¸ä¸€è‡´ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;è¿™æ—¶å€™å°±éœ€è¦ä½¿ç”¨ä¸€ä¸ªå…¨å±€çš„ data svr æ¥ç¼“å­˜ç©å®¶çš„ä¿¡æ¯ï¼Œ&lt;strong&gt;ä¿è¯ä¸åŒæ’è¡Œ svr å–åˆ°çš„ç©å®¶æ•°æ®æ˜¯ä¸€è‡´çš„ï¼ŒåŒæ—¶ä¸¤ä¸ªæ’è¡Œsvråˆ·æ–°ç¼“å­˜çš„å‘¨æœŸéœ€è¦ä¿æŒä¸€è‡´&lt;/strong&gt;ã€‚&lt;/p&gt;

&lt;p&gt;&lt;em&gt;æ–¹æ¡ˆäºŒï¼šæ¯ä¸ªæ’è¡Œæ¦œéƒ½ä»data svr æ‹‰å–ç©å®¶æ•°æ®ï¼š&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;æ•°æ®æºéƒ½ä» data svr æ‹‰å–è¿™ä¸ªå¾ˆç®€å•ï¼Œå…³é”®åœ¨äº&lt;strong&gt;å¦‚ä½•è®©ä¸åŒæ’è¡Œæ¦œçš„åˆ·æ–°å‘¨æœŸä¿æŒä¸€è‡´&lt;/strong&gt;ã€‚æœ¬æ–‡æå‡ºä¸€ä¸ªä¸æˆç†Ÿæœ‰å¾…è€ƒéªŒçš„æ–¹æ¡ˆè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¹¶ç»™å‡ºç®€å•çš„åè®®ä¾‹å­è¯´æ˜ã€‚&lt;/p&gt;

&lt;h2&gt;ä¸‰. æ–¹æ¡ˆ&lt;/h2&gt;

&lt;h3&gt;1. åè®®&lt;/h3&gt;

&lt;p&gt;CSProto è¡¨ç¤ºä»å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨çš„åè®®ï¼ŒSSProto è¡¨ç¤ºæœåŠ¡å™¨ä¹‹é—´çš„åè®®ã€‚Common ä¸ºå…¬ç”¨åè®®ã€‚å®šä¹‰æ’è¡Œæ¦œç›¸å…³åè®®å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;em&gt;å…¬ç”¨åè®®ï¼š&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package Common;

message PlayerInfo {
    int32 uid              = 1;  // ç©å®¶ uid
    int64 udpate_timestamp = 2;  // ç©å®¶ä¿¡æ¯çš„æ›´æ–°æ—¶é—´
    // ç©å®¶ä¿¡æ¯ åŒ…æ‹¬ä¾‹å¦‚æœ€é«˜åˆ† è€—æ—¶ å…·ä½“å­—æ®µç•¥è¿‡ç•¥
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„åè®®ï¼š&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import &amp;quot;common.proto&amp;quot;;

package CSProto;

message RankReq {
    int32 rank_type = 1; // æ’è¡Œæ¦œç±»å‹ ä¾‹å¦‚å¥½å‹æ’è¡Œæ¦œ å…¨å›½æ’è¡Œæ¦œ
}

message RankInfo {
    Common.PlayerInfo info = 1; // ç©å®¶ä¿¡æ¯ å®¢æˆ·ç«¯å±•ç¤ºç”¨
    int32 rank_idx         = 2; // ç©å®¶æ’å
}

message RankRes {
    int32 rank_type             = 1; // æ’è¡Œæ¦œç±»å‹ ä¾‹å¦‚å¥½å‹æ’è¡Œæ¦œ å…¨å›½æ’è¡Œæ¦œ
    repeated RankInfo rank_list = 2; // æ’è¡Œæ•°æ®
    int64 update_timestamp      = 3; // æ’è¡Œæ¦œæ›´æ–°æ—¶é—´
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;æœåŠ¡å™¨å’ŒæœåŠ¡å™¨ä¹‹é—´çš„åè®®ï¼š&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package SSProto;

message GetPlayerInfoReq {
    repeated int32 uid_list = 1;
} 

message GetPlayerInfoRes {
    repeated Common.PlayerInfo info_list = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;æ¶ˆæ¯æµå¦‚ä¸‹ï¼š&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2. ä¿è¯æ’è¡Œæ¦œ svr åˆ·æ–°å‘¨æœŸä¸€è‡´&lt;/h3&gt;

&lt;p&gt;æ’è¡Œæ¦œ svr ä» Data svr ä¸­æ‹‰å–ç©å®¶çš„ä¿¡æ¯è¿›è¡Œæ’åºï¼Œè€Œ Data svr ä¼šå®šæœŸå»æ›´æ–°ç©å®¶çš„ä¿¡æ¯ï¼Œå¯ä»¥æ¨å¯¼å‡ºï¼š&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;æ’è¡Œæ¦œçš„åˆ·æ–°æ—¶é—´ç­‰äºmax(æ’è¡Œæ¦œä¸Šæ¦œçš„ç©å®¶æ•°æ®çš„æ›´æ–°æ—¶é—´æˆ³)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;å› æ­¤å›åŒ…ç»™å®¢æˆ·ç«¯çš„ RankRes ä¸­çš„ update_timestamp å–å€¼çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_res.update_timestamp =  max([rankinfo.info.udpate_timestamp for rankinfo in rank_res.rank_list])
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;å®¢æˆ·ç«¯ä½¿ç”¨ map æ¥ç®¡ç†æ¯ä¸ªæ’è¡Œæ¦œçš„æ›´æ–°æ—¶é—´ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# rank_map
&amp;lt;ranktype1, udpate_timestamp1&amp;gt;
&amp;lt;ranktype2, update_timestamp2&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;å¹¶å®šä¹‰æ‰€æœ‰æ’è¡Œæ¦œçš„æœ€æ–°æ›´æ–°æ—¶é—´ rank_max_update_timestampï¼Œå–å€¼ä¼ªä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_max_update_timestamp = max([update_timestamp for _, update_timestamp in rank_map]) 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;å½“ç©å®¶ç‚¹å‡»æŸä¸ªæ’è¡Œæ¦œï¼Œå®¢æˆ·ç«¯å‘ç°è¯¥æ’è¡Œæ¦œçš„ update_timestamp å°äº rank_max_update_timestampï¼Œå°±èƒ½åˆ¤å®šè¯¥æ’è¡Œæ¦œä¸Šå­˜åœ¨è¿‡æ—¶çš„ç©å®¶æ•°æ®ï¼Œè¿™æ—¶å°±åº”è¯¥å‘åå°å‘èµ· RankReq è·å–æ’è¡Œæ¦œè¯·æ±‚ã€‚&lt;strong&gt;é€šè¿‡åŠæ—¶è¯·æ±‚è¿‡æ—¶æ’è¡Œæ¦œæ•°æ®ï¼Œä¿è¯æ¯ä¸ªæ’è¡Œæ¦œçš„ update_timestamp ä¸€è‡´ï¼Œå°±èƒ½ä¿è¯æ’è¡Œæ¦œä¸Šç©å®¶ä¿¡æ¯çš„ä¸€è‡´ï¼Œä¹Ÿå°±ä¿è¯äº†åœ¨å¤šä¸ªæ’è¡Œæ¦œä¸Šç©å®¶ä¿¡æ¯çš„ä¸€è‡´ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3. ä¼˜åŒ–&lt;/h3&gt;

&lt;p&gt;ä¸Šé¢æåˆ°ï¼Œæ¯æ¬¡ update_timestamp å°äº rank_max_update_timestampï¼Œå®¢æˆ·ç«¯éƒ½ä¼šé‡æ–°è¯·æ±‚ä¸€æ¬¡æ’è¡Œæ¦œï¼Œåå°ä¼šè¿”å›æœ€æ–°çš„æ’è¡Œæ¦œæ•°æ®ï¼Œè¿™é‡Œå…¶å®å¯ä»¥åšä¸‹ä¼˜åŒ–ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-4.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;å®¢æˆ·ç«¯å…ˆè¯·æ±‚äº† ranktype1 çš„æ’è¡Œæ¦œï¼Œå¯ä»¥çœ‹å‡º ranktype1 çš„ update_timestamp ä¸º t1ã€‚ä¹‹ååˆè¯·æ±‚äº† rank_type2 çš„æ’è¡Œæ¦œï¼Œè¿”å› ranktype2 çš„ update_timestamp ä¸º t2ã€‚ç”±äº t1 &amp;lt; t2ï¼Œå®¢æˆ·ç«¯ä¼šå‘ç°éœ€è¦æ›´æ–° ranktype1ã€‚ä½†ä»å›¾ä¸Šå¯ä»¥çœ‹å‡ºå…¶å®åå°ä¸éœ€è¦å†è¿”å›ä¸€æ¬¡ ranktype1 çš„æ’è¡Œæ•°æ®äº†ï¼ˆranktype1 æ¦œä¸Šçš„ç©å®¶ uid1 uid2 uid3 çš„æ•°æ®å¹¶æ²¡æœ‰å˜åŒ–ï¼‰ã€‚å› æ­¤æˆ‘ä»¬åœ¨ RankReq é‡ŒåŠ ä¸Šå®¢æˆ·ç«¯æœ¬åœ°è¯¥æ’è¡Œæ¦œçš„ update_timestampï¼Œå¦‚æœåå°å‘ç°å®¢æˆ·ç«¯çš„ update_timestamp å’Œåå°çš„æ˜¯ä¸€è‡´çš„ï¼Œå°±è¿”å›ç‰¹å®šçš„é”™è¯¯ç å‘Šè¯‰å®¢æˆ·ç«¯æ’è¡Œæ¦œä¾ç„¶æœ‰æ•ˆã€‚&lt;/p&gt;

&lt;p&gt;&lt;em&gt;æ–°å¢å®¢æˆ·ç«¯æœ¬åœ°è¯¥æ’è¡Œæ¦œçš„ update_timestampï¼š&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;message RankReq {
    int32 rank_type               = 1; // æ’è¡Œæ¦œç±»å‹ ä¾‹å¦‚å¥½å‹æ’è¡Œæ¦œ å…¨å›½æ’è¡Œæ¦œ
    int64 client_update_timestamp = 2; // å®¢æˆ·ç«¯æœ¬åœ°è¯¥æ’è¡Œæ¦œçš„ update_timestamp
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;é‡‡ç”¨è¿™ç§æ–¹å¼çš„è¯ï¼Œæ¯æ¬¡ç‚¹å‡»è¯¥æ’è¡Œæ¦œå®¢æˆ·ç«¯è¿˜æ˜¯éœ€è¦å‘èµ·ä¸€æ¬¡ï¼ˆæ— æ•ˆï¼‰çš„åå°è¯·æ±‚ï¼Œå¦‚ä½•åšä¼˜åŒ–å‘¢ï¼Ÿè¿™é‡Œç”¨äº†ä¸€ä¸ªç®€å•çš„æ–¹æ¡ˆï¼Œå¦‚æœå®¢æˆ·ç«¯æ”¶åˆ°æ’è¡Œæ¦œä¾ç„¶æœ‰æ•ˆçš„é”™è¯¯ç ï¼Œå°±æŠŠæœ¬åœ°è¯¥æ’è¡Œæ¦œ update_timestamp æ›´æ–°ä¸º rank_max_update_timestampï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-5.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;æ¯æ¬¡å®¢æˆ·ç«¯è¯·æ±‚ï¼Œrank svr éƒ½éœ€è¦åˆ° data svr æŸ¥è¯¢ç©å®¶ä¿¡æ¯ã€‚å¯ä»¥åœ¨ rank svr ä¸Šç¼“å­˜ç©å®¶çš„ä¿¡æ¯ï¼Œåˆ° data svr æŸ¥è¯¢æ—¶å¦‚æœç©å®¶æ•°æ®æ— å˜åŒ–ï¼Œåˆ™è¿”å›ç‰¹å®šé”™è¯¯ç ï¼Œrank svr ç»§ç»­ä½¿ç”¨æœ¬åœ°çš„ç©å®¶ä¿¡æ¯ç¼“å­˜ã€‚&lt;/p&gt;

&lt;h2&gt;ä¸‰. æ€»ç»“&lt;/h2&gt;

&lt;p&gt;æœ¬æ–‡æå‡ºäº†ä¸€ä¸ªæœ‰å¾…è€ƒéªŒçš„å¤šæ’è¡Œæ¦œæ•°æ®åˆ·æ–°æ–¹æ¡ˆï¼Œä¸ºè§£å†³å¤šä¸ªæ’è¡Œæ¦œæ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜ã€‚è¯¥æ–¹æ¡ˆè¿˜æœ‰ä¸€äº›ç»†èŠ‚æœ‰å¾…è€ƒé‡ï¼Œæ¬¢è¿å¤§å®¶æœ‰ä»»ä½•æƒ³æ³•æˆ–æœ‰æ›´å¥½çš„æ–¹æ¡ˆé‚®ä»¶æˆ‘ä¸€èµ·è®¨è®ºã€‚&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 09:00:42 +0800</pubDate>
        <link>http://masutangu.com/2018/03/multi-rank-refresh-design/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/multi-rank-refresh-design/</guid>
        
        
        <category>å·¥ä½œ</category>
        
      </item>
    
      <item>
        <title>Programming Language è¯¾ç¨‹ç¬”è®°</title>
        <description>&lt;p&gt;æœ¬æ–‡æ˜¯å­¦ä¹ &lt;a href=&quot;https://www.coursera.org/learn/programming-languages/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;è¯¾ç¨‹çš„å­¦ä¹ ç¬”è®°ï¼Œæ–‡ç« å†…å®¹åŠä»£ç å‡å–è‡ªè¯¾ç¨‹ææ–™ã€‚&lt;/p&gt;

&lt;h2&gt;ä¸€. å£°æ˜å¼ç¼–ç¨‹å’Œå‘½ä»¤å¼ç¼–ç¨‹&lt;/h2&gt;

&lt;h4&gt;å£°æ˜å¼ç¼–ç¨‹ï¼ˆDeclarative Programmingï¼‰&lt;/h4&gt;

&lt;p&gt;Building the structure and elements of computer programs, that &lt;strong&gt;expresses the logic of a computation without describing its control flow&lt;/strong&gt;.&lt;/p&gt;

&lt;h4&gt;å‘½ä»¤å¼ç¼–ç¨‹ï¼ˆImperative Programmingï¼‰&lt;/h4&gt;

&lt;p&gt;Describes computation &lt;strong&gt;in terms of statements that change a program state&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;å·¦å›¾ä¸º Declarative Programming èŒƒå¼ï¼Œå³å›¾ä¸º Imperative Programming èŒƒå¼ï¼š&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;äºŒ. å‡½æ•°å¼ç¼–ç¨‹&lt;/h2&gt;

&lt;p&gt;ä¸‰å¤§ç‰¹æ€§ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No Mutation&lt;/li&gt;
&lt;li&gt;First Class Function&lt;/li&gt;
&lt;li&gt;Tail Recursion Optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;1. No Mutation&lt;/h3&gt;

&lt;p&gt;çŸ¥ä¹ä¸Š&lt;a href=&quot;https://www.zhihu.com/question/28292740&quot;&gt;ã€Šä»€ä¹ˆæ˜¯å‡½æ•°å¼ç¼–ç¨‹æ€ç»´ã€‹&lt;/a&gt;å…¶ä¸­ä¸€ä¸ªå›åˆ°å†™å¾—å¾ˆå¥½ï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;å‡½æ•°å¼ç¼–ç¨‹çš„æœ¬è´¨ï¼š
å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„&lt;strong&gt;å‡½æ•°&lt;/strong&gt;è¿™ä¸ªæœ¯è¯­ä¸æ˜¯æŒ‡è®¡ç®—æœºä¸­çš„å‡½æ•°ï¼Œè€Œæ˜¯æŒ‡æ•°å­¦ä¸­çš„å‡½æ•°ï¼Œå³è‡ªå˜é‡çš„æ˜ å°„ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªå‡½æ•°çš„å€¼ä»…å†³å®šäºå‡½æ•°å‚æ•°çš„å€¼ï¼Œä¸ä¾èµ–å…¶ä»–çŠ¶æ€ã€‚åœ¨å‡½æ•°å¼è¯­è¨€ä¸­ï¼Œ&lt;strong&gt;å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘&lt;/strong&gt;ï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹å®šä¹‰ï¼Œåœ¨å‡½æ•°å†…æˆ–å‡½æ•°å¤–ï¼Œå¯ä»¥ä½œä¸ºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œå¯ä»¥å¯¹å‡½æ•°è¿›è¡Œç»„åˆã€‚çº¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸­çš„&lt;strong&gt;å˜é‡&lt;/strong&gt;ä¹Ÿä¸æ˜¯å‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€ä¸­çš„å˜é‡è¡¨ç¤ºå­˜å‚¨çŠ¶æ€çš„å•å…ƒï¼Œè€Œæ˜¯&lt;strong&gt;ä»£æ•°ä¸­çš„å˜é‡&lt;/strong&gt;ï¼Œå³ä¸€ä¸ªå€¼çš„åç§°ã€‚å˜é‡çš„å€¼æ˜¯&lt;strong&gt;ä¸å¯å˜çš„ï¼ˆimmutableï¼‰&lt;/strong&gt;ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸å…è®¸åƒå‘½ä»¤å¼ç¼–ç¨‹è¯­è¨€ä¸­é‚£æ ·å¤šæ¬¡ç»™ä¸€ä¸ªå˜é‡èµ‹å€¼ã€‚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;æ²¡æœ‰ Mutation å¸¦æ¥çš„å¥½å¤„:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No code can ever distinguish aliasing vs. identical copies&lt;/li&gt;
&lt;li&gt;No need to think about aliasing: focus on other things&lt;/li&gt;
&lt;li&gt;Can use aliasing, which saves space, without danger &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. How to build bigger types&lt;/h3&gt;

&lt;p&gt;3 most important type building-blocks in any language&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Each of&lt;/strong&gt;: A t value contains values of each of t1 t2 â€¦ tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One of&lt;/strong&gt;: A t value contains values of one of t1 t2 â€¦ tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self reference&lt;/strong&gt;: A t value can refer to other t values&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3. Tail Recursion and Accumulators&lt;/h3&gt;

&lt;p&gt;ML recognizes these tail calls in the compiler and treats them differently: &lt;strong&gt;pop the caller before the call, allowing callee to reuse the same stack space&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;éå°¾é€’å½’çš„è°ƒç”¨å †æ ˆ&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;å°¾é€’å½’ä¼˜åŒ–åçš„è°ƒç”¨å †æ ˆ&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4. Higher Order Function&lt;/h3&gt;

&lt;h4&gt;Map&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun map (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xsâ€™ =&amp;gt; (f x)::(map(f,xsâ€™))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Filter&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun filter (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xsâ€™ =&amp;gt; if f x
 then x::(filter(f,xsâ€™))
 else filter(f,xsâ€™)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Fold&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun fold f acc xs =
 case xs of
 [] =&amp;gt; acc
 | x::xsâ€™ =&amp;gt; fold f (f(acc,x)) xsâ€™
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Higher Order Function vs For Loop&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Fold&lt;/strong&gt;  is another very famous iterator over recursive structures. This pattern separates recursive traversal from data processing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same traversal for different data processing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same data processing for different data structures&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In both cases, using common vocabulary concisely communicates intent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;éå†å‡½æ•°å’Œå¤„ç†å‡½æ•°åˆ†ç¦»ï¼Œæé«˜å¤ç”¨æ€§ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;5. Function Closure&lt;/h3&gt;

&lt;p&gt;A function value has two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The code&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The environment&lt;/strong&gt; that was current when the function was defined&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This pair is called a &lt;strong&gt;function closure&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;6. Abstract Data Types With Closure&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;datatype set = S of { insert : int -&amp;gt; set, 
              member : int -&amp;gt; bool, 
              size   : unit -&amp;gt; int }

val empty_set =
    let
        fun make_set xs = (* xs is a &amp;quot;private field&amp;quot; in result *)
            let (* contains a &amp;quot;private method&amp;quot; in result *)
                fun contains i = List.exists (fn j =&amp;gt; i=j) xs
            in
                S { insert = fn i =&amp;gt; if contains i 
                                     then make_set xs 
                                     else make_set (i::xs),
                    member = contains,
                    size   = fn () =&amp;gt; length xs
                  }
            end
    in
        make_set []
    end 

fun use_sets () =
    let val S s1 = empty_set
        val S s2 = (#insert s1) 34
        val S s3 = (#insert s2) 34
        val S s4 = #insert s3 19
    in
        if (#member s4) 42
        then 99
        else if (#member s4) 19
        then 17 + (#size s3) ()
        else 0
    end 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;ä½¿ç”¨ Java å®ç°ï¼š&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;interface Func&amp;lt;B,A&amp;gt; {
    B m(A x);
}
interface Pred&amp;lt;A&amp;gt; {
    boolean m(A x);
}

class List&amp;lt;T&amp;gt; {
    T       head;
    List&amp;lt;T&amp;gt; tail;
    List(T x, List&amp;lt;T&amp;gt; xs) {
    head = x;
    tail = xs;
    }

    // * the advantage of a static method is it allows xs to be null
    //    -- a more OO way would be a subclass for empty lists
    // * a more efficient way in Java would be a messy while loop
    //   where you keep a pointer to the previous element and mutate it
    //   -- (try it if you do not believe it is messy)
    static &amp;lt;A,B&amp;gt; List&amp;lt;B&amp;gt; map(Func&amp;lt;B,A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        return new List&amp;lt;B&amp;gt;(f.m(xs.head), map(f,xs.tail));
    }

    static &amp;lt;A&amp;gt; List&amp;lt;A&amp;gt; filter(Pred&amp;lt;A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        if(f.m(xs.head))
            return new List&amp;lt;A&amp;gt;(xs.head, filter(f,xs.tail));
        return filter(f,xs.tail);
    }

    // * again recursion would be more elegant but less efficient
    // * again an instance method would be more common, but then
    //   all clients have to special-case null 
    static &amp;lt;A&amp;gt; int length(List&amp;lt;A&amp;gt; xs) {
        int ans = 0;
        while(xs != null) {
            ++ans;
            xs = xs.tail;
        }
        return ans;
    }
}

class ExampleClients {
    static List&amp;lt;Integer&amp;gt; doubleAll(List&amp;lt;Integer&amp;gt; xs) {
        return List.map((new Func&amp;lt;Integer,Integer&amp;gt;() { 
                     public Integer m(Integer x) { return x * 2; } 
                         }), xs);
    }
    static int countNs(List&amp;lt;Integer&amp;gt; xs, final int n) {
        return List.length(List.filter(
           (new Pred&amp;lt;Integer&amp;gt;() { 
               public boolean m(Integer x) { return x==n; } 
           }), xs));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;ä½¿ç”¨ C å®ç°:&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;typedef struct List list_t;
struct List {
  void * head;
  list_t * tail;
};

list_t * makelist (void * x, list_t * xs) {
  list_t * ans = (list_t *)malloc(sizeof(list_t));
  ans-&amp;gt;head = x;
  ans-&amp;gt;tail = xs;
  return ans;
}

list_t * map(void* (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  return makelist(f(env,xs-&amp;gt;head), map(f,env,xs-&amp;gt;tail));
}

list_t * filter(bool (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  if(f(env,xs-&amp;gt;head))
    return makelist(xs-&amp;gt;head, filter(f,env,xs-&amp;gt;tail));
  return filter(f,env,xs-&amp;gt;tail);
}

int length(list_t* xs) {
  int ans = 0;
  while(xs != NULL) {
    ++ans;
    xs = xs-&amp;gt;tail;
  }
  return ans;
}

// clients of our list implementation:
// [the clients that cast from void* to intptr_t are technically not legal C, 
//  as explained in detail below if curious]

// awful type casts to match what map expects
void* doubleInt(void* ignore, void* i) {
  return (void*)(((intptr_t)i)*2);
}

// assumes list holds intptr_t fields
list_t * doubleAll(list_t * xs) {
  return map(doubleInt, NULL, xs);
}

// awful type casts to match what filter expects
bool isN(void* n, void* i) {
  return ((intptr_t)n)==((intptr_t)i);
}

// assumes list hold intptr_t fields
int countNs(list_t * xs, intptr_t n) {
  return length(filter(isN, (void*)n, xs));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Fri, 02 Mar 2018 19:45:24 +0800</pubDate>
        <link>http://masutangu.com/2018/03/programing-language/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/programing-language/</guid>
        
        
        <category>è¯»ä¹¦ç¬”è®°</category>
        
      </item>
    
      <item>
        <title>åŸºäº Replicated State Machine å®ç°æ¸¸æˆè¿›ç¨‹æ¢å¤</title>
        <description>&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;æ¸¸æˆæœåŠ¡å™¨å®ç°çš„ä¸šåŠ¡é€»è¾‘æ™®éæ¯”è¾ƒå¤æ‚ï¼Œä¸”å¤§éƒ¨åˆ†æ˜¯å¸¦æœ‰çŠ¶æ€çš„ã€‚å¦‚æœè¿›ç¨‹é‡å¯æˆ–æ„å¤–å´©æºƒï¼Œä¼šå¯¼è‡´è¯¥æœåŠ¡å™¨ä¸Šçš„ç©å®¶æ–­çº¿ï¼Œä¸¢å¤±è¿›è¡Œä¸­çš„æ¸¸æˆæ•°æ®ï¼Œå¸¦æ¥æå·®çš„æ¸¸æˆä½“éªŒã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µå‡ºç°ï¼Œä¸€èˆ¬æ¸¸æˆæœåŠ¡å™¨éƒ½ä¼šæŒä¹…åŒ–ç©å®¶æ•°æ®ä»¥å®ç°è¿›ç¨‹æ¢å¤ï¼Œå½“é‡å¯æˆ–è¿›ç¨‹æ„å¤–å´©æºƒæ—¶ï¼Œé‡æ–°æ‹‰èµ·è¿›ç¨‹åå¯ä»¥æ¢å¤åˆ°ä¹‹å‰çš„çŠ¶æ€ã€‚&lt;strong&gt;å¸¸ç”¨çš„åšæ³•æ˜¯å°†ç©å®¶çš„çŠ¶æ€ä¿¡æ¯ä¿å­˜åœ¨å…±äº«å†…å­˜ä¸­ï¼Œé‡å¯æ—¶åŠ è½½å…±äº«å†…å­˜è¿›è¡Œæ¢å¤ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;å…±äº«å†…å­˜è™½ç„¶æ–¹ä¾¿ï¼Œä½†ä¼šæœ‰è®¸å¤šé™åˆ¶ã€‚æ¯”å¦‚ C++ æ¶‰åŠåˆ°&lt;strong&gt;å¤šæ€ï¼ˆè™šå‡½æ•°è¡¨ï¼‰ã€STLå®¹å™¨ï¼ˆheapåˆ†é…ï¼‰&lt;/strong&gt;ï¼Œéƒ½ä¸èƒ½ç›´æ¥æ˜ å°„åˆ°å…±äº«å†…å­˜ä¸­ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;è¿™ç¯‡æ–‡ç« æä¾›äº†æ–°çš„æ€è·¯ï¼Œæå‡ºä¸€ä¸ªå®ç°æ¸¸æˆè¿›ç¨‹æ¢å¤æ›´ç®€æ´çš„åšæ³•ã€‚&lt;/p&gt;

&lt;h2&gt;Replicated State Machine&lt;/h2&gt;

&lt;p&gt;åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œ&lt;strong&gt;replicated State Machine æ˜¯å®ç° fault tolerance çš„ä¸€ä¸ªé‡è¦æ–¹å¼&lt;/strong&gt;ï¼Œé€šå¸¸ç”±å¤åˆ¶æ—¥å¿—æ¥å®ç°ã€‚æ¯ä¸€å°æœåŠ¡å™¨ä¿å­˜ä¸€ä»½æ—¥å¿—ï¼Œæ—¥å¿—ä¸­åŒ…å«ä¸€ç³»åˆ—çš„å‘½ä»¤ï¼ŒçŠ¶æ€æœºä¼šæŒ‰é¡ºåºæ‰§è¡Œè¿™äº›å‘½ä»¤ã€‚å› ä¸ºæ¯ä¸€å°è®¡ç®—æœºçš„çŠ¶æ€æœºéƒ½æ˜¯ç¡®å®šçš„ï¼ˆdeterministic state machineï¼‰ï¼Œæ‰§è¡Œçš„å‘½ä»¤ç›¸åŒï¼Œæœ€åè¾“å‡ºçš„ç»“æœä¹Ÿç›¸åŒã€‚&lt;/p&gt;

&lt;h2&gt;Combine&lt;/h2&gt;

&lt;p&gt;å¦‚æœæˆ‘ä»¬èƒ½&lt;strong&gt;ä»¥ç¡®å®šçŠ¶æ€æœºï¼ˆdeterministic state machineï¼‰æ¥å®ç°æ¸¸æˆé€»è¾‘&lt;/strong&gt;ï¼Œå°±å¯ä»¥è¿ç”¨ replicated State Machine çš„æ€æƒ³ã€‚åªè¦æˆ‘ä»¬æŠŠæ‰€æœ‰è§¦å‘çŠ¶æ€æœºçŠ¶æ€å˜æ›´çš„ event éƒ½ä¿å­˜ä¸‹æ¥ï¼Œé‡å¯æ—¶ç›´æ¥é‡æ”¾ä¸€éï¼Œå°±å¯ä»¥å›åˆ°é‡å¯å‰çš„çŠ¶æ€äº†ã€‚&lt;/p&gt;

&lt;p&gt;å‡è®¾å®ç°ä¸€ä¸ªå›åˆåˆ¶ pvp çš„å¯¹æˆ˜æ¸¸æˆé€»è¾‘ã€‚RoomSvr ä¸Šæœ‰è‹¥å¹²ä¸ªæˆ¿é—´ã€‚æˆ‘ä»¬&lt;strong&gt;ä»¥ state machine æ¥å®ç°ä¸šåŠ¡é€»è¾‘ï¼Œæ¯ä¸ªæˆ¿é—´é€šè¿‡ state machine ç»´æŠ¤è‡ªå·±çš„çŠ¶æ€ä¿¡æ¯ï¼Œå°†ç©å®¶çš„è¯·æ±‚å’Œå®šæ—¶å™¨è¶…æ—¶éƒ½è½¬åŒ–ä¸º eventï¼Œé€šè¿‡ event distributer åˆ†å‘ç»™ç›¸åº”æˆ¿é—´å¤„ç†ï¼Œå¹¶ä¸”å°† event é€šè¿‡ logging module åºåˆ—åŒ–ä¿å­˜åˆ°æœ¬åœ°&lt;/strong&gt;ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;è¿›ç¨‹é‡å¯æ—¶ç›´æ¥åŠ è½½æ—¥å¿—ï¼Œè¯»å– event ä¸¢ç»™æˆ¿é—´çš„ state machine è¿›è¡Œé‡æ”¾ï¼Œå°±èƒ½å°†æ¯ä¸ªæˆ¿é—´æ¢å¤åˆ°è¿›ç¨‹é‡å¯/æŒ‚æ‰ä¹‹å‰çš„çŠ¶æ€äº†ã€‚&lt;/p&gt;

&lt;h2&gt;How to Snapshot&lt;/h2&gt;

&lt;p&gt;æ—¥ç§¯æœˆç´¯ï¼Œåºåˆ—åŒ–çš„æ—¥å¿—ä¼šè¶Šæ¥è¶Šå¤šï¼Œå¦‚ä½•èƒ½æ¸…ç†åˆ°ä¸å†éœ€è¦çš„æ—¥å¿—ï¼Œæé«˜é‡å¯æ—¶åŠ è½½çš„é€Ÿåº¦å‘¢ï¼Ÿç”±äºæ¸¸æˆé€»è¾‘ä¸æ˜¯ç®€å•çš„ kv å­˜å‚¨ï¼Œæ— æ³•ç›´æ¥åš snapshotï¼Œä¹Ÿæ— æ³•å‚è€ƒ leveldb LSM-Tree çš„åšæ³•ï¼Œéœ€è¦æ¢ä¸€ç§æ–¹å¼æ¥å‡å°‘æ—¥å¿—çš„å †ç§¯ã€‚&lt;/p&gt;

&lt;p&gt;å½“è¿™ä¸€å±€å·²ç»ç»“æŸæ—¶ï¼Œè¿™å±€çš„ç›¸å…³ event å°±å¯ä»¥å…¨éƒ¨åˆ æ‰äº†ã€‚å¦‚æœå°† event åºåˆ—åŒ–åˆ°æ—¥å¿—ä¸­ï¼Œè¦åˆ é™¤ä¼šæ¯”è¾ƒéº»çƒ¦ã€‚æ‰€ä»¥è€ƒè™‘åˆ©ç”¨å…±äº«å†…å­˜æ¥å®ç°ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;å®ç° ShmStore æ¥ç®¡ç†å…±äº«å†…å­˜çš„å­˜å‚¨ï¼Œæ›¿æ¢æ‰ä¸Šå›¾çš„ Logging Moduleã€‚&lt;code&gt;ShmArr&lt;/code&gt; ä¸ºæ˜ å°„åˆ°å…±äº«å†…å­˜çš„ &lt;code&gt;RoomInfo&lt;/code&gt;æ•°ç»„ï¼Œ&lt;code&gt;RoomInfo&lt;/code&gt; æ˜¯ C struct ç»“æ„ï¼Œè®°å½•äº†æˆ¿é—´idã€æˆ¿é—´çš„çŠ¶æ€ï¼ˆæ˜¯å¦æœ‰æ•ˆï¼‰å’Œæˆ¿é—´çš„æ‰€æœ‰ eventã€‚  &lt;code&gt;room_idx_map_&lt;/code&gt; ç»´æŠ¤ç€æˆ¿é—´ id åˆ° &lt;code&gt;ShmArr&lt;/code&gt; ä¸‹æ ‡çš„å…³ç³»ï¼Œ&lt;code&gt;free_idx_&lt;/code&gt; ä¿å­˜ç€ &lt;code&gt;ShmArr&lt;/code&gt; ä¸­ç©ºé—²çš„ä¸‹æ ‡ã€‚å½“åˆ›å»ºæ–°æˆ¿é—´æ—¶ï¼Œä» &lt;code&gt;free_idx_&lt;/code&gt; ä¸­å–ä¸€ä¸ªç©ºé—²ä¸‹æ ‡ï¼Œå¹¶æŠŠæˆ¿é—´ id åˆ°è¯¥ä¸‹æ ‡çš„æ˜ å°„å…³ç³»ä¿å­˜äº &lt;code&gt;room_idx_map_&lt;/code&gt; ä¸­ï¼Œå°† &lt;code&gt;RoomInfo&lt;/code&gt; çš„ status ç½®ä¸ºæœ‰æ•ˆã€‚ä¹‹åè¯¥æˆ¿é—´çš„æ‰€æœ‰ event å°±ä¿å­˜åœ¨å¯¹åº”çš„ &lt;code&gt;RoomInfo&lt;/code&gt; ç»“æ„é‡Œã€‚å½“æˆ¿é—´é”€æ¯æ—¶ï¼Œå°†å¯¹åº”çš„ &lt;code&gt;RoomInfo&lt;/code&gt; ç»“æ„æ¸…ç©ºï¼ŒåŒæ—¶ä»&lt;code&gt;room_idx_map_&lt;/code&gt;åˆ é™¤å¯¹åº”çš„æ˜ å°„å…³ç³»ï¼Œå¹¶æŠŠè¯¥ &lt;code&gt;RoomInfo&lt;/code&gt; çš„ä¸‹æ ‡æ·»åŠ å› &lt;code&gt;free_idx_&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;p&gt;å½“è¯»å–å…±äº«å†…å­˜é‡å»ºæˆ¿é—´çŠ¶æ€æ—¶ï¼ŒåªåŠ è½½ status ä¸ºæœ‰æ•ˆçš„ &lt;code&gt;RoomInfo&lt;/code&gt; ç»“æ„ã€‚&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;æœ€ç»ˆæ¨¡å—å›¾å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-4.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Jan 2018 11:30:24 +0800</pubDate>
        <link>http://masutangu.com/2018/01/game-recover-based-on-replicated-state-machine/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/01/game-recover-based-on-replicated-state-machine/</guid>
        
        
        <category>å·¥ä½œ</category>
        
      </item>
    
      <item>
        <title>MIT 6.824 å­¦ä¹ ç¬”è®°ï¼ˆå››ï¼‰</title>
        <description>&lt;p&gt;æœ¬ç³»åˆ—æ–‡ç« æ˜¯å¯¹ &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot;&gt;MIT 6.824&lt;/a&gt; è¯¾ç¨‹çš„å­¦ä¹ ç¬”è®°ã€‚&lt;/p&gt;

&lt;h1&gt;ZooKeeper&lt;/h1&gt;

&lt;h2&gt;Abstract&lt;/h2&gt;

&lt;p&gt;ZooKeeper æ—¨åœ¨æä¾›ç®€å•é«˜æ•ˆçš„å†…æ ¸ä»¥ä¾›å®¢æˆ·ç«¯å®ç°æ›´å¤æ‚çš„ coordination primitivesã€‚In addition to the wait-free
property, ZooKeeper provides a &lt;strong&gt;per client guarantee of FIFO execution of requests&lt;/strong&gt; and &lt;strong&gt;linearizability for all requests that change the ZooKeeper state&lt;/strong&gt;.&lt;/p&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;ä¸ºäº†ä¿è¯çŠ¶æ€æ›´æ–°æ“ä½œï¼ˆå†™è¯·æ±‚ï¼‰çš„ linearizabilityï¼ŒZooKeeper å®ç°äº† &lt;strong&gt;Zabï¼Œä¸€ä¸ªåŸºäº leader çš„åŸå­å¹¿æ’­åè®®&lt;/strong&gt;ã€‚In ZooKeeper, &lt;strong&gt;servers process read operations locally, and we do not use Zab to totally order them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;åœ¨å®¢æˆ·ç«¯ç¼“å­˜æ•°æ®æ˜¯æé«˜è¯»æ€§èƒ½çš„é‡è¦æŠ€æœ¯ï¼Œ&lt;strong&gt;ZooKeeper æä¾›äº† watch æœºåˆ¶&lt;/strong&gt;ï¼Œä¸ç›´æ¥ç®¡ç†å®¢æˆ·ç«¯ç¼“å­˜ã€‚&lt;/p&gt;

&lt;h2&gt;Service overview&lt;/h2&gt;

&lt;p&gt;ZooKeeper æä¾›ç»™å®¢æˆ·ç«¯ znode çš„æŠ½è±¡ï¼Œznode æœ‰ä¸‹åˆ—ä¸¤ç§ç±»å‹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt; : ç”±å®¢æˆ·ç«¯æ˜¾å¼åˆ›å»ºå’Œåˆ é™¤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ephemeral&lt;/strong&gt;: ç”±å®¢æˆ·ç«¯åˆ›å»ºï¼Œå¯ä»¥ç”±å®¢æˆ·ç«¯æ˜¾å¼åˆ é™¤ï¼Œå½“ä¼šè¯ç»ˆæ­¢æ—¶ç³»ç»Ÿä¹Ÿä¼šè‡ªåŠ¨åˆ é™¤&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ZooKeeper å®ç°äº† watch æœºåˆ¶ï¼Œå½“æ•°æ®å‘ç”Ÿæ”¹å˜æ—¶é€šçŸ¥å®¢æˆ·ç«¯ï¼Œè€Œä¸å¿…é€šè¿‡è®©å®¢æˆ·ç«¯è½®è¯¢æœåŠ¡å™¨çš„æ–¹å¼ã€‚&lt;/p&gt;

&lt;p&gt;å®¢æˆ·ç«¯è¿æ¥åˆ° ZooKeeper æ—¶ä¼šåˆå§‹åŒ–ä¸€ä¸ª sessionã€‚Session æœ‰è¶…æ—¶æœºåˆ¶ï¼Œå½“ ZooKeeper åœ¨è¶…æ—¶æ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯ sessionçš„ä»»ä½•ä¿¡æ¯æ—¶ï¼Œä¼šåˆ¤å®šè¯¥å®¢æˆ·ç«¯å·²ç»æŒ‚æ‰ã€‚&lt;/p&gt;

&lt;h2&gt;ZooKeeper guarantees&lt;/h2&gt;

&lt;p&gt;ZooKeeper å…·å¤‡ä»¥ä¸‹ä¸¤ä¸ªåŸºç¡€ä¿è¯ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linearizable writes&lt;/strong&gt;: all requests that update the state of ZooKeeper are serializable and respect precedence;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;FIFO client order&lt;/strong&gt;: all requests from a given client are executed in the order that they were sent by the client.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Examples of primitives&lt;/h2&gt;

&lt;h3&gt;Simple Locks without Herd Effect&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Lock
1 n = create(l + â€œ/lock-â€, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for watch event
6 goto 2

Unlock
1 delete(n)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Write Lock
1 n = create(l + â€œ/write-â€, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 2

Read Lock
1 n = create(l + â€œ/read-â€, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if no write znodes lower than n in C, exit
4 p = write znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 3
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;ZooKeeper Implementation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mit-6824-note-4/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;æ”¶åˆ°è¯·æ±‚æ—¶ï¼Œç”± request processor å¤„ç†ã€‚å¦‚æœæ˜¯å†™è¯·æ±‚ï¼Œåˆ™ä½¿ç”¨ zab åè®®ï¼Œæœ€ç»ˆæäº¤åˆ° ZooKeeper æ•°æ®åº“çš„ä¿®æ”¹å°†ä¼šè¢«å¤åˆ¶åˆ°è¯¥ç³»ç»Ÿä¸Šæ‰€æœ‰çš„æœåŠ¡å™¨ã€‚&lt;/p&gt;

&lt;p&gt;å¤åˆ¶æ•°æ®åº“æ˜¯ä¸€ä¸ªå†…å­˜æ•°æ®åº“ï¼Œ&lt;strong&gt;åœ¨å˜æ›´è¢«åº”åˆ°åˆ°å†…å­˜æ•°æ®åº“ä¹‹å‰ï¼Œæˆ‘ä»¬å¼ºåˆ¶å°†æ›´æ–°è®°å½•åˆ·åˆ°ç£ç›˜ä¸Šä»¥å®ç° recoverability&lt;/strong&gt;ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;æ¯ä¸ª ZooKeeper æœåŠ¡å™¨éƒ½æ¥æ”¶å¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ è¯»æ“ä½œç”±æ¯ä¸ªæœåŠ¡å™¨çš„æœ¬åœ°æ•°æ®åº“æ¥å¤„ç†ï¼Œå†™è¯·æ±‚åˆ™ç”± zab åè®®å¤„ç†ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Request Processor&lt;/h3&gt;

&lt;p&gt;ä¸å®¢æˆ·ç«¯å‘é€çš„è¯·æ±‚ä¸åŒï¼Œ&lt;strong&gt;äº‹åŠ¡æ˜¯å¹‚ç­‰çš„&lt;/strong&gt;ã€‚When the leader receives a write request, it calculates what the state of the system will be when the write is applied and transforms it into a transaction that captures this new state. The future state must be calculated because there may be outstanding transactions that have not yet been applied to the database. ï¼ˆå°½ç®¡ transaction å¯èƒ½æ‰§è¡Œå¤šæ¬¡ï¼Œä½†é€šè¿‡è®¡ç®— state çš„æ–¹å¼ï¼Œä¸”ä¿è¯å¤šæ¬¡æ‰§è¡Œçš„ transaction ä¹ŸæŒ‰ç…§åŸå…ˆçš„é¡ºåºï¼Œå°±èƒ½ä¿è¯å¹‚ç­‰æ€§ï¼‰&lt;/p&gt;

&lt;h3&gt;Atomic Broadcast&lt;/h3&gt;

&lt;p&gt;æ‰€æœ‰æ›´æ–° ZooKeeper çŠ¶æ€çš„è¯·æ±‚éƒ½è¢«è½¬å‘åˆ° leaderã€‚ Leader æ‰§è¡Œè¯·æ±‚å¹¶é€šè¿‡ Zabï¼Œä¸€ä¸ªåŸå­å¹¿æ’­åè®®å¹¿æ’­è¯¥å˜æ›´ã€‚Zab é‡‡ç”¨majority quorums æ¥å†³å®šä¸€ä¸ªå»ºè®®ï¼Œå› æ­¤ ZooKeeper åœ¨ 2F + 1 æœåŠ¡å™¨çš„åœºæ™¯ä¸‹æœ€å¤šå¯ä»¥å®¹å¿ F å°æœåŠ¡å™¨æ•…éšœã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Because state changes depend on the application of previous state changes, Zab provides stronger order guarantees than regular atomic broadcast.&lt;/strong&gt; More specifically, Zab guarantees that &lt;strong&gt;changes broadcast by a leader are delivered in the order they were sent&lt;/strong&gt; and &lt;strong&gt;all changes from previous leaders are delivered to an established leader before it broadcasts its own changes&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;Replicated Database&lt;/h3&gt;

&lt;p&gt;é‡æ”¾æ¶ˆæ¯ä»¥æ¢å¤çŠ¶æ€éå¸¸è€—æ—¶ï¼Œå› æ­¤ ZooKeeper å®šæœŸè¿›è¡Œå¿«ç…§ï¼Œæ¢å¤æ—¶åªéœ€è¦é‡æ”¾å¿«ç…§åçš„æ¶ˆæ¯ã€‚ ä¸ºäº†ä¸é”ä½çŠ¶æ€ï¼ŒZooKeeper é‡‡ç”¨&lt;strong&gt;æ¨¡ç³Šå¿«ç…§&lt;/strong&gt;çš„æ–¹å¼ã€‚å¯¹æ ‘è¿›è¡Œæ·±åº¦ä¼˜å…ˆæ‰«æï¼ŒåŸå­è¯»å–æ¯ä¸ª znode çš„æ•°æ®å’Œå…ƒæ•°æ®å¹¶å†™å…¥ç£ç›˜ã€‚Since the resulting fuzzy snapshot may have applied some subset of the state changes delivered during the generation of the snapshot, the result may not correspond to the state of ZooKeeper at any point in time. However, since state changes are idempotent, we can apply them twice as long as we apply the state changes in order.&lt;/p&gt;

&lt;h3&gt;Client-Server Interactions&lt;/h3&gt;

&lt;p&gt;è¯»è¯·æ±‚ç”±æœåŠ¡å™¨æœ¬åœ°å¤„ç†ã€‚æ¯ä¸ªè¯»è¯·æ±‚éƒ½è¢«ä¸€ä¸ª zxid æ ‡è®°ï¼Œè¡¨ç¤ºæœåŠ¡å™¨çœ‹åˆ°çš„æœ€åä¸€ä¸ªäº‹åŠ¡ã€‚æœ¬åœ°è¯»å–çš„æ–¹å¼æé«˜äº†æ€§èƒ½ï¼Œä½†å¯èƒ½è¿”å›æ—§æ•°æ®ã€‚å®¢æˆ·ç«¯å¯ä»¥åœ¨è¯»æ“ä½œåè°ƒç”¨ sync æ¥ä¿è¯è¿”å›çš„æ˜¯æœ€æ–°çš„å€¼ã€‚In our implementation, we do not need to atomically broadcast sync as we use a leader-based algorithm, and we simply place the sync operation at the end of the queue of requests between the leader and the server executing the call to sync. In order for this to work, the follower must be sure that the leader is still the leader. If there are pending transactions that commit, then the server does not suspect the leader. If the pending queue is empty, the leader needs to issue a null transaction to commit and orders the sync after that transaction.&lt;/p&gt;

&lt;p&gt;ZooKeeper æœåŠ¡å™¨ä»¥ FIFO çš„é¡ºåºæ¥å¤„ç†å®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚Response åŒ…å«äº† zxidã€‚Even heartbeat messages during intervals of no activity include the last zxid seen by the server that the client is connected to. If the client connects to a new server, that new server ensures that its view of the ZooKeeper data is at least as recent as the view of the client by checking the last zxid of the client against its last zxid. If the client has a more recent view than the server, the server does not reestablish the session with the client until the server has caught up.&lt;/p&gt;

&lt;h1&gt;Linearizability versus Serializability&lt;/h1&gt;

&lt;p&gt;æ³¨ï¼šæ‘˜è‡ª &lt;a href=&quot;http://www.bailis.org/blog/linearizability-versus-serializability/&quot;&gt;Linearizability versus Serializability&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Linearizability: single-operation, single-object, real-time order&lt;/h2&gt;

&lt;p&gt;Linearizability is a guarantee about single operations on single objects. It provides a real-time  guarantee on the behavior of a set of single operations.&lt;/p&gt;

&lt;p&gt;In plain English, under linearizability, writes should appear to be instantaneous. Imprecisely, once a write completes, all later reads (where â€œlaterâ€ is defined by wall-clock start time) should return the value of that write or the value of a later write. Once a read returns a particular value, all later reads should return that value or the value of a later write.&lt;/p&gt;

&lt;p&gt;Linearizability for read and write operations is synonymous with the term â€œatomic consistencyâ€ and is the â€œC,â€ or â€œconsistency,â€ in Gilbert and Lynchâ€™s proof of the CAP Theorem. We say linearizability is composable (or â€œlocalâ€) because, if operations on each object in a system are linearizable, then all operations in the system are linearizable.&lt;/p&gt;

&lt;h2&gt;Serializability: multi-operation, multi-object, arbitrary total order&lt;/h2&gt;

&lt;p&gt;Serializability is a guarantee about transactions, or groups of one or more operations over one or more objects. It guarantees that the execution of a set of transactions (usually containing read and write operations) over multiple items is equivalent to some serial execution (total ordering) of the transactions.&lt;/p&gt;

&lt;p&gt;Serializability is the traditional â€œI,â€ or isolation, in ACID. If usersâ€™ transactions each preserve application correctness (â€œC,â€ or consistency, in ACID), a serializable execution also preserves correctness. Therefore, serializability is a mechanism for guaranteeing database correctness.&lt;/p&gt;

&lt;p&gt;Serializability is not composable. Serializability does not imply any kind of deterministic orderâ€”it simply requires that some equivalent serial execution exists.&lt;/p&gt;

&lt;p&gt;å…³äº Serializability å’Œ Linearizabilityï¼Œå¯ä»¥è¯»è¯»&lt;a href=&quot;https://36kr.com/p/5037166.html&quot;&gt;åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§çš„å‘å±•å†å²&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Transaction Management in the R* Distributed Database Management System&lt;/h1&gt;

&lt;p&gt;è¿™ç¯‡è®ºæ–‡çš„ä¸»é¢˜æ˜¯å…³äºåˆ†å¸ƒå¼æ•°æ®åº“ç³»ç»Ÿçš„äº‹åŠ¡ç®¡ç†ï¼Œç€é‡æè¿°äº† R* æäº¤åè®®ï¼šPresumed Abortï¼ˆPAï¼‰å’Œ Presumed Commitï¼ˆPCï¼‰ã€‚PA å’Œ PC æ˜¯è‘—åçš„ two-phaseï¼ˆ2Pï¼‰æäº¤åè®®çš„æ‰©å±•ã€‚&lt;/p&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;R* is an experimental, distributed database management system (DDBMS). In a distributed database
system, the actions of a transaction (an atomic unit of consistency and recovery) may occur at more than one site. &lt;strong&gt;A commit protocol is needed to guarantee the uniform commitment of distributed transaction executions.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;Some of the desirable characteristics in a commit protocol are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guaranteed transaction atomicity always&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ability to â€œforgetâ€ outcome of commit processing after a short amount of timeï¼ˆä¸éœ€è¦ä¸€ç›´è®°å½•ç»“æœï¼‰&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minimal overhead in terms of log writes and message traffic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;optimized performance in the no-failure case&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exploitation of completely or partially read-only transactions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximizing the ability to perform unilateral aborts&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Multilevel hierarchical commit protocols are suggested to be more natural than the conventional two-level (one coordinator and a set of subordinates) protocols.&lt;/strong&gt; With these goals in mind, we extended the conventional 2P commit protocol to support a tree of processes and defined the &lt;strong&gt;Presumed Abort (PA)&lt;/strong&gt; and the &lt;strong&gt;Presumed Commit (PC)&lt;/strong&gt; protocols to improve the performance of distributed transaction commit. &lt;/p&gt;

&lt;h2&gt;The Two-Phase Commit Protocol&lt;/h2&gt;

&lt;p&gt;åœ¨ 2P æäº¤åè®®ä¸­ï¼Œåˆ†å¸ƒå¼äº‹åŠ¡æ‰§è¡Œæ¨¡å‹åŒ…æ‹¬äº†ä¸€ä¸ª coordinator è¿›ç¨‹ï¼Œå®ƒè¿æ¥äº†å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºå’Œå…¶ä»–ç§°ä¸º subordinates çš„è¿›ç¨‹ã€‚Subordinates è¿›ç¨‹å½¼æ­¤ä¹‹é—´ä¸äº¤äº’ï¼Œåªå’Œ coordinator äº¤äº’ã€‚æ¯ä¸ªäº‹åŠ¡åˆ†é…ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„åå­—ã€‚&lt;/p&gt;

&lt;h3&gt;2P Under Normal Operation&lt;/h3&gt;

&lt;p&gt;å½“ coordinator æ¥æ”¶åˆ°æ¥è‡ªç”¨æˆ·çš„äº‹åŠ¡æäº¤è¯·æ±‚æ—¶ï¼Œå¹¶è¡Œçš„å‘é€ PREPARE æ¶ˆæ¯ç»™ subordinatesï¼Œæ­¤æ—¶è¿›å…¥æäº¤åè®®çš„ç¬¬ä¸€é˜¶æ®µã€‚å¦‚æœè¯¥äº‹åŠ¡å¯ä»¥æäº¤ï¼Œsubordinate å…ˆ force-write ä¸€æ¡ prepare log recordï¼Œä¹‹åå‘é€ YES VOTE ç»™ coordinatorï¼Œå†ç­‰å¾… coordinator è¿”å›æœ€åçš„å†³ç­–ï¼ˆcommit è¿˜æ˜¯ abortï¼‰ï¼Œä¹‹å subordinate è¿›å…¥ &lt;strong&gt;prepare&lt;/strong&gt; çŠ¶æ€ï¼Œæ— æ³•å•æ–¹é¢ç»ˆæ­¢æˆ–æäº¤äº‹åŠ¡ã€‚å¦‚æœ subordinate å†³å®šç»ˆæ­¢äº‹åŠ¡ï¼Œå…ˆ force-write ä¸€æ¡ abort recordï¼Œä¹‹åå‘é€ NO VOTE ç»™ coordinatorã€‚å› ä¸º NO VOTE è¡¨ç¤ºå¦å†³ï¼Œsubordinate ä¸éœ€è¦ç­‰å¾… coordinatorï¼Œç›´æ¥ç»ˆæ­¢è¯¥äº‹åŠ¡ï¼Œé‡Šæ”¾é”å¹¶â€œå¿˜è®°â€è¯¥äº‹åŠ¡ï¼ˆä¸éœ€è¦è®°å½•ä»»ä½•ä¿¡æ¯äº†ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;å½“ coordinator æ¥æ”¶åˆ°æ‰€æœ‰ subordinates çš„æŠ•ç¥¨æ—¶ï¼Œè¿›å…¥æäº¤åè®®çš„ç¬¬äºŒé˜¶æ®µã€‚å¦‚æœæ‰€æœ‰æŠ•ç¥¨éƒ½æ˜¯ YESï¼Œåˆ™ coordinator è¿›å…¥ &lt;strong&gt;committing&lt;/strong&gt; çŠ¶æ€ï¼šé¦–å…ˆ force-write ä¸€æ¡ commit recordï¼Œå‘é€ COMMIT æ¶ˆæ¯ç»™æ‰€æœ‰ subordinates. åœ¨ force-write æˆåŠŸæ‰§è¡Œåï¼Œäº‹åŠ¡å³å¯æäº¤ï¼Œä¸”é€šçŸ¥å®¢æˆ·ç«¯äº‹åŠ¡å·²ç»æˆåŠŸæäº¤ã€‚å¦‚æœ coordinator æœ‰æ”¶åˆ° NO VOTEï¼Œåˆ™è¿›å…¥ &lt;strong&gt;aborting&lt;/strong&gt; çŠ¶æ€ï¼šforce-write ä¸€æ¡ abort recordï¼Œå‘é€ ABORT æ¶ˆæ¯ç»™å¤„äºå‡†å¤‡çŠ¶æ€çš„æˆ–è€…æ²¡æœ‰å› PREPARE æ¶ˆæ¯çš„ subordinatesã€‚&lt;/p&gt;

&lt;p&gt;å¦‚æœ subordinate æ”¶åˆ° COMMIT æ¶ˆæ¯ï¼Œåˆ™è¿›å…¥ &lt;strong&gt;committing&lt;/strong&gt; çŠ¶æ€ï¼šå…ˆ force-write ä¸€æ¡ commit recordï¼Œå‘é€ ACK æ¶ˆæ¯ç»™ coordinatorï¼Œç„¶åæäº¤äº‹åŠ¡å¹¶ä¸”â€œå¿˜è®°â€è¯¥äº‹åŠ¡ã€‚å¦‚æœæ”¶åˆ°çš„æ˜¯ ABORT æ¶ˆæ¯ï¼Œè¿›å…¥ &lt;strong&gt;aborting&lt;/strong&gt; çŠ¶æ€ï¼šforce-write ä¸€æ¡ abort recordï¼Œå‘é€ ACK æ¶ˆæ¯ç»™ coordinatorï¼Œç„¶åç»ˆæ­¢äº‹åŠ¡å¹¶ä¸”â€œå¿˜è®°â€è¯¥äº‹åŠ¡ã€‚å½“ coordinator æ”¶åˆ°æ‰€æœ‰ subordinates çš„ ACK æ¶ˆæ¯ï¼ˆä¸åŒ…æ‹¬ NO VOTE çš„ subordinatesï¼‰ï¼Œå†™ä¸€æ¡ end record ç„¶åâ€œå¿˜è®°â€è¯¥äº‹åŠ¡ã€‚&lt;/p&gt;

&lt;p&gt;The general principle on which the protocols described in this paper are based is that if a subordinate acknowledges the receipt of any particular message, then it should make sure (by forcing a log record with the information in that message before sending the ACK) that it will never ask the coordinator about that piece of information. &lt;/p&gt;

&lt;p&gt;log åŒ…å«äº†å¦‚ä¸‹å†…å®¹ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;the type (prepare, end, etc.) of the record&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identity of the process that writes the record&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the name of the transaction&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identity of the coordinator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the names of the exclusive locks held by the writer in the case of prepare records&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identities of the subordinates in the case of the commit/abort records written by the coordinator&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;æ€»ç»“ä¸‹ï¼Œæäº¤äº‹åŠ¡æ€»å…±éœ€è¦ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;subordinate å†™ä¸¤æ¡è®°å½•ï¼šprepare record å’Œ commit recordï¼Œä¸”å‘é€ä¸¤æ¡æ¶ˆæ¯ï¼šYES VOTE å’Œ ACK&lt;/li&gt;
&lt;li&gt;coordinator å‘é€ä¸¤æ¡æ¶ˆæ¯ï¼šPREPARE å’Œ COMMITï¼Œä»¥åŠå†™ä¸¤æ¡è®°å½•ï¼šcommit recordï¼ˆforce-writeï¼‰å’Œ end recordï¼ˆé force-writeï¼‰ &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2P and Failures&lt;/h3&gt;

&lt;p&gt;æ¯ä¸ªç«™ç‚¹éƒ½å­˜åœ¨ä¸€ä¸ª recovery è¿›ç¨‹ï¼Œå¤„ç†æ¥è‡ªå…¶ä»–ç«™ç‚¹çš„ recovery è¿›ç¨‹çš„ä¿¡æ¯ã€‚å½“ä» crash ä¸­æ¢å¤æ—¶ï¼Œrecovery è¿›ç¨‹è¯»å– stable storage çš„ logï¼Œå¹¶ä¸”åœ¨ virtual storage ä¸­é‡å»ºã€‚åœ¨ virtual storage çš„è¿™éƒ¨åˆ†ä¿¡æ¯æœ‰ä¸‹åˆ—ç”¨é€”ï¼š&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;åº”ç­”å…¶ä»–ç«™ç‚¹å‘æ¥çš„äº‹åŠ¡æŸ¥è¯¢è¯·æ±‚ï¼Œè¿™äº›äº‹åŠ¡çš„ coordinators æ˜¯è¿è¡Œåœ¨è¯¥æŒ‚æ‰çš„ç«™ç‚¹ä¸Šï¼ˆanswer queries from other sites about transactions that had their coordinators at this siteï¼‰&lt;/li&gt;
&lt;li&gt;å‘é€äº‹åŠ¡çš„æŸ¥è¯¢ä¿¡æ¯ç»™å…¶ä»–ç«™ç‚¹çš„ subordinatesï¼Œè¿™äº›äº‹åŠ¡çš„ coordinators æ˜¯è¿è¡Œåœ¨è¯¥æŒ‚æ‰çš„ç«™ç‚¹ä¸Šï¼ˆsend unsolicited information to other sites that had subordinates for transactions that had their coordinators at this siteï¼‰&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;åœ¨ virtual storage æ„å»ºçš„å¥½å¤„åœ¨äºå¯ä»¥å¿«é€Ÿå›åº”å…¶ä»–ç«™ç‚¹çš„æŸ¥è¯¢ï¼Œè€Œä¸éœ€è¦ä» stable storage æŸ¥è¯¢æ—¥å¿—ã€‚&lt;/p&gt;

&lt;p&gt;å½“ recovery è¿›ç¨‹å‘ç°æœ‰äº‹åŠ¡å¤„äº &lt;strong&gt;prepare&lt;/strong&gt; çŠ¶æ€ï¼Œåˆ™ä¼šå®šæœŸå‘ coordinator è¯¢é—®è¯¥äº‹åŠ¡åº”è¯¥å¦‚ä½•å¤„ç†ï¼ˆcommit è¿˜æ˜¯ abortï¼‰ã€‚å¦‚æœ recovery è¿›ç¨‹å‘ç°æœ‰äº‹åŠ¡åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å´©æºƒï¼Œæ²¡æœ‰ç•™ä¸‹ä»»ä½•æ—¥å¿—ï¼Œåˆ™ç›´æ¥å›æ»šæ“ä½œï¼Œå†™ä¸€æ¡ abort recordï¼Œç„¶åâ€œå¿˜è®°â€ã€‚&lt;/p&gt;

&lt;p&gt;å¦‚æœ recovery è¿›ç¨‹å‘ç°äº‹åŠ¡å¤„äº &lt;strong&gt;committing/aborting&lt;/strong&gt; çŠ¶æ€ï¼Œå®ƒå°†å°è¯•å®šæœŸå‘é€ COMMIT/ABORT ç»™æ‰€æœ‰è¿˜æ²¡ ACK è¿‡çš„ subordinatesã€‚ä¸€æ—¦æ”¶åˆ°æ‰€æœ‰ ACKï¼Œåˆ™å†™ä¸€æ¡ end record å¹¶ä¸”â€œå¿˜è®°â€è¯¥äº‹åŠ¡ã€‚&lt;/p&gt;

&lt;p&gt;å¦‚æœ recovery è¿›ç¨‹æ”¶åˆ°ä¸€æ¡äº‹åŠ¡æŸ¥è¯¢ï¼Œä½† virtual storage ä¸­æ²¡æœ‰è¯¥äº‹åŠ¡çš„ä¿¡æ¯ï¼Œåˆ™ç›´æ¥è¿”å› ABORTã€‚&lt;/p&gt;

&lt;h2&gt;The Presumed Abort Protocol&lt;/h2&gt;

&lt;p&gt;ä¸Šä¸€èŠ‚æåˆ°ï¼Œåœ¨æ‰¾ä¸åˆ°å…³äºäº‹åŠ¡çš„ä¿¡æ¯æ—¶ï¼Œrecovery è¿›ç¨‹å°†è¿”å› ABORTã€‚è¿™æ„å‘³ç€å½“ coordinator å†³å®šè¦ abort äº‹åŠ¡æ—¶ï¼Œå¯ä»¥ç›´æ¥â€œå¿˜è®°â€è¯¥äº‹åŠ¡ï¼Œcoordinator å’Œ subordinates ä¸å†éœ€è¦ force-write ä¸€æ¡ abort recordï¼Œsubordinates ä¹Ÿä¸éœ€è¦ ACK æ¥è‡ª coordinator çš„ ABORT æ¶ˆæ¯ã€‚coordinator ä¹Ÿä¸åœ¨éœ€è¦è®°å½• end record äº†ã€‚&lt;/p&gt;

&lt;p&gt;åªè¯»äº‹åŠ¡çš„æƒ…å†µä¸‹ï¼Œleaf è¿›ç¨‹ç›´æ¥è¿”å› READ VOTEï¼Œé‡Šæ”¾é”ï¼Œä¸”â€œå¿˜è®°â€è¯¥äº‹åŠ¡ã€‚ A nonroot, nonleaf sends a READ VOTE only if its own vote and those of its subordinatesâ€™ are also READ VOTES. Otherwise, as long as none of the latter is a NO VOTE, it sends a YES VOTE.ï¼ˆå­˜åœ¨éƒ¨åˆ†åªè¯»äº‹åŠ¡ï¼‰&lt;/p&gt;

&lt;p&gt;There will not be a second phase of the protocol if the root process is readonly and it gets only READ VOTES. In this case the root process, just like the other processes, writes no log records for the transaction. &lt;/p&gt;

&lt;p&gt;æ€»ç»“ä¸‹ï¼Œå®Œå…¨åªè¯»äº‹åŠ¡ï¼Œæ‰€æœ‰è¿›ç¨‹éƒ½ä¸éœ€è¦å†™ä»»ä½• log recordã€‚æ¯ä¸ª nonleaf è¿›ç¨‹å‘é€ä¸€æ¡ PREPARE æ¶ˆæ¯ï¼Œæ¯ä¸ª nonroot è¿›ç¨‹å‘é€ä¸€æ¡ä¿¡æ¯ READ VOTE æ¶ˆæ¯ã€‚&lt;/p&gt;

&lt;h2&gt;ZooKeeper Note&lt;/h2&gt;

&lt;p&gt;Zookeeper: &lt;strong&gt;a generic &amp;quot;master&amp;quot; service&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Design challenges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What API?&lt;/li&gt;
&lt;li&gt;How to make master fault tolerant?&lt;/li&gt;
&lt;li&gt;How to get good performance?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Challenges interact: good performance may influence API e.g., asynchronous interface to allow pipelining&lt;/p&gt;

&lt;p&gt;Sessions: clients sign into zookeeper&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Session allows a client to fail-over to another zookeeper service
Client know the term and index of last completed operationsend it on each request. &lt;strong&gt;Service performs operation only if caught up with what client has seen.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sessions can timeout
Client must refresh a session continuously send a heartbeat to the server (like a lease). &lt;strong&gt;Zookeeper considers client &amp;quot;dead&amp;quot; if doesn&amp;#39;t hear from a client.&lt;/strong&gt; Client may keep doing its thing (e.g., network partition) but cannot perform other zookeeper ops in that session&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Challenge: Duplicates client requests&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scenario
Primary receives client request, fails
Client resends client request to new primary&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lab 3: 
&lt;strong&gt;Table to detect duplicates&lt;/strong&gt;
&lt;strong&gt;Limitation: one outstanding op per client&lt;/strong&gt;ï¼ˆç¼“å­˜å›åŒ…ï¼Œæ‰€ä»¥éœ€è¦ç­‰ä¸Šä¸€ä¸ªè¯·æ±‚å¤„ç†å®Œï¼Œæ‰èƒ½å¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚ï¼Œå¯¹æ¯”æ˜¯å¦é‡å¤ï¼Œé‡å¤çš„è¯è¿”å›å·²ç»ç¼“å­˜å¥½çš„å›åŒ…ï¼‰
Problem problem: cannot pipeline client requests&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Zookeeper:
Some ops are idempotent period
Some ops are easy to make idempotent: &lt;strong&gt;test-version-and-then-do-op&lt;/strong&gt;
Some ops &lt;strong&gt;the client is responsible for detecting dups&lt;/strong&gt;
 Consider the lock example.
   Create a file name that includes its session ID
     &amp;quot;app/lock/request-sessionID-seqno&amp;quot;
     zookeeper informs client when switch to new primary
 client runs getChildren()
   if new requests is there, all set
   if not, re-issue create&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Problem: read may return stale data if only master performs it&lt;/p&gt;

&lt;p&gt;Zookeeper solution: don&amp;#39;t promise non-stale data (by default)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reads are allowed to return stale data&lt;/li&gt;
&lt;li&gt;Reads can be executed by any replica&lt;/li&gt;
&lt;li&gt;Read throughput increases as number of servers increases&lt;/li&gt;
&lt;li&gt;Read returns the last zxid it has seen
 So that new primary can catch up to zxid before serving the read
 Avoids reading from past&lt;/li&gt;
&lt;li&gt;Only sync-read() guarantees data is not stale&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sync optimization: &lt;strong&gt;avoid ZAB layer for sync-read&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Must ensure that read observes last committed txn. &lt;strong&gt;Leader puts sync in queue between it and replica.&lt;/strong&gt; If ops ahead of in the queue commit, then leader must be leader, otherwise, issue null transaction.(&lt;strong&gt;In same spirit read optimization in Raft paper&lt;/strong&gt;, see last par section 8 of raft paper)&lt;/p&gt;

&lt;h2&gt;2P Note&lt;/h2&gt;

&lt;p&gt;What about concurrent transactions?&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;x and y are bank balances
x and y start out as $10

T1 is doing a transfer of $1 from x to y
T1:
  add(x, 1)  -- server A
  add(y, -1) -- server B
T2:
  tmp1 = get(x)
  tmp2 = get(y)
  print tmp1, tmp2
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Problem: &lt;strong&gt;What if T2 runs between the two add() RPCs?&lt;/strong&gt; Then T2 will print 11, 10 money will have been created!  T2 should print 10,10 or 9,11.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The traditional correctness definition is &amp;quot;serializability&amp;quot;.&lt;/strong&gt;  Results should be as if transactions ran one at a time in some order as if T1, then T2; or T2, then T1. The results for the two differ, either is OK.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;quot;Two-phase locking&amp;quot; is one way to implement serializability&lt;/strong&gt;. Each database record has a lock. The lock is stored at the server that stores the record. Transaction must wait for and acquire a record&amp;#39;s lock before using it. Thus add() handler implicitly acquires lock when it uses record. x or y transaction holds its locks until &lt;em&gt;after&lt;/em&gt; commit or abort.&lt;/p&gt;

&lt;p&gt;What are locks really doing?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When transactions conflict, locks delay one to force serial execution.&lt;/li&gt;
&lt;li&gt;When transactions don&amp;#39;t conflict, locks allow fast parallel execution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Raft and two-phase commit solve different problems!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use Raft to get high availability by replicating&lt;/strong&gt;, i.e. to be able to operate when some servers are crashed. The servers all do the &lt;em&gt;same&lt;/em&gt; thing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use 2PC when each subordinate does something different&lt;/strong&gt; and &lt;strong&gt;all of them must do their part&lt;/strong&gt;. &lt;strong&gt;2PC does not help availability&lt;/strong&gt; since all servers must be up to get anything done. &lt;strong&gt;Raft does not ensure that all servers do something&lt;/strong&gt; since only a majority have to be alive.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What if you want &lt;strong&gt;high availability and distributed commit&lt;/strong&gt;?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each &amp;quot;server&amp;quot; should be a Raft-replicated service&lt;/li&gt;
&lt;li&gt;And the Transaction Coordinator(TC) should be Raft-replicated&lt;/li&gt;
&lt;li&gt;Run two-phase commit among the replicated services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then you can tolerate failures and still make progress.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jan 2018 19:53:45 +0800</pubDate>
        <link>http://masutangu.com/2018/01/mit-6824-note-4/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/01/mit-6824-note-4/</guid>
        
        
        <category>è¯»ä¹¦ç¬”è®°</category>
        
      </item>
    
  </channel>
</rss>
