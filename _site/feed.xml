<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Masutangu</title>
    <description>也許我這一生　始終在追逐那顆九號球</description>
    <link>http://masutangu.com/</link>
    <atom:link href="http://masutangu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Jul 2016 19:08:53 +0800</pubDate>
    <lastBuildDate>Thu, 07 Jul 2016 19:08:53 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>Elric 使用手册</title>
        <description>&lt;p&gt;这篇文章正式介绍下分布式任务框架 &lt;a href=&quot;https://github.com/Masutangu/Elric&quot;&gt;Elric&lt;/a&gt;，包括其API，架构，周边能力以及实现细节。&lt;/p&gt;

&lt;p&gt;读者可以先阅读之前的这篇文章《&lt;a href=&quot;http://masutangu.com/2015/08/elric-distributed-job-scheduler-by-python/&quot;&gt;Python实现的分布式任务调度系统&lt;/a&gt;》来了解Elric的起源和早期设计的思想。&lt;/p&gt;

&lt;h1&gt;一. 简介&lt;/h1&gt;

&lt;p&gt;Elric 是一个 Python 实现的简单的分布式任务框架。Master-Worker 架构，Worker 向 Master 提交任务和执行 Master 下发的任务。支持多种任务类型：即时任务，周期任务，crontab 任务和定时任务。
其实现参考了 &lt;a href=&quot;https://apscheduler.readthedocs.io/en/latest/&quot;&gt;Apscheduler&lt;/a&gt;，Elric 的部分逻辑参考了 Apscheduler， 部分代码（trigger）取自 Apscheduler。&lt;/p&gt;

&lt;h1&gt;二. API&lt;/h1&gt;

&lt;h2&gt;Master&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化和启动 Master&lt;/p&gt;

&lt;p&gt;启动 Master 很简单，样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from Master.rqueue import RQMaster
rq_Master = RQMaster()
rq_Master.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果需要带有 filter 功能（任务去重）的Master，应该实例化 Spider 类，样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from Master.spider import Spider
rq_Master = Spider()
rq_Master.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Worker&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化和启动 Worker&lt;/p&gt;

&lt;p&gt;Worker 的构造函数稍微复杂一些：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def __init__(self, name, listen_keys=None, Worker_num=2, timezone=None, logger_name=&amp;#39;elric.Worker&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;name：Worker 的名字，不同用途的 Worker 应该取不同的名字。&lt;/li&gt;
&lt;li&gt;listen_keys：Worker 监听的任务队列名，类型为 list。&lt;/li&gt;
&lt;li&gt;Worker_num：Worker 的进程池数。&lt;/li&gt;
&lt;li&gt;timezone：时区，默认为 local。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动 Worker 将会开始从监听的任务队列里取任务来执行，初始化和启动 Worker 的样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from Worker.rqueue import RQWorker
rq_Worker = RQWorker(name=&amp;#39;test&amp;#39;, listen_keys=[&amp;#39;job1&amp;#39;, &amp;#39;job2&amp;#39;])
rq_Worker.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上述代码初始化一个名字为 test 的 Worker，它将从 job1，job2 这两个任务队列中取下任务来执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提交任务&lt;/p&gt;

&lt;p&gt;提交任务的接口如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def submit_job(self, func, job_key, args=None, kwargs=None, trigger=None, job_id=None,
               replace_exist=False, filter_key=&amp;#39;&amp;#39;, filter_value=&amp;#39;&amp;#39;, **trigger_args):
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;func：提交该任务需要执行的函数。&lt;/li&gt;
&lt;li&gt;job_key：该任务将提交的任务队列名。&lt;/li&gt;
&lt;li&gt;args：提交的函数执行所需要的位置参数。&lt;/li&gt;
&lt;li&gt;kwargs：提交的函数执行所需要的命名参数。&lt;/li&gt;
&lt;li&gt;trigger：提交任务的执行时间信息，date 为定时任务，cron 为 crontab 任务、interval 为周期任务，为空则为即时任务。&lt;/li&gt;
&lt;li&gt;job_id：提交任务的id，便于调试。如果没有提供将自动生成一个随机id。&lt;/li&gt;
&lt;li&gt;filter_key：用以任务去重的key，注意只有 Master 为 Spider 实例该参数才有效。&lt;/li&gt;
&lt;li&gt;filter_key：用以任务去重的value，注意只有 Master 为 Spider 实例该参数才有效。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;去重&lt;/h2&gt;

&lt;p&gt;Elric 支持任务去重，通常这个特性用于爬虫。当有需要对已完成的任务进行去重时，可以提供 filter_key 和 filter_value 这两个参数：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;album_id = 123
rq_worker = RQWorker(name=&amp;#39;crawler&amp;#39;, listen_keys=[&amp;#39;crawl_album&amp;#39;, ])
rq_worker.submit_job(crawl_album, &amp;#39;job2&amp;#39;, args=[album_id], filter_key=&amp;#39;crawl_album_filter&amp;#39;, filter_value=album_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果 crawl_album 任务执行成功，则 Master 会往名为 &amp;#39;crawl_album_filter&amp;#39; 这个集合里添加 album_id 这个值。之后如果 Master 再次接受到filter_key为 crawl_album_filter 的任务，会先检查该任务的 filter_value 是否已经存在于 filter_key 的集合里，如果存在则直接过滤该任务，不再下发。&lt;/p&gt;

&lt;h2&gt;配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Masutangu/Elric/blob/master/settings.py&quot;&gt;settings.py&lt;/a&gt; 文件的配置信息如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DISTRIBUTED_LOCK_CONFIG：Master分布式锁的相关配置。&lt;/li&gt;
&lt;li&gt;JOB_QUEUE_CONFIG：任务队列的相关配置。&lt;/li&gt;
&lt;li&gt;FILTER_CONFIG：去重的相关配置。&lt;/li&gt;
&lt;li&gt;JOB_STORE_CONFIG：任务存储的相关配置。&lt;/li&gt;
&lt;li&gt;LOGGINGF_CONFIG：日志的相关配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;样例代码&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from Worker.rqueue import RQWorker

def wapper_job():
    print &amp;#39;run first job&amp;#39;
    rq_Worker.submit_job(nest_job, &amp;#39;job1&amp;#39;, args=[&amp;#39;hi i am nested job&amp;#39;])

def nest_job(welcome):
    print welcome

def test_job(language=None):
    print &amp;#39;my favorite language is {language}&amp;#39;.format(language=language)

def test_date_job():
    print &amp;#39;hello i am date job&amp;#39;

def test_cron_job():
    print &amp;#39;hello i am crontab job&amp;#39;

if __name__ == &amp;#39;__main__&amp;#39;:
    # 初始化名字为 test 的 Worker ，监听 &amp;#39;job1&amp;#39; 和 &amp;#39;job2&amp;#39; 这两个任务队列
    rq_worker = RQWorker(name=&amp;#39;test&amp;#39;, listen_keys=[&amp;#39;job1&amp;#39;, &amp;#39;job2&amp;#39;])

    # 向 Master 提交任务，该任务将由 Master 在 2015-07-17 21:13:30 这个时间点通过 &amp;#39;job1&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_date_job 函数
    rq_worker.submit_job(test_date_job, &amp;#39;job1&amp;#39;, trigger=&amp;#39;date&amp;#39;, run_date=&amp;#39;2015-07-17 21:13:30&amp;#39;)

    # 向 Master 提交任务，该任务将每隔30秒由 Master 通过 &amp;#39;job1&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 wapper_job 函数
    rq_worker.submit_job(wapper_job, &amp;#39;job1&amp;#39;, trigger=&amp;#39;interval&amp;#39;, seconds=30)

    # 向 Master 提交任务，该任务为即时任务（没有提供trigger），将马上由Master 通过任务队列 &amp;#39;job2&amp;#39; 下发给 Worker ，Worker 拿到后将执行 test_job 函数
    rq_worker.submit_job(test_job, &amp;#39;job2&amp;#39;, kwargs={&amp;#39;language&amp;#39;: &amp;#39;python&amp;#39;})

    # 向 Master 提交任务，该任务将在每分钟的第7秒由 Master 通过 &amp;#39;job2&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_cron_job 函数
    rq_worker.submit_job(test_cron_job, &amp;#39;job2&amp;#39;, trigger=&amp;#39;cron&amp;#39;, second=7)

    # 启动 Worker，如果 &amp;#39;job1&amp;#39; 或 &amp;#39;job2&amp;#39; 有任务则拉取下来执行
    rq_worker.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;完整的demo可见&lt;a href=&quot;https://github.com/Masutangu/Elric/tree/master/example&quot;&gt;https://github.com/Masutangu/Elric/tree/master/example&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;三. 架构&lt;/h1&gt;

&lt;p&gt;Elric 架构图如下：
&lt;img src=&quot;/assets/images/elric-documentation/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运转流程如下（包含部分实现细节）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Worker 调用 submit_job 提交任务，该任务将存放在任务队列的 &amp;#39;&lt;strong&gt;elric_submit_channel&lt;/strong&gt;&amp;#39; 队列中，等待 Master 处理。同时启动 Worker，Worker 将监听其感兴趣的任务队列，比如 &amp;#39;job1&amp;#39; 队列。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Master 从任务队列 &amp;#39;&lt;strong&gt;elric_submit_channel&lt;/strong&gt;&amp;#39; 中拉取 Worker 提交的任务，然后做如下处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;去重处理（如果该 Master 是 Spider 的实例，否则跳过该步骤）：&lt;/p&gt;

&lt;p&gt;首先判断任务是否带有 filter 信息，如果带有 filter 信息，则到去重模块 dupefiler 做去重：如果在名为 filter_key 的集合内已存在该 filter_value 的值，则该任务被过滤掉。   &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非即时处理：&lt;/p&gt;

&lt;p&gt;如果任务不是即时任务（ trigger 不为空），则将该任务存储到任务存储 jobstore 中，Master 有另一线程定时扫描 jobstore 取出到期任务来下发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务下发：&lt;/p&gt;

&lt;p&gt;将任务下发到相应的任务队列，例如放到名为 &amp;#39;job1&amp;#39; 的任务队列。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Worker 监听到 &amp;#39;job1&amp;#39; 任务队列有新任务，取出后交给 executor 来执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;四. 周边能力&lt;/h1&gt;

&lt;p&gt;任务的执行结果存放在 mongodb ，为了方便使用者查询和定位问题，我提供了一个简单粗糙的 web 服务：&lt;a href=&quot;https://github.com/Masutangu/ElricStats&quot;&gt;ElricStats&lt;/a&gt;，通过他可以方便的查询每个任务执行的时间和结果。&lt;/p&gt;

&lt;h1&gt;五. 实现细节&lt;/h1&gt;

&lt;h2&gt;Master的分布式锁&lt;/h2&gt;

&lt;p&gt;为了支持多机器部署Master，在某些操作需要有锁的机制来保证原子性，比如在查询 jobstore 并取出到期任务下发时，简化代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
    # 将任务下发到任务队列
    self._enqueue_job(job_key, serialized_job)

    # 获取任务的下次执行时间，并更新到 jobstore 
    job = Job.deserialize(serialized_job)
    last_run_time = Job.get_serial_run_times(job, now)
    job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
    self.update_job(job)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果在这个操作没有加锁保证原子性，将有可能下发重复的任务。这里我采用了redis实现的分布式锁来解决这个问题。其原理利用了 redis 的 setnx 命令，详细可以查看这篇文章《&lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;Distributed locks with Redis&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;我把分布式锁封装成 Context Managers 的形式：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class distributed_lock(object):
    def __init__(self, **config):
        self.config = config
        self.dlm = redlock.Redlock([config[&amp;#39;server&amp;#39;], ],
                                retry_count=config[&amp;#39;retry_count&amp;#39;],
                                retry_delay=config[&amp;#39;retry_delay&amp;#39;])
        self.dlm_lock = None

    def __enter__(self):
        while not self.dlm_lock:
            self.dlm_lock = self.dlm.lock(self.config[&amp;#39;resource&amp;#39;], 1000)
            if self.dlm_lock:
                break
            else:
                time.sleep(self.config[&amp;#39;retry_delay&amp;#39;])

    def __exit__(self, type, value, traceback):
        self.dlm.unlock(self.dlm_lock)
        self.dlm_lock = None
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这样就可以使用 with statement 来管理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;with distributed_lock(**DISTRIBUTED_LOCK_CONFIG):
    for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
        # 将任务下发到任务队列
        self._enqueue_job(job_key, serialized_job)

        # 获取任务的下次执行时间，并更新到 jobstore 
        job = Job.deserialize(serialized_job)
        last_run_time = Job.get_serial_run_times(job, now)
        job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
        self.update_job(job)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;六. 后续优化&lt;/h1&gt;

&lt;p&gt;Elric 目前来说还比较粗糙，后续有时间我希望对下面这几个方面做些优化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置规范化：目前我的配置文件 settings.py 的实现并不规范，后续希望参考 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt; 的做法来实现配置管理。 &lt;/li&gt;
&lt;li&gt;接口简化：后续可能会把 filter_key，job_key 和 func 这三个参数进行合并，把 filter_value 和 job_id 这两个参数进行合并，减少使用者的理解成本。&lt;/li&gt;
&lt;li&gt;防雪崩机制优化：目前防雪崩机制比较简单，在任务队列满的时候 Master 会缓存一部分任务。后期改造成在下发的任务里带上任务的下发时间，Worker 取到任务后如果发现任务已经过期一段时间则直接抛弃。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Jul 2016 15:02:11 +0800</pubDate>
        <link>http://masutangu.com/2016/07/elric-documentation/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/elric-documentation/</guid>
        
        
        <category>个人项目</category>
        
      </item>
    
      <item>
        <title>Python笔记</title>
        <description>&lt;p&gt;这篇文章整理了python相关的资料，包括性能优化、常见错误和高级用法。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：本文内容整理自网上博客，《Python Cookbook》等，非原创。&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;性能优化&lt;/h2&gt;

&lt;h3&gt;1. 字典和列表&lt;/h3&gt;

&lt;p&gt;Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from time import time
t = time()
list = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;is&amp;#39;,&amp;#39;python&amp;#39;,&amp;#39;jason&amp;#39;,&amp;#39;hello&amp;#39;,&amp;#39;hill&amp;#39;,&amp;#39;with&amp;#39;,&amp;#39;phone&amp;#39;,&amp;#39;test&amp;#39;,
&amp;#39;dfdf&amp;#39;,&amp;#39;apple&amp;#39;,&amp;#39;pddf&amp;#39;,&amp;#39;ind&amp;#39;,&amp;#39;basic&amp;#39;,&amp;#39;none&amp;#39;,&amp;#39;baecr&amp;#39;,&amp;#39;var&amp;#39;,&amp;#39;bana&amp;#39;,&amp;#39;dd&amp;#39;,&amp;#39;wrd&amp;#39;]
#list = dict.fromkeys(list,True)
print list
filter = []
for i in range (1000000):
    for find in [&amp;#39;is&amp;#39;,&amp;#39;hat&amp;#39;,&amp;#39;new&amp;#39;,&amp;#39;list&amp;#39;,&amp;#39;old&amp;#39;,&amp;#39;.&amp;#39;]:
        if find not in list:
            filter.append(find)
print &amp;quot;total run time:&amp;quot;
print time()-t
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;将list转化为dict后速度提升了将近一半。&lt;/p&gt;

&lt;h3&gt;2. 集合和列表&lt;/h3&gt;

&lt;p&gt;set 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 使用list：
from time import time
t = time()
lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]
listb=[2,4,6,9,23]
intersection=[]
for i in range (1000000):
for a in lista:
    for b in listb:
        if a == b:
            intersection.append(a)

print &amp;quot;total run time:&amp;quot;
print time()-t

# 使用set：
from time import time
t = time()
lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]
listb=[2,4,6,9,23]
intersection=[]
for i in range (1000000):
    list(set(lista)&amp;amp;set(listb))
print &amp;quot;total run time:&amp;quot;
print time()-t
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;3. 字符串的优化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在字符串连接的使用尽量使用 join() 而不是 +。&lt;/li&gt;
&lt;li&gt;当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对字符进行格式化比直接串联读取要快，因此要&lt;/p&gt;

&lt;p&gt;使用：&lt;code&gt;out = &amp;quot;&amp;lt;html&amp;gt;%s%s%s%s&amp;lt;/html&amp;gt;&amp;quot; % (head, prologue, query, tail)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;避免：&lt;code&gt;out = &amp;quot;&amp;lt;html&amp;gt;&amp;quot; + head + prologue + query + tail + &amp;quot;&amp;lt;/html&amp;gt;&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;4. 使用列表解析和生成器表达式&lt;/h3&gt;

&lt;p&gt;列表解析要比在循环中重新构建一个新的 list 更为高效，因此我们可以利用这一特性来提高运行的效率。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from time import time
t = time()
list = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;is&amp;#39;,&amp;#39;python&amp;#39;,&amp;#39;jason&amp;#39;,&amp;#39;hello&amp;#39;,&amp;#39;hill&amp;#39;,&amp;#39;with&amp;#39;,&amp;#39;phone&amp;#39;,&amp;#39;test&amp;#39;,
&amp;#39;dfdf&amp;#39;,&amp;#39;apple&amp;#39;,&amp;#39;pddf&amp;#39;,&amp;#39;ind&amp;#39;,&amp;#39;basic&amp;#39;,&amp;#39;none&amp;#39;,&amp;#39;baecr&amp;#39;,&amp;#39;var&amp;#39;,&amp;#39;bana&amp;#39;,&amp;#39;dd&amp;#39;,&amp;#39;wrd&amp;#39;]
total=[]
for i in range (1000000):
for w in list:
    total.append(w)
print &amp;quot;total run time:&amp;quot;
print time()-t

# 使用列表解析：
for i in range (1000000):
    a = [w for w in list]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在上述例子上中代码 &lt;code&gt;a = [w for w in list]&lt;/code&gt; 修改为 &lt;code&gt;a = (w for w in list)&lt;/code&gt;，运行时间将进一步减少。&lt;/p&gt;

&lt;h3&gt;5. 其他优化技巧&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；&lt;/li&gt;
&lt;li&gt;在循环的时候使用 xrange 而不是 range；使用 xrange 可以节省大量的系统内存，因为 xrange() 在序列中每次调用只产生一个整数元素。而 range() 將直接返回完整的元素列表，用于循环时会有不必要的开销。在 python3 中 xrange 不再存在，里面 range 提供一个可以遍历任意长度的范围的 iterator。&lt;/li&gt;
&lt;li&gt;使用局部变量，避免”global” 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。&lt;/li&gt;
&lt;li&gt;if done is not None 比语句 if done != None 更快，读者可以自行验证；&lt;/li&gt;
&lt;li&gt;在耗时较多的循环中，可以把函数的调用改为内联的方式；&lt;/li&gt;
&lt;li&gt;使用级联比较 “x &amp;lt; y &amp;lt; z” 而不是 “x &amp;lt; y and y &amp;lt; z”；&lt;/li&gt;
&lt;li&gt;while 1 要比 while True 更快（当然后者的可读性更好）；&lt;/li&gt;
&lt;li&gt;build in 函数通常较快，add(a,b) 要优于 a+b。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;常见错误&lt;/h2&gt;

&lt;h3&gt;1. range的使用&lt;/h3&gt;

&lt;p&gt;不恰当的使用range，容易出bug：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for i range(len(alist)):
    print alist[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for item in alist:
    print item
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;不恰当使用range的理由：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要在循环中使用索引：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for index, value in enumerate(alist):
    print index, value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要同时迭代两个循环：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for word, number in zip(words, numbers):
    print word, number
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要迭代序列的一部分：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for word in words[1:]: # 不包括第一个元素
    print word
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;range的正确用法是生成一个数字序列，而不是生成索引：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# Print foo(x) for 0&amp;lt;=x&amp;lt;5
for x in range(5):
    print foo(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. 变量泄漏&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;for idx, value in enumerate(y):
    if value &amp;gt; max_value:
        break

processList(y, idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当y为空，processList将会抛出异常，原因是idx没有定义。&lt;/p&gt;

&lt;p&gt;正确的处理方式：&lt;strong&gt;哨兵模式&lt;/strong&gt;，在循环前为idx设置一些特殊的值。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;idx ＝ None
for idx, value in enumerate(y):
    if value &amp;gt; max_value:
        break

if idex:
    processList(y, idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外作用域&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import sys

# See the bug in the function declaration?
def print_file(filenam):
    &amp;quot;&amp;quot;&amp;quot;Print every line of a file.&amp;quot;&amp;quot;&amp;quot;
    with open(filename) as input_file:
        for line in input_file:
            print line.strip()

if __name__ == &amp;quot;__main__&amp;quot;:
    filename = sys.argv[1]
    print_file(filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;此时函数定义中的参数被错误的写为filenam，但是程序依然可以运行。因为print_file的外部作用域存在一个filename的变量。&lt;/p&gt;

&lt;p&gt;正确的做法：&lt;strong&gt;外部作用域的全局变量命名要明显&lt;/strong&gt;，例如IN_ALL_CAPS。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3. 循环的数据结构导致循环&lt;/h3&gt;

&lt;p&gt;如果在一个对象中发现一个循环，python会输出一个[...]。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mylist ＝ ［&amp;#39;test&amp;#39;]
mylist.append(mylist)
#此时会打印[&amp;#39;test&amp;#39;,[...]]
print mylist
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;4. 赋值创建引用&lt;/h3&gt;

&lt;p&gt;python中赋值语句不会创建对象副本,只会创建引用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;arr = [1, 2, 3, 4]
arr_cp = arr
arr_cp[0] = 100
#print打印出[100, 2, 3, 4]
print arr
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;5. 静态识别局部变量&lt;/h3&gt;

&lt;p&gt;python默认将一个在函数中赋值的变量名视为局部变量，存在于该函数的作用域并当函数运行时才存在。python是在编译def代码时去静态识别局部变量的。&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;a ＝ 100

＃你可能想先打印a的值，再对a的值进行修改
def myfunc():
    print a
    a = 200
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为在预编译的时候python发现函数中对a有赋值，因此把a当作局部变量。而运行到‘print a’语句的时候，局部变量a尚未赋值，因此会报错。&lt;/p&gt;

&lt;p&gt;正确的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;a ＝ 100

def myfunc():
    global a
    print a
    a = 200
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;更隐晦的错误代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;myVar = 1

def myfunc():
    myVar += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;myVar += 1&lt;/code&gt;其实相当于&lt;code&gt;myVar = myVar + 1&lt;/code&gt;，python检测到myVar变量有赋值操作，因此将myVar添加到局部命名空间中。当执行到&lt;code&gt;myVar += 1&lt;/code&gt;时会读取myVar的值，此时该变量尚未有值关联，因此会报错。&lt;/p&gt;

&lt;h3&gt;6. 默认参数&lt;/h3&gt;

&lt;p&gt;在执行def语句时，默认参数的值只被解析并保存一次。因此在修改可变的默认变量时可能会出现意想不到的效果。&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def saver(x=[]):
    x.append(1)
    print x

saver() # 打印[1]
saver() # 打印[1,1]
saver() # 打印[1,1,1]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为默认参数只被解析并保存一次。因此可变的默认参数在每次函数调用都会保存状态。&lt;/p&gt;

&lt;p&gt;正确的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def saver(x=None):
    if x is None: x = []
    x.append(1)
    print x
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;def是python中的可执行语句。默认参数在def的语句环境里被计算。如果你执行了def语句多次，每次它都将会创建一个新的函数对象。&lt;/p&gt;

&lt;p&gt;看看stackoverflow的一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;flist = []

for i in xrange(3):
    def func(x): return x * i
    flist.append(func)

for f in flist:
    print f(2) ＃expect 0 2 4 but print 4 4 4
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们可以借助默认参数的机制，在执行def时解析默认参数的值：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;flist=[]
for i in xrange(3):
    def func(x,i=i): return x*i
    flist.append(func)

for f in flist:
    print f(2)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;默认参数还可以用来做缓存：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def calculate(a, b, c, memo={}):
    try:
        value = memo[a, b, c] # return already calculated value
    except KeyError:
        value = heavy_calculation(a, b, c)
    memo[a, b, c] = value # update the memo dictionary
    return value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;牢记：当Python执行一条def语句时， 它会使用已经准备好的东西（包括函数的代码对象和函数的上下文属性），创建了一个新的函数对象。同时，计算了函数的默认参数值。&lt;/p&gt;

&lt;h3&gt;7. 谨慎使用super()&lt;/h3&gt;

&lt;p&gt;原文&lt;a href=&quot;https://fuhm.net/super-harmful/&quot;&gt;Python&amp;#39;s Super is nifty, but you can&amp;#39;t use it&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者提出两个观点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;People omit calls to super(...).&lt;strong&gt;init&lt;/strong&gt; if the only superclass is &amp;#39;object&amp;#39;, as, after all, object.&lt;strong&gt;init&lt;/strong&gt; doesn&amp;#39;t do anything! However, this is very incorrect. Doing so will cause other classes&amp;#39; &lt;strong&gt;init&lt;/strong&gt; methods to not be called.&lt;/li&gt;
&lt;li&gt;People think they know what arguments their method will get, and what arguments they should pass along to super. This is also incorrect.
先看第二点，比较好理解，代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class A(object):
    def __init__(self):
        print &amp;quot;A&amp;quot;
        super(A, self).__init__()

class B(object):
    def __init__(self):
        print &amp;quot;B&amp;quot;
        super(B, self).__init__()

class C(A):
    def __init__(self, arg):
        print &amp;quot;C&amp;quot;,&amp;quot;arg=&amp;quot;,arg
        super(C, self).__init__()

class D(B):
    def __init__(self, arg):
        print &amp;quot;D&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(D, self).__init__()

class E(C,D):
    def __init__(self, arg):
        print &amp;quot;E&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(E, self).__init__(arg)

print &amp;quot;MRO:&amp;quot;, [x.__name__ for x in E.__mro__]
E(10)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;看着很正确，执行下报错：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]
E arg= 10
C arg= 10
A

Traceback (most recent call last):
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 27, in &amp;lt;module&amp;gt;
    E(10)
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 24, in __init__
    super(E, self).__init__(arg)
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 14, in __init__
    super(C, self).__init__()
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 4, in __init__
    super(A, self).__init__()
TypeError: __init__() takes exactly 2 arguments (1 given)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;原因是：MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]，A的下一个是D，因此super(A, self)方法调用的是D的&lt;strong&gt;init&lt;/strong&gt;方法，D的&lt;strong&gt;init&lt;/strong&gt;方法需要一个参数，因此报错了。&lt;/p&gt;

&lt;p&gt;再看第一点，如果父类是object的话，不调用super().&lt;strong&gt;init&lt;/strong&gt;可能会导致问题，例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class A(object):
    def __init__(self, *args, **kwargs):
        print &amp;quot;A&amp;quot;
        #super(A, self).__init__(*args, **kwargs) 注释掉

class B(object):
    def __init__(self, *args, **kwargs):
        print &amp;quot;B&amp;quot;
        #super(B, self).__init__(*args, **kwargs) 注释掉

class C(A):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;C&amp;quot;,&amp;quot;arg=&amp;quot;,arg
        super(C, self).__init__(arg, *args, **kwargs)

class D(B):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;D&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(D, self).__init__(arg, *args, **kwargs)

class E(C,D):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;E&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(E, self).__init__(arg, *args, **kwargs)

print &amp;quot;MRO:&amp;quot;, [x.__name__ for x in E.__mro__]
E(10)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]
E arg= 10
C arg= 10
A
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;可以发现D和B都没有输出，也就是说如果没有调用父类为object类的super.&lt;strong&gt;init&lt;/strong&gt;()，会导致其他类（在本例中为D和B）的&lt;strong&gt;init&lt;/strong&gt;()不执行。按理来说，调用了类E的super.&lt;strong&gt;init&lt;/strong&gt;()函数，应该会同时调用E的父类C和D的&lt;strong&gt;init&lt;/strong&gt;()函数。但是由于MRO是以super()调用来驱动的，上诉例子中，执行到A时，由于没有调用super的init()函数了，因此整个链路就停了。
总结：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;* 一定要调用父类为object的类的super.__init__()函数
* 调用的super()返回不一定是父类，因此super调用最好保持参数一致
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;另附一篇也是关于super的文章&lt;a href=&quot;http://rhettinger.wordpress.com/2011/05/26/super-considered-super/&quot;&gt;Python’s super() considered super!&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;8. string转换为dict&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;str = ‘{ &amp;quot;key&amp;quot; : null}&amp;#39;
mydict = eval(str)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;eval 可能会报错，因为 json 的语义跟 Python 的 dict 不完全一样, 如果 json 串里面出现一个 null 就报错了.
因此合适的方法是采用如下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;json.loads()
mydict = json.loads(str)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;高级特性&lt;/h2&gt;

&lt;h3&gt;1. 闭包&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def return_func_that_prints_list(z):
    def f():
        print z
    return f

z = [1, 2]
g = return_func_that_prints_list(z)
g()  # print [1, 2]

z.append(3)
g()  # print [1, 2, 3]
z = [1]
g()  # print [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;【译者】：z.append(3)时，g()内部的引用和z仍然指向一个变量，而z=[1]之后，两者就不再指向一个变量了。&lt;/p&gt;

&lt;p&gt;关于闭包，stack overflow &lt;a href=&quot;http://stackoverflow.com/questions/4020419/closures-in-python&quot;&gt;http://stackoverflow.com/questions/4020419/closures-in-python&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2. wraps&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;给decorator加上wraps以保留原有函数的名称和docstring：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from functools import wraps
def my_decorator(f):
    @wraps(f)
    def wrapper(*args, **kwds):
        print &amp;#39;Calling decorated function&amp;#39;
        return f(*args, **kwds)
    return wrapper


@my_decorator
def example():
    &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
    print &amp;#39;Called example function&amp;#39;

example()  # print &amp;#39;Calling decorated function&amp;#39; &amp;#39;Called example function&amp;#39;
example.__name__  # print &amp;#39;example&amp;#39;
example.__doc__  # print &amp;#39;Docstring&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Without the use of this decorator factory, the name of the example function would have been &amp;#39;wrapper&amp;#39;, and the docstring of the original example() would have been lost.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3. class decorator&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;给类的所有函数添加decorator：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def logged(time_format, name_prefix=&amp;quot;&amp;quot;):
    def decorator(func):
        if hasattr(func, &amp;#39;_logged_decorator&amp;#39;) and func._logged_decorator:
            return func

        @wraps(func)
        def decorated_func(*args, **kwargs):
            start_time = time.time()
            print &amp;quot;- Running &amp;#39;%s&amp;#39; on %s &amp;quot; % (
                                            name_prefix + func.__name__,
                                            time.strftime(time_format)
                                )
            result = func(*args, **kwargs)
            end_time = time.time()
            print &amp;quot;- Finished &amp;#39;%s&amp;#39;, execution time = %0.3fs &amp;quot; % (
                                            name_prefix + func.__name__,
                                            end_time - start_time
                                )

            return result
        decorated_func._logged_decorator = True
        return decorated_func
    return decorator

def log_method_calls(time_format):
    def decorator(cls):
        for attr in dir(cls):
            if attr.startswith(&amp;#39;__’): #过滤掉以双下划线开头的attributes
                continue
            a = getattr(cls, attr)
            if hasattr(a, &amp;#39;__call__’): #如果包含__call__属性，说明是函数
                decorated_a = logged(time_format, cls.__name__ + &amp;quot;.&amp;quot;)(a)
                setattr(cls, attr, decorated_a)
        return cls
    return decorator

@log_method_calls(&amp;quot;%b %d %Y - %H:%M:%S&amp;quot;)
class A(object):
    def test1(self):
        print &amp;quot;test1&amp;quot;

@log_method_calls(&amp;quot;%b %d %Y - %H:%M:%S&amp;quot;)
class B(A):
    def test1(self):
        super(B, self).test1()
        print &amp;quot;child test1&amp;quot;

    def test2(self):
        print &amp;quot;test2&amp;quot;

b = B()
b.test1()
b.test2()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- Running &amp;#39;B.test1&amp;#39; on Jul 24 2013 - 14:15:03
- Running &amp;#39;A.test1&amp;#39; on Jul 24 2013 - 14:15:03
test1
- Finished &amp;#39;A.test1&amp;#39;, execution time = 0.000s
child test1
- Finished &amp;#39;B.test1&amp;#39;, execution time = 1.001s
- Running &amp;#39;B.test2&amp;#39; on Jul 24 2013 - 14:15:04
test2
- Finished &amp;#39;B.test2&amp;#39;, execution time = 2.001s
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;4. descriptor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用法1：Type Checking&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&amp;#39;Expected &amp;#39; + str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]


# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Finally, it should be stressed that you would probably not write a descriptor if you simply want to customize the access of a single attribute of a specific class. Descriptors are more useful in situations where there will be a lot of code reuse (i.e., you want to use the functionality provided by the descriptor in hundreds of places in your code or provide it as a library feature).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用法2：Lazily Computed Properties&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class lazyproperty:
    def __init__(self, func):
        self.func = func
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;If a descriptor only defines a &lt;strong&gt;get&lt;/strong&gt;() method, it has a much weaker binding than usual. In particular, the &lt;strong&gt;get&lt;/strong&gt;() method only fires if the attribute being accessed is not in the underlying instance dictionary.&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Jul 2016 18:56:31 +0800</pubDate>
        <link>http://masutangu.com/2016/07/python-note-1/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/python-note-1/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>matplotlib配置支持中文</title>
        <description>&lt;p&gt;这篇文章介绍linux下如何配置&lt;a href=&quot;http://matplotlib.org/&quot;&gt;matplot&lt;/a&gt;来支持中文显示。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确定系统已有哪些支持中文字体&lt;/p&gt;

&lt;p&gt;linux下运行 &lt;code&gt;fc-list :lang=zh&lt;/code&gt; 命令会输出所有支持中文的字体。
如果为空，可以按如下步骤添加：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  拷贝一份window &lt;code&gt;C:\windows\fonts\&lt;/code&gt; 目录下的任一中文字体文件，例如 &lt;code&gt;MSYH.ttc&lt;/code&gt; （微软雅黑）&lt;/li&gt;
&lt;li&gt;  重命名为MSYH.ttf，并放到linux的 &lt;code&gt;/usr/share/fonts/chinese/&lt;/code&gt;目录下 &lt;/li&gt;
&lt;li&gt;  linux下执行 &lt;code&gt;fc-cache /usr/share/fonts/chinese&lt;/code&gt; 清空字体缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改matplotlibrc配置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  打开python安装目录下的 &lt;code&gt;lib/site-packages/matplotlib/mpl-data/matplotlibrc&lt;/code&gt; 文件，将 &lt;code&gt;font.family&lt;/code&gt; 和 &lt;code&gt;font.sans-serif&lt;/code&gt; 这两行开头的注释删掉，并在 &lt;code&gt;font.sans-serif&lt;/code&gt; 这行添加 &lt;code&gt;Microsoft YaHei&lt;/code&gt; (或系统支持的其他中文字体）&lt;/li&gt;
&lt;li&gt;  删除 &lt;code&gt;~/.cache/matplotlib&lt;/code&gt; 缓存目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改python代码，指定使用中文字体&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    from matplotlib import rcParams
    rcParams[&amp;#39;font.sans-serif&amp;#39;] = [&amp;#39;Microsoft YaHei&amp;#39;]  
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Done!&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 08:06:35 +0800</pubDate>
        <link>http://masutangu.com/2016/07/matplot-support-chinese/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/matplot-support-chinese/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>Tcpcopy源码阅读</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/session-replay-tools/tcpcopy&quot;&gt;tcpcopy&lt;/a&gt;是网易开源的一款压测工具，可以实时复制线上流量到测试环境，从而利用线上真实的用户流量来对测试环境进行仿真压测。
由于网上关于tcpcopy的介绍并不多，我对tcpcopy的原理也很感兴趣。因此在学习其源码后写下这篇文章和大家分享。这里非常感谢tcpcopy的作者王斌老师的热心指导。&lt;/p&gt;

&lt;h1&gt;架构&lt;/h1&gt;

&lt;p&gt;第一种架构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现原理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从数据链路层捕获客户端的请求包，修改目的IP地址为压测机器，再从IP层发送出去。&lt;/li&gt;
&lt;li&gt;从数据链路层捕获压测机器的响应包，保持tcp会话的状态（seq number，ack number等），以此来欺骗压测机器的TCP协议栈。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图解： 
&lt;img src=&quot;/assets/images/read-tcpcopy-source-code/illustration-1.png&quot; width=&quot;800&quot; /&gt;
&lt;img src=&quot;/assets/images/read-tcpcopy-source-code/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局限：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只支持同一网段：tcpcopy通过网卡的混杂模式来抓包，因此除非在路由设备上设置强制路由，否则响应包无法回到tcpcopy的机器。&lt;/li&gt;
&lt;li&gt;难以支持多台现网机器流量复制：把在线请求包导到压测机器进行压测的关键在于欺骗压测机器的TCP协议栈，因此我们需要在tcpcopy的进程捕获压测机器的响应包，保存相关字段来维持和压测机器之间会话的状态。如果有多个tcpcopy机器，那压测机器需要维护多个tcpcopy机器的请求包关系，才能把响应包回给响相应的tcpcopy机器，只有当tcpcopy机器能正常收到压测机器的响应包，才能维护正确的TCP会话状态。而目前的架构压测机器无法得知请求包来自哪个tcpcopy机器，自然也没办法将响应包回给正确的tcpcopy机器。
为什么不把请求包的源IP替换成tcpcopy机器的IP呢？这样压测机器就能把响应包准确回复给相应的tcpcopy的机器。但如果这样的话，由于tcpcopy机器并没有监听该端口，会发送reset包给压测机器，连接将被断开，压测也无法进行下去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;流程&lt;/h1&gt;

&lt;p&gt;截获客户端请求包的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 如果是SYN/RST包，转发一份到压测机器。&lt;/li&gt;
&lt;li&gt; 如果是FIN包，判断下之前的数据包压测机器是否已经确认，如果都确认了，就转发FIN包给压测机器，如果还有没确认的，则先把FIN包保存下来。&lt;/li&gt;
&lt;li&gt; 如果是普通数据包，如果当前是SYN_SENT状态，则先保存到unsend列表里，否则转发到压测机器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;截获压测机器响应包的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 如果是reset包，设置reset_flag为true。&lt;/li&gt;
&lt;li&gt; 如果不是ack包，不需要处理。&lt;/li&gt;
&lt;li&gt; 保存响应包的ack_seq到virtual_ack字段。&lt;/li&gt;
&lt;li&gt; 如果是SYN包，更新virtual_next_sequence字段的值为响应包的seq number加1，更新virtual_status为SYN_CONFIRM，三次握手完成，将unsend的数据包（如果有）转发给压测机器。&lt;/li&gt;
&lt;li&gt; 如果是FIN包，更新virtual_status为SERVER FIN，更新virtual_next_sequence字段的值为响应包的seq number加1。如果有fin_ack_packge，则将该fin_ack_package发送给压测机器。&lt;/li&gt;
&lt;li&gt; 如果是数据包，根据头部的信息更新virtual_next_sequence。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;源码细节&lt;/h1&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;struct session_st {
    uint32_t virtual_next_sequence; //下个要发送的segment的ack sequence number
    uint32_t virtual_ack; //收到segment的ack sequence number
    uint16_t virtual_status; //当前状态：Client Fin, Server Fin, SYN_CONFIRM, SYN_SENT
    uint32_t client_next_sequence; //下个要发送的segment的sequence number
    uint16_t client_window; // 窗口大小
    uint16_t client_ip_id ;  //包的序列号
    unsigned char *fin_ack_package; //fin ack包
    bool     reset_flag; //是否重置
    dataContainer unsend; //segment缓存队列
｝


int main(int argc ,char **argv)
{
    ...
    //创建收发二层（链路层）报文的raw socket，链路层抓包
    int sock = socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));

    //创建收发三层（IP层）报文的raw socket，IP层转发包
    send_init();
    while(1)
    {
      //在链路层捕获到客户端请求包或压测机器的回包时，由process函数处理
      int recv_len = recvfrom(sock,recvbuf,2000,0,NULL,NULL);
      process(recvbuf,recv_len);
    }
    return 0;
}

void process(char *packet,int len)
{
    struct etharp_frame *ether = (struct etharp_frame *)packet;
    ...
    //判断以太网报文的类型是不是IP
    if(ntohs(ether-&amp;gt;type) != 0x800){
      return;
    }
    ip_header = (struct iphdr*)(packet+sizeof(struct etharp_frame ) );
    //判断是不是TCP
    if(ip_header-&amp;gt;protocol != IPPROTO_TCP)
    {
      return ;
    }

    size_ip = ip_header-&amp;gt;ihl*4; //获取ip头部的大小
    tcp_header = (struct tcphdr*)((char *)ip_header+size_ip); 
    size_tcp = tcp_header-&amp;gt;doff*4; //获取tcp头部的大小


    if( (ip_header-&amp;gt;saddr==remote_ip) &amp;amp;&amp;amp; (tcp_header-&amp;gt;source==remote_port) )
    {
        //如果是压测机器的回包，由update_virtual_status函数处理
        seIterator iter = sessions.find(get_ip_port_value(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest));
        if(iter != sessions.end())
        {
            iter-&amp;gt;second.update_virtual_status(ip_header,tcp_header);
            if( iter-&amp;gt;second.is_over())
            {
              sessions.erase(iter);
            }
        }
    }
    else if( (ip_header-&amp;gt;daddr==local_ip) &amp;amp;&amp;amp; (tcp_header-&amp;gt;dest==local_port))
    {
        //如果是客户端请求包，由process_recv函数处理
        if(tcp_header-&amp;gt;syn)
        {
          sessions[get_ip_port_value(ip_header-&amp;gt;saddr,tcp_header-&amp;gt;source)].process_recv(ip_header,tcp_header);
        }
        else
        {
            seIterator iter = sessions.find(get_ip_port_value(ip_header-&amp;gt;saddr,tcp_header-&amp;gt;source));
            if(iter != sessions.end())
            {
                iter-&amp;gt;second.process_recv(ip_header,tcp_header);
                if ((iter-&amp;gt;second.is_over()))
                {
                    sessions.erase(iter);
                }
            }
        }
    }
}

void session_st::update_virtual_status(struct iphdr *ip_header,struct tcphdr* tcp_header)
{
    if( !(tcp_header-&amp;gt;ack))
    {
        return; //不是ack不处理
    }
    //记录压测机器回包的ack seq number
    virtual_ack = tcp_header-&amp;gt;ack_seq;
    //处理syn包
    if( tcp_header-&amp;gt;syn)
    {
        //virtual_next_sequence加1
        virtual_next_sequence = plus_1(tcp_header-&amp;gt;seq);
        virtual_status |= SYN_CONFIRM;
        //如果缓存队列有未发送的包，则转发到压测机器
        while(! unsend.empty())
        {
          unsigned char *data = unsend.front();
          send_ip_package(data, virtual_next_sequence);
          free(data);
          unsend.pop_front();
        }
        return;
    }
    //处理fin包
    else if(tcp_header-&amp;gt;fin)
    {
        virtual_status  |= SERVER_FIN;
        //virtual_next_sequence加1
        virtual_next_sequence = plus_1(tcp_header-&amp;gt;seq);
        //如果有保存fin_ack_package，则发送出去。
        if(fin_ack_package)
        {
            send_ip_package(fin_ack_package,virtual_next_sequence);
        }
        return;
    }
    uint32_t tot_len = ntohs(ip_header-&amp;gt;tot_len);
    uint32_t next_seq = htonl(ntohl(tcp_header-&amp;gt;seq)+tot_len-ip_header-&amp;gt;ihl*4-tcp_header-&amp;gt;doff*4);

    if(ntohl(next_seq) &amp;lt; ntohl(virtual_next_sequence))
    {
        //如果next_seq小于virtual_next_sequence，意味着之前给压测机器的ack包丢了，重新发送ack包
        send_fake_ack(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest);
    }
    else if(ntohl(next_seq)==ntohl(virtual_next_sequence))
    {
        //has data
        if(tot_len != ip_header-&amp;gt;ihl*4+tcp_header-&amp;gt;doff*4)
        {
            //同上，ack包丢了，重发
            send_fake_ack(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest);
        }
    }
    else
    {
        virtual_next_sequence = next_seq;
    }

    /* 如果收到客户端的fin包，但压测机器还有回包没有ack，就会把客户端的fin包保存在fin_ack_package。当virtual_ack等于client_next_sequence，意味着服务器已经确认了所有数据，如果fin_ack_package不为空，意味着客户端没有数据要发送了，因此将之前保存的fin包发送给压测机器。
    */
    if(virtual_ack == client_next_sequence)
    {
        if(fin_ack_package)
        {
            send_ip_package(fin_ack_package,virtual_next_sequence);
            virtual_status |= CLIENT_FIN;
            confirmed = true;
        }
    }
}

void session_st::process_recv(struct iphdr *ip_header,struct tcphdr *tcp_header)
{
    //syn包
    if(tcp_header-&amp;gt;syn)
    {
      send_ip_package((unsigned char *)ip_header,virtual_next_sequence);
      return;
    }
    //fin包
    if(tcp_header-&amp;gt;fin)
    {
        //virtual_ack等于tcp_header-&amp;gt;seq表示压测机器已经ack了所有请求数据
        if(virtual_ack == tcp_header-&amp;gt;seq)
        {
            send_ip_package((unsigned char *)ip_header,virtual_next_sequence);
            virtual_status |= CLIENT_FIN;
            return;
        }
        else
        { 
            //如果压测机器还有未确认的请求包，则先保存客户端的fin包
            fin_ack_package = copy_ip_package(ip_header);
        }
        return;
    }
    //更新client_next_sequence    
    save_header_info(ip_header,tcp_header);
    //如果三次握手还没完成，先将数据包压入缓存队列
    if(virtual_status == SYN_SEND)
    {
        unsend.push_back(copy_ip_package(ip_header));
    }
    else
    {
        //否则直接转发给压测机器
        send_ip_package((unsigned char *)ip_header,virtual_next_sequence); 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 05 May 2016 10:00:25 +0800</pubDate>
        <link>http://masutangu.com/2016/05/read-tcpcopy-source-code/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/05/read-tcpcopy-source-code/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>iOS初体验</title>
        <description>&lt;p&gt;客户端对做后端的我来说，一直是黑盒子般。自从换了Mac，就寻思着什么时候学习学习iOS开发。这几个月断断续续花了时间，先是看了Stanford的cs193p课程，后来又读了&amp;lt;iOS Programming The Big Nerd Ranch Guide&amp;gt;,最后写了个非常简单的App：&lt;a href=&quot;https://github.com/Masutangu/ToDo&quot;&gt;ToDo&lt;/a&gt;。今天这里分享下iOS一些学习笔记，素材取自cs193p的ppt，apple的开发者文档。鉴于我现在iOS水平有限，写得比较浅，大家请见谅。&lt;/p&gt;

&lt;h1&gt;What’s in iOS?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-1.png&quot; alt=&quot;iOS架构图&quot; title=&quot;iOS架构图&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS处于底层硬件和app的中间。iOS的整体架构可以划分为四层：Core OS, Core Services, Media, Cocoa Touch&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Core OS: Contains the low-level features that most other technologies are built upon. Include：OSX Kernel, Mach 3.0, BSD, Sockets, Security, Power Management, Keychain Access, Certificates, File System, Bonjour&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core Services: Contains fundamental system services for apps. This layer also contains individual technologies to support features such as location, iCloud, social media, and networking. Include：Collections, Address Book, Networking, File Access, SQLite, Core Location, Net Services, Threading, Preferences, URL Utilities. 我理解是在Core OS基础上封装了一层接口。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Media: Contains the graphics, audio, and video technologies you use to implement multimedia experiences in your apps. Include：Core Audio，OpenAL, Audio Mixing, Audio Recording, Video Playback, OpenGL ES, Core Animation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cocoa Touch: Contains key frameworks for building iOS apps. These frameworks define the appearance of your app. They also provide the basic app infrastructure and support for key technologies such as multitasking, touch-based input, push notifications, and many high-level system services. Include: Multi-Touch, Core Motion, View Hierarchy, Localization, Controls, Alerts, Web View, Map Kit, Image Picker, Camera.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;MVC&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-2.png&quot; alt=&quot;MVC&quot; title=&quot;MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;: What your application is (but not how it is displayed)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;: How your Model is presented to the user (UI logic)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;:  Your Controller’s minions&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用程序的逻辑应该放在Model而不是Controller，因为&lt;strong&gt;Model = What your application is&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;MVC之间的关系&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-3.png&quot; alt=&quot;MVC关系&quot; title=&quot;MVC关系&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Controller可以直接访问Model和View（outlet）&lt;/li&gt;
&lt;li&gt;Model和View是完全隔离开的&lt;/li&gt;
&lt;li&gt;View通过protocol的方式（blind and structured）访问Controller，包括：&lt;strong&gt;target-action&lt;/strong&gt;方式，&lt;strong&gt;delegate&lt;/strong&gt;方式和&lt;strong&gt;data source&lt;/strong&gt;方式。&lt;/li&gt;
&lt;li&gt;Model通过&lt;strong&gt;notification&amp;amp;KVO（Key Value Observing）&lt;/strong&gt;将变化通知给Controller&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;多个MVC的组织&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-4.png&quot; alt=&quot;错误方式组织多个MVC&quot; title=&quot;错误方式组织多个MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;错误的做法：不同模块的communication非常杂乱，难以维护。&lt;/em&gt;
&lt;img src=&quot;/assets/images/ios-introduction/illustration-5.png&quot; alt=&quot;正确方式组织多个MVC&quot; title=&quot;正确方式组织多个MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;正确的做法：Using MVC as part of the view of another MVC。划分好模块，不同模块间的communication非常少。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;Objective-C&lt;/h1&gt;

&lt;p&gt;面向对象编程的三个原则是：&lt;strong&gt;基于消息传递机制&lt;/strong&gt;，&lt;strong&gt;对象分离&lt;/strong&gt;和&lt;strong&gt;多态&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Category&lt;/strong&gt;
给已存在的类新增新的方法。
&lt;pre&gt;&lt;code&gt;
//NSObject+HelloWorld.h
@interface NSObject (HelloWorld)&lt;br&gt;
-(void)HelloWorld;&lt;br&gt;
@end&lt;br&gt;
//NSObject+HelloWorld.m
#import &amp;quot;NSObject+HelloWorld.h&amp;quot;&lt;br&gt;
@implementation NSObject (HelloWorld)&lt;br&gt;
-(void)HelloWorld{&lt;br&gt;
    NSLog(@&amp;quot;Hello World!&amp;quot;);&lt;br&gt;
}&lt;br&gt;
@end&lt;br&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Category vs Inheritance&lt;/strong&gt;:
Category用于给一个类新增一个功能，Inheritance用于修改父类的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Category vs Extension&lt;/strong&gt;:
Extension一般用来隐藏类的私有信息，需要有类的源码才能添加Extension。另外Extension可以添加成员变量，而Category不允许。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Introspection&lt;/strong&gt;: Asking at runtime what class an object is or what messages can be sent to it. 
&lt;pre&gt;&lt;code&gt;
&lt;strong&gt;isKindOfClass&lt;/strong&gt;: returns whether an object is that kind of class (inheritance included) 
&lt;strong&gt;isMemberOfClass&lt;/strong&gt;: returns whether an object is that kind of class (no inheritance) 
&lt;strong&gt;respondsToSelector&lt;/strong&gt;: returns whether an object responds to a given method
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protocols&lt;/strong&gt;: A syntax that is “in between” id and static typing. Does not specify the class of an object pointed to, but does specify what methods it implements.
&lt;pre&gt;&lt;code&gt;
//definition file
@protocol Foo
-(void)someMethod;
-(void)methodWithArgument:(BOOL)argument;
@property (readonly) int readonlyProperty; // getter (only) is part of this protocol
@property NSString &lt;em&gt;readwriteProperty; // getter and setter are both in the protocol 
-(int)methodThatReturnsSomething;
@end
//example file
id &lt;Foo&gt; obj = [[MyClass alloc] init];
&lt;/code&gt;&lt;/pre&gt;
Protocols在iOS中的应用包括&lt;/em&gt;&lt;em&gt;delegates&lt;/em&gt;* 和 &lt;strong&gt;dataSources&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;设计模式&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Target-Action&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Cocoa uses the &lt;strong&gt;target-action&lt;/strong&gt; mechanism for communication between a &lt;strong&gt;control&lt;/strong&gt; and another object.  The receiving object—typically an instance of a custom class—is called the &lt;strong&gt;target&lt;/strong&gt;. The &lt;strong&gt;action&lt;/strong&gt; is the message that the control sends to the target.   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Delegation&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Delegation&lt;/strong&gt; is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. The delegating object keeps a reference to the other object—the delegate—and at the appropriate time sends a message to it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Date Source&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;A data source&lt;/strong&gt; is almost identical to a &lt;strong&gt;delegate&lt;/strong&gt;. The difference is in the relationship with the delegating object. Instead of being delegated control of the user interface, a data source is &lt;strong&gt;delegated control of data&lt;/strong&gt;. The delegating object, typically a view object such as a table view, holds a reference to its data source and occasionally asks it for the data it should display.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;KVO&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Key-value observing&lt;/strong&gt; is a mechanism that enables an object to be notified directly when a property of another object changes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;内存管理&lt;/h1&gt;

&lt;p&gt;iOS使用&lt;strong&gt;Automatic Reference Counting&lt;/strong&gt;来做内存管理。ARC在编译期会分析代码，确定对象的生命周期，在相应的位置自动加上retain和release。&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Apr 2016 23:10:00 +0800</pubDate>
        <link>http://masutangu.com/2016/04/ios-introduction/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/04/ios-introduction/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
      <item>
        <title>Python 进程池的坑：Pickling Error!</title>
        <description>&lt;p&gt;前阵子在跑&lt;a href=&quot;https://github.com/Masutangu/Elric&quot;&gt;Elric&lt;/a&gt;下的爬虫任务时，发现了worker进程有偶现的异常挂起的现象，通过strace看到worker进程block在futex(…, FUTEX_WAIT,…)这里，查看了worker的标准输出，发现打印了这么一行东西：&lt;/p&gt;

&lt;p&gt;File “../multiprocessing/queues.py”, line 266, in _feed send(obj) PickingError: can’t pickle &lt;type ‘thread.lock’&gt;: attribute lookup thread.lock failed&lt;/p&gt;

&lt;h1&gt;解决思路&lt;/h1&gt;

&lt;p&gt;接下来就是艰辛的定位问题之旅：&lt;/p&gt;

&lt;p&gt;Step 1：我检查了Elric里面的pickle操作（序列化提交的任务时会使用到pickle），没有发现问题。&lt;/p&gt;

&lt;p&gt;Step 2：因为rpc调用会输出到标准输出，上个版本我刚好在master 新增了一个queue用以缓存没来得及处理的job，因此我也特别检查了这部分代码，也没有发现问题。&lt;/p&gt;

&lt;p&gt;Step 3：从输出到traceback来看，最上层的调用不是我的代码，因此我猜测是进程池fork进程出来后发生的exception，之所以打印到标准输出来是因为这个exception没有被catch。&lt;/p&gt;

&lt;p&gt;Step 4：打算用pdb打断点进行调试，没想到其他比较好的办法。于是我简单粗暴地把queues.py文件拷贝了一份，在第266行的send(obj)设置了断点。把代码里import到的queues文件都替换成我拷贝出来的这份，pdb执行一下，当遇到exception的时候程序就会停住。打印此时的obj，输出&lt;core.my_process._ResultItem object at xxxx&gt;，说明是在进程池往queue里塞进程执行结果的时候，pickle失败了。观察了下_ResultItem的成员，有work_id, exception, result。其中exception和result都有可能包含了thread.lock导致pickle失败。再打印下obj.exception，输出(&lt;request.packages.urllib3.connectionpool.HTTPConnectionPool object at xxxx&gt;, ‘Connection to xxxx timed out.(connect timeoout=3)’)&lt;/p&gt;

&lt;p&gt;看起来有可能是HTTPConnectionPool这个对象无法pickle，验证一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/python-pickling-error/illustration-1.png&quot; alt=&quot;示例1&quot; title=&quot;示例1&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/python-pickling-error/illustration-2.png&quot; alt=&quot;示例2&quot; title=&quot;示例2&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;果然是因为HTTPConnectionPool对象包含了lock导致无法被pickle。&lt;/p&gt;

&lt;p&gt;但是在我自己电脑上验证时，pickle却不会报错。比对了线上环境和自己电脑的requests库版本，线上环境是2.3.0, 自己电脑是2.6.0。应该是requests修改了HTTPConnectionPool的实现，去掉了内部的lock。&lt;/p&gt;

&lt;h1&gt;解决方案&lt;/h1&gt;

&lt;p&gt;在使用python进程池提交任务的时候，注意任务执行可能会抛出一些无法pickle的exception，导致进程池拉取任务执行结果的时候pickle失败。建议是在任务代码中catch所有可能的exception，然后reraise自定义的支持pickle的exception。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;这次定位问题的手段太过简单粗暴，但自己也没想出更好的办法。幸好最终是确定了问题所在。如果大家对于解决该问题有什么建议，欢迎留言或发邮件提出。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Apr 2016 16:07:58 +0800</pubDate>
        <link>http://masutangu.com/2016/04/python-pickling-error/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/04/python-pickling-error/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>使用binlog实时监控Mysql数据更新</title>
        <description>&lt;p&gt;上一篇文章《&lt;a href=&quot;http://masutangu.github.io/blog/2016/02/29/udftrigger%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7mysql%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/&quot;&gt;UDF+Trigger实时监控Mysql数据更新&lt;/a&gt;》介绍了用UDF+Trigger的方式来监控Mysql数据的更新，这次介绍下使用binlog监控数据更新的方法。&lt;/p&gt;

&lt;h1&gt;binlog 简介&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;The binary log is a set of log files that contain information about data modifications made to a MySQL server instance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其主要有以下两个用途：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;主从同步&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据恢复&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mysql主从同步原理 利用binlog来监控mysql数据的更新，以更新缓存。原理类似于mysql的主从同步。先简单介绍下mysql主从同步的原理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Whenever the master’s database is modified, the change is written to a file, the so-called binary log, or binlog. This is done by the client thread that executed the query that modified the database.&lt;/li&gt;
&lt;li&gt;The master has a thread, called the dump thread, that continuously reads the master’s binlog and sends it to the slave.&lt;/li&gt;
&lt;li&gt;The slave has a thread, called the IO thread, that receives the binlog that the master’s dump thread sent, and writes it to a file: the relay log.&lt;/li&gt;
&lt;li&gt;The slave has another thread, called the SQL thread, that continuously reads the relay log and applies the changes to the slave server.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1&gt;利用binlog监听mysql更新&lt;/h1&gt;

&lt;p&gt;我们的目的是监听mysql数据变化，及时更新缓存以保证缓存数据不过期。如果我们模拟Mysql Slave的交互协议，伪装自己为Mysql Slave，向Master发送dump协议，Master收到dump请求，就会推送binary log给我们的伪Slave。接下来解析binlog，把相应的更新同步到缓存就可以了。&lt;/p&gt;

&lt;h1&gt;Python-Mysql-Replication #&lt;/h1&gt;

&lt;p&gt;伪装Mysql Slave，解析binlog都需要对mysql有更深入的了解。为了把精力关注在我们的目标上，这里我选择了一个现有的python库：Python-Mysql-Replication。&lt;/p&gt;

&lt;p&gt;官方给的demo很简单：
&lt;img src=&quot;/assets/images/using-binlog/illustration-1.png&quot; alt=&quot;示例1&quot; title=&quot;示例1&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;dump方法就会把各类event的详细信息都打印出来。我们需要关心的event类型有：DeleteRowsEvent / UpdateRowsEvent / WriteRowsEvent / RotateEvent。&lt;/p&gt;

&lt;p&gt;前三个事件分别对应删除操作／更新操作／新增操作。看看UpdateRowsEvent包含了哪些信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/using-binlog/illustration-2.png&quot; alt=&quot;示例2&quot; title=&quot;示例2&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要关注的信息有date/log position/table/values。log position表示这个event在binlog文件的offset。&lt;/p&gt;

&lt;p&gt;RotateEvent则给出当前使用的binlog的文件名（binlog文件超过指定size时会rotate，这时通过监听RotateEvent就能拿到最新的binlog文件名）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/using-binlog/illustration-3.png&quot; alt=&quot;示例3&quot; title=&quot;示例3&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过RotateEvent提供的binlog文件名，和DeleteRowsEvent / UpdateRowsEvent / WriteRowsEvent等Event附带的log position信息，我们就能记录当前已经处理的binlog的偏移。实际上，Mysql Slave就是通过这种方式来做增量更新的，Slave通过将Relay_Master_Log_File和Exec_Master_Log_Pos这两个字段记录在relay-log.info文件来存储同步的进度。&lt;/p&gt;

&lt;h1&gt;和udf+trigger方式的比较&lt;/h1&gt;

&lt;p&gt;使用udf＋trigger的方式的优点是简单，不足主要如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运维成本高&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有一定开销&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;难以监控trigger的成功率&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用binlog的难点主要是解析比较麻烦，不过现有的各种库很好的帮我们处理了。优点主要如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运维无成本&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对mysql没有什么开销&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于binlog是全库的log，如果需求是监听一两张表的数据更新，建议采用trigger＋udf的方式。而如果监听的表数量较多，那么建议使用binlog的方式。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Mar 2016 16:07:58 +0800</pubDate>
        <link>http://masutangu.com/2016/03/using-binlog/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/03/using-binlog/</guid>
        
        
        <category>数据库</category>
        
      </item>
    
      <item>
        <title>水滴石穿－第三期</title>
        <description>&lt;blockquote&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;http://www.theatlantic.com/technology/archive/2015/07/i-like-instagram/398834/&quot;&gt;Instagram Is the Best Social Network&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者谈他为何觉得Instagram是最好的社交应用，主要是以下三点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单

&lt;ul&gt;
&lt;li&gt;信息简单：Instagram以纯图片的方式传递，没有超链接，没有一大段文字&lt;/li&gt;
&lt;li&gt;操作简单：点赞或者只是浏览。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安静
不打扰用户，用户用完即走。这和之前张小龙演讲提到的观点是一致的。&lt;/li&gt;
&lt;li&gt;无限制社交&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instagram的定位并不是密友社交。并顺带举了path失败的例子，密友社交不是需求，真正的密友社交是一对一的，而不是一个密友圈。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People like social networks because they’re an efficient way of communicating with many others, but, as he said, “efficiency is the enemy of intimacy.”&lt;/p&gt;

&lt;p&gt;“Real intimacy can never, ever be broadcast. It must be either one-to-one or one-off,”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以你在Instagram上看到不同圈子的照片，你可以有自己的解读：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can skip inside jokes. You can miss subtext that pricks someone else’s hearts. You can savor the density of meaning in pictures from close friends and the surface beauty of posts from distant ones.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;http://www.trevormckendrick.com/how-to-choose-a-profitable-niche/&quot;&gt;How To Choose a Profitable Niche&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者提出具备好商机的app有下面三个条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Is profitable
如何确定是否有潜在的利润？作者这块分析的结论没看出来。&lt;/li&gt;
&lt;li&gt; Can be found via App Store search
找到用户搜索的热词，了解用户需求。&lt;/li&gt;
&lt;li&gt;Has crappy competitors
竞争对手比较烂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.trevormckendrick.com/how-i-sold-my-bible-app-company/&quot;&gt;How I Sold my Bible App Company&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;http://thenextweb.com/entrepreneur/2015/06/02/9-daily-habits-of-successful-mobile-app-entrepreneurs/&quot;&gt;9 daily habits of successful mobile app entrepreneurs&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如何做好一个app？可以参考下该文章提出的几个习惯：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Study the App Store：了解用户的评价，排名趋势和排序算法。&lt;/li&gt;
&lt;li&gt;Learn From The Horrible Apps：分析优秀的app和糟糕的app之间的差别。&lt;/li&gt;
&lt;li&gt;Answer Support Calls &amp;amp; Emails (Even as a CEO)：回复咨询电话和邮件：每天花部分时间亲自回复用户的咨询，即使你是ceo。&lt;/li&gt;
&lt;li&gt;Consume Something Inspirational：读些motivational的书，听听ted talk，保持积极向上的心态。&lt;/li&gt;
&lt;li&gt;Write EVERYTHING Down：好记性不如烂笔头。&lt;/li&gt;
&lt;li&gt;Benchmark Your Data：紧盯数据趋势（评分，用户评价等），确保走在正确的方向上。&lt;/li&gt;
&lt;li&gt;Inbox Zero：及时回复邮件。&lt;/li&gt;
&lt;li&gt;Keep a Journal：“I use journaling as a form of therapy and as a way for me to start each day with a clean slate.”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;https://medium.com/@benbrown/slack-is-the-operating-system-6bae1a6c0291#.m8unpie2p&quot;&gt;Slack is the Operating System Slack is the Operating System&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;对于大多数新的app来说，slack是一个操作系统。在slack上运作一个app，它是跨平台的，实时同步的，并且界面一致，对用户友好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Designing for messaging will become a discipline as important as responsive design, and will incorporate skills as diverse as copy writing, business analytics and API programming.&lt;/p&gt;

&lt;p&gt;We’re going to call it Messaging Experience Design, or MXD.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;http://www.trenchant.org/daily/2015/6/3/&quot;&gt;Messaging is the New Web&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Web的优点在于易部署易扩展易分发。而在智能手机兴起的大背景下，Messaging应运而生。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Messaging (in a very broad sense including SMS, texting apps, and things like Slack) present a similar challenge and opportunity today in the context of smartphones.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回复信息/文本会话相比起app来说要轻量得多，比起打开浏览器，输入url再等待页面展示也更近方便。同时登陆认证对于用户来说是透明的，用户不需要额外申请账户，也不需要额外学习新的操作界面。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If integration with Slack is cheap and easy and provides additional distribution for business services, more services will be incentivized to offer it, which in turn makes Slack more valuable for its customers. And when Slack’s customers have a host of services integrated with their Slack instance, the more valuable Slack becomes to them&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;https://medium.com/@paulcolomiets/the-future-of-asynchronous-io-in-python-ce200536d847#.tctyl610p&quot;&gt;The Future of Asynchronous IO in Python&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这篇没怎么看懂，欢迎交流。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;http://blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp&quot;&gt;Making sense of MVP (Minimum Viable Product) — and why I prefer Earliest Testable/Usable/Lovable&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;深度好文！文章最后的总结如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Avoid Big Bang delivery for complex, innovative product development. Do it iteratively and incrementally. You knew that already. But are you actually doing it?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Start by identifying your skateboard — the earliest testable product. Aim for the clouds, but swallow your pride and start by delivering the skateboard.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Avoid the term MVP. Be more explicit about what you’re actually talking about. Earliest testable/usable/lovable is just one example, use whatever terms are least confusing to your stakeholders..&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是精华摘抄：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We start with the same context — the customer ordered a car. But this time we don’t just build a car. Instead we focus on the underlying need the customer wants fulfilled. Turns out that his underlying need is “I need to get from A to B faster”, and Car is just one possible solution to that.&lt;/p&gt;

&lt;p&gt;We might learn some really surprising things. Suppose the customer says he hates the skateboard, we ask why, and he says “I hate the color”. We’re like “uh…. the color? That’s all?”. And the customer says “Yeah, make it blue! Other than that, it’s fine!”. You just saved &lt;em&gt;alot&lt;/em&gt; of money not building the car! Not likely, but who knows?&lt;/p&gt;

&lt;p&gt;The key question is “What is the cheapest and fastest way we can start learning?” Can we deliver something even earlier than a skateboard? How about a bus ticket?&lt;/p&gt;

&lt;p&gt;In most real-life product development scenarios I’ve seen, no matter how much up-front analysis you do, you’re still surprised when you put the first real release into the hands of a real user, and many of your assumptions turn out to be way off.&lt;/p&gt;

&lt;p&gt;Early feedback from real users! Don’t just design the product and build the whole thing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;https://stratechery.com/2014/pleco-building-business-just-app/&quot;&gt;Pleco: Building a Business, not an App&lt;/a&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;What stands out to me about Love’s approach was that from day one his differentiation was not based on design, ease-of-use, or some other attribute we usually glorify in developers. Rather, he focused on decidedly less sexy things like licensing. Sure, licensing is particularly pertinent to a dictionary app, but the broader point is that Love’s sustainable differentiation was not about his own code. Sustainable differentiation never is.&lt;/p&gt;

&lt;p&gt;This is the critical point: developers all want to write an app for themselves, which means everyone has. That’s why there is no money to be made in something like an RSS reader. But there are whole swathes of people out there who have really interesting and specific needs — like Chinese language learning — just waiting for someone who can not only develop, but can also do market research, build a business model, and do all the messystuff upon which true differentiation — and sustainable businesses — are built.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;a href=&quot;http://highscalability.com/blog/2015/7/22/architecting-backend-for-a-social-product.html&quot;&gt;Architecting Backend for a Social Product&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如何设计社交产品的后台架构？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;存储

&lt;ul&gt;
&lt;li&gt;Master Data or Static Form of Data Like User Profile
选择document based storage，推荐mongodb。优点：分布式／高可用／可分库分表。&lt;/li&gt;
&lt;li&gt;Connected or Relational Data 
选择图数据库，推荐Neo4j，但是其不支持分库分表。其他选择：FlockDB, AllegroGraph 和InfiniteGraph。&lt;/li&gt;
&lt;li&gt;Binary data (UGC)
推荐Amazon S3&lt;/li&gt;
&lt;li&gt;Session Data&lt;/li&gt;
&lt;li&gt;用户相关，推荐redis。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;索引
Apache Storm用于实时生成索引。Lucene（性能不够）或SolrCloud做索引系统。&lt;/li&gt;
&lt;li&gt;Queuing &amp;amp; Push Notifications
使用ActiveMQ做队列，push通知可以采用pyapns, CommandIQ 或App Booster。&lt;/li&gt;
&lt;li&gt;缓存策略

&lt;ul&gt;
&lt;li&gt;Application Level Caching (Content Cache)
redis。&lt;/li&gt;
&lt;li&gt;Proxy Cache
Nginx 或ATS。&lt;/li&gt;
&lt;li&gt;Second Level Cache (Code Level Caching)
EhCache。&lt;/li&gt;
&lt;li&gt;Client Cache
客户端做缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输协议
http客户端采用OkHttp，消息传输采用MQTT。&lt;/li&gt;
&lt;li&gt;安全
All our user data must be encrypted
&amp;gt; MongoDB and Neo4j already supports Storage Encryption. On case basis we can decide to encrypt key user information. Transport Encryption must be enabled for all DB related calls.

&lt;ul&gt;
&lt;li&gt;Secure Socket Layer
SSL&lt;/li&gt;
&lt;li&gt;All our api endpoints should be run on non default ports and should implement Oauth without fail&lt;/li&gt;
&lt;li&gt;All reads from DB should happen through rest endpoints always&lt;/li&gt;
&lt;li&gt;The configuration which holds password must be dealt specially&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模块
整个后台架构包括以下模块：

&lt;ul&gt;
&lt;li&gt;Load Balancer：负载均衡&lt;/li&gt;
&lt;li&gt;Proxy Server：处理http请求，包括cache策略&lt;/li&gt;
&lt;li&gt;Ingestion Engine：处理输入数据，包括缓存，转码，压缩&lt;/li&gt;
&lt;li&gt;REST Server: 访问db&lt;/li&gt;
&lt;li&gt;Event Processor: 从ActiveMQ读取消息并通过notification engine生成push通知。&lt;/li&gt;
&lt;li&gt;Recommendation Engine: 根据用户操作，做些推荐相关的算法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;http://engineering.skybettingandgaming.com/2016/02/02/how-we-release-so-frequently/&quot;&gt;How We Release So Frequently How We Release So Frequently&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;如何快速发布？作者提了下面几个快速发布的准则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Forward-only Migrations
不允许回滚数据库的Migrations。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Take dropping a column as an example; how do you release that change? Easy:
Release a version of the code that doesn’t use that column; ensure it is stable / won’t be rolled back.
Do a second release that has a migration to remove the column.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;New Code != New Features
用户应该对你代码的发布无感知。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It’s a really bad experience for customers to see a new feature appear, start using it, and then have it disappear a few minutes later as a release is rolled back — possibly for unrelated reasons&lt;/p&gt;

&lt;p&gt;Every new feature is first released in a hidden state, ready to be turned on with a ‘feature toggle’.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are some really strong plus points to this approach:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We don’t have to roll back a whole release (which may contain several changes) just because a single new feature isn’t working&lt;/li&gt;
&lt;li&gt;We can fully test new features in an environment that has the exact hardware, software and data we need&lt;/li&gt;
&lt;li&gt;We can release new features to customers gradually&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文中介绍了利用session和cookie来实现灰度升级，有兴趣可以仔细阅读下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Small Releases
The more often we release, the smaller the releases can be. Smaller releases carry less risk, letting us release even more often.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 08 Mar 2016 12:42:43 +0800</pubDate>
        <link>http://masutangu.com/2016/03/dewdrop-note-3/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/03/dewdrop-note-3/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>UDF+Trigger实时监控Mysql数据更新</title>
        <description>&lt;p&gt;最近在做缓存相关的事情，需要在mysql的上层架一层缓存，以缓解mysql的压力，简单的架构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/using-udf-plus-trigger/illustration-1.png&quot; alt=&quot;示例1&quot; title=&quot;示例1&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家都知道，缓存带来性能上的提高，然而却有数据不一致的可能。比方说修改了mysql的数据，但是用户读取到的缓存数据还未更新，这时就会有不一致的问题。&lt;/p&gt;

&lt;p&gt;这样就需要一种机制来监控mysql中数据的变化以更新缓存：
&lt;img src=&quot;/assets/images/using-udf-plus-trigger/illustration-2.png&quot; alt=&quot;示例2&quot; title=&quot;示例2&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;方案&lt;/h1&gt;

&lt;p&gt;有两种办法可以实时监控mysql，一是利用mysql的binlog，二是利用mysql的trigger。这篇文章主要介绍trigger的方式。&lt;/p&gt;

&lt;p&gt;trigger可以在特定事件发生时触发指定的操作，因此可以用trigger来监听insert/update/delete操作。再利用udf，我们就能将这些事件通知到同步server，再由同步server更新缓存中已经过时的数据。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;关于udf的介绍：
&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/adding-udf.html&quot;&gt;http://dev.mysql.com/doc/refman/5.7/en/adding-udf.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如何编写udf：&lt;a href=&quot;http://blog.loftdigital.com/blog/how-to-write-mysql-functions-in-c&quot;&gt;http://blog.loftdigital.com/blog/how-to-write-mysql-functions-in-c&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里我使用了mysql-udf-http，它是开源的UDF，提供了利用HTTP协议进行REST操作的能力。&lt;/p&gt;

&lt;p&gt;安装完成后，创建trigger如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/using-udf-plus-trigger/illustration-3.png&quot; alt=&quot;示例3&quot; title=&quot;示例3&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建trigger成功后，如果在posts表有insert操作，就会发一个http put请求到指定ip和端口上；如果有delete操作，就会发送一个http delete请求到指定的ip和端口上。&lt;/p&gt;

&lt;p&gt;这样我们只需要搭建一个http同步server，等待接收触发trigger调用udf发送的http请求，并更新相应的缓存就可以了。&lt;/p&gt;

&lt;p&gt;如果你担心trigger是比较昂贵的操作，你可以在mysql的从库上创建trigger，该从库不对外服务，只用于监控数据更新。&lt;/p&gt;

&lt;h1&gt;不足&lt;/h1&gt;

&lt;p&gt;使用trigger＋udf虽然方便，不过需要手动为监听的每张表创建trigger。另外处理trigger事件的同步server只能使用单进程模型，不然无法保证同步的顺序。但是单进程的效率又太低了。&lt;/p&gt;

&lt;h1&gt;一点联想&lt;/h1&gt;

&lt;p&gt;实现监控mysql数据更新这个功能的过程中，我对设计数据库表结构也有一点启发：在设计表的时候，需要做到&lt;strong&gt;动静分离&lt;/strong&gt;。把静态的（不常更新的）数据放在一张表，而把动态的（经常更新的）数据放在另外的表。&lt;/p&gt;

&lt;p&gt;比如说：我们把专辑的信息放一张表，把专辑的订阅数／粉丝数／播放量放另外的表。这样我们只需要监控专辑信息表，及时更新缓存就可以了。&lt;/p&gt;

&lt;p&gt;相反的，如果我们把订阅数等和专辑信息表放在一起，由于订阅数经常会变，我们要么得写一个复杂的trigger监听某几个字段的更新（不清楚能否实现），要么需要在同步server做逻辑判断，非常的繁琐。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Feb 2016 16:07:58 +0800</pubDate>
        <link>http://masutangu.com/2016/02/using-udf-plus-trigger/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/02/using-udf-plus-trigger/</guid>
        
        
        <category>数据库</category>
        
      </item>
    
      <item>
        <title>Elric Change Log II</title>
        <description>&lt;p&gt;最近有些时间，于是对分布式框架Elric做了些优化，同时新增了些新特性，在这里分享给大家。&lt;/p&gt;

&lt;h1&gt;优化Worker拉取任务逻辑&lt;/h1&gt;

&lt;p&gt;之前的逻辑是从任务队列里拉取任务后就塞给进程池，会导致worker不断从任务队列里取任务，然后在进程池里等待执行。这样的话，Worker不是按需取任务，而是揽一大堆活然后一直积压在手里做不完，而后续拉起空闲的Worker则取不到任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-1.png&quot; alt=&quot;示例1&quot; title=&quot;示例1&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前的逻辑，拉取任务后直接塞给进程池这里我对取任务的逻辑做了优化，使用Queue来统计正在执行中的任务。初始化一个Queue，其最大长度等于Worker的进程池大小。拉取任务前，往Queue里put一个控制符。任务执行完时，从Queue里get一个控制符。当进程池的进程都在执行任务的时候，此时Queue是满的，put操作会阻塞，因此Worker阻塞到Queue有空间的时候（有进程完成任务了，从Queue里get走了一个控制符，也意味着有空闲的进程了），才会到任务队列里拉取任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-2.png&quot; alt=&quot;示例2&quot; title=&quot;示例2&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;拉取任务前，尝试往queue里put一个控制符，如果queue已满（没有空闲进程），则一直阻塞&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-3.png&quot; alt=&quot;示例3&quot; title=&quot;示例3&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;任务执行完，从queue里get一个控制符&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;commit：&lt;a href=&quot;https://github.com/Masutangu/Elric/commit/e84d359b2082e97f4aa8b400f2b8e1651506fae3&quot;&gt;https://github.com/Masutangu/Elric/commit/e84d359b2082e97f4aa8b400f2b8e1651506fae3&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;限制任务队列的长度&lt;/h1&gt;

&lt;p&gt;之前Master会一直往任务队列里提交任务，并不关心任务队列积压的任务数。这样如果Worker挂掉一段时间后再拉起的时候，就会一直执行积压的过期任务。&lt;/p&gt;

&lt;p&gt;于是我希望给Master提供一个控制队列长度的能力。首先给任务队列新增一个接口is_full()，返回True表示任务队列已满。在Master提交任务到任务队列前，先检查任务队列是否已满。如果队列已经满了，则把该任务写到Buffer Queue里，在另外的线程里去做定期重试写入任务队列的逻辑。&lt;/p&gt;

&lt;p&gt;这里其实是参考了nsq的做法。只不过我把Python的Queue当成Golang的channel来使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-4.png&quot; alt=&quot;示例4&quot; title=&quot;示例4&quot; width=&quot;800&quot; /&gt;
&lt;em&gt;新增is_full()接口&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-5.png&quot; alt=&quot;示例5&quot; title=&quot;示例5&quot; width=&quot;800&quot; /&gt;
&lt;em&gt;提交任务前检查下任务队列是否已满，如果是，则写到buffer_queue里&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-6.png&quot; alt=&quot;示例6&quot; title=&quot;示例6&quot; width=&quot;800&quot; /&gt;
&lt;em&gt;start_process_buffer_job线程处理buffer_queue的任务，定期尝试写入到任务队列里，如果任务队列已满，则再次放回buffer_queue。如果超过一定时间都没有提交成功，则将任务丢弃&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;commit：&lt;a href=&quot;https://github.com/Masutangu/Elric/commit/592e6756725bf2e138d2e1f1de1c9f7d579a4324&quot;&gt;https://github.com/Masutangu/Elric/commit/592e6756725bf2e138d2e1f1de1c9f7d579a4324&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;提供任务存储的mongodb支持&lt;/h1&gt;

&lt;p&gt;之前的任务存储是基于内存，为了使master有更高的可用性，这里我新增了mongodb的支持。&lt;/p&gt;

&lt;p&gt;同时为了更好的监控任务的执行情况，需要有存储来记录每个任务执行是否成功，失败则记录Exception的信息。如果是循环任务，则只需要记录近N次的执行结果。&lt;/p&gt;

&lt;p&gt;Mongodb的Array类型提供了限制大小的能力，非常符合我仅记录近N次执行结果的需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elric-change-log-2/illustration-7.png&quot; alt=&quot;示例7&quot; title=&quot;示例7&quot; width=&quot;800&quot; /&gt;
&lt;em&gt;slice用与限制array的大小&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;commit：&lt;a href=&quot;https://github.com/Masutangu/Elric/commit/c87fd9c227359ca5ce31f19c2be05154c96a45f0&quot;&gt;https://github.com/Masutangu/Elric/commit/c87fd9c227359ca5ce31f19c2be05154c96a45f0&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Feb 2016 16:07:58 +0800</pubDate>
        <link>http://masutangu.com/2016/02/elric-change-log-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/02/elric-change-log-2/</guid>
        
        
        <category>优化&amp;重构</category>
        
      </item>
    
  </channel>
</rss>
