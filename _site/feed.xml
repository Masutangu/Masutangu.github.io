<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Masutangu</title>
    <description>也許我這一生　始終在追逐那顆九號球</description>
    <link>http://masutangu.com/</link>
    <atom:link href="http://masutangu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 06 Jul 2018 23:05:45 +0800</pubDate>
    <lastBuildDate>Fri, 06 Jul 2018 23:05:45 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>etcd-raft 源码学习笔记（Leader Transfer）</title>
        <description>&lt;p&gt;这篇文章介绍 etcd-raft 如何实现 leadership transfer，把 leader 身份转移给某个 follower。&lt;/p&gt;

&lt;p&gt;应用层调用 &lt;code&gt;TransferLeadership&lt;/code&gt; 方法，发送一个 type 为 pb.MsgTransferLeader 的请求给 raft 处理。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (n *node) TransferLeadership(ctx context.Context, lead, transferee uint64) {
    select {
    // manually set &amp;#39;from&amp;#39; and &amp;#39;to&amp;#39;, so that leader can voluntarily transfers its leadership
    case n.recvc &amp;lt;- pb.Message{Type: pb.MsgTransferLeader, From: transferee, To: lead}:
    case &amp;lt;-n.done:
    case &amp;lt;-ctx.Done():
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;stepLeader&lt;/code&gt; 收到 pb.MsgTransferLeader 后，检查下是否有正在进行的 leader transfer，并检查 tranferee 的 log 是否是最新的，如果是，调用 &lt;code&gt;sendTimeoutNow&lt;/code&gt;，如果不是最新日志，则发送 appendEntriesReq，收到 MsgAppResp 后，如果条件符合，再调用 &lt;code&gt;sendTimeoutNow&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // All other message types require a progress for m.From (pr).
    pr := r.getProgress(m.From)
    // These message types do not require any progress for m.From.
    switch m.Type {
        case pb.MsgTransferLeader:
        leadTransferee := m.From
        lastLeadTransferee := r.leadTransferee
        if lastLeadTransferee != None {
            if lastLeadTransferee == leadTransferee {
                return nil
            }
            // 取消之前的
            r.abortLeaderTransfer()
        }
        if leadTransferee == r.id {
            // leadTransferee 已经是 leader 了
            return nil
        }
        // Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.
        r.electionElapsed = 0
        r.leadTransferee = leadTransferee
        // 如果 leadTransferee 的 log 已经是最新的了 则马上调用 sendTimeoutNow，开始 transfer
        if pr.Match == r.raftLog.lastIndex() {
            r.sendTimeoutNow(leadTransferee)
        } else {
            // 否则先往 leadTransferee append 日志
            r.sendAppend(leadTransferee)
        }

        ...
        // 收到 append 回包后，检查是不是有 in progress 的 leader transfer，并且 log 也是最新了的话，则调用 sendTimeoutNow
        case pb.MsgAppResp:
        pr.RecentActive = true

        ...
        // Transfer leadership is in progress.
        if m.From == r.leadTransferee &amp;amp;&amp;amp; pr.Match == r.raftLog.lastIndex() {
            r.sendTimeoutNow(m.From)
        }
        ...
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Leader transfer 过程中不处理 pb.MsgProp 类型的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgProp:
        ...
        if r.leadTransferee != None {
            // 正在 leader tranfer，不处理 Propose 请求
            return ErrProposalDropped
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;sendTimeoutNow&lt;/code&gt; 发送 pb.MsgTimeoutNow 的请求，看看 follower 如何处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepFollower(r *raft, m pb.Message) error {
    switch m.Type {
        case pb.MsgTimeoutNow:
        if r.promotable() {
            // Leadership transfers never use pre-vote even if r.preVote is true; we
            // know we are not recovering from a partition so there is no need for the
            // extra round trip.
            r.campaign(campaignTransfer)
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;campain&lt;/code&gt; 会发送 voteMsg 给 peers 进行选举：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;
func (r *raft) campaign(t CampaignType) {
    var term uint64
    var voteMsg pb.MessageType
    if t == campaignPreElection {
        r.becomePreCandidate()
        voteMsg = pb.MsgPreVote
        // PreVote RPCs are sent for the next term before we&amp;#39;ve incremented r.Term.
        term = r.Term + 1
    } else {
        r.becomeCandidate()  // 变成 Candidate term + 1，此时该节点 term 最大，所以该节点将成为新的 leader
        voteMsg = pb.MsgVote
        term = r.Term
    }
    if r.quorum() == r.poll(r.id, voteRespMsgType(voteMsg), true) {
        // We won the election after voting for ourselves (which must mean that
        // this is a single-node cluster). Advance to the next state.
        if t == campaignPreElection {
            r.campaign(campaignElection)
        } else {
            r.becomeLeader()
        }
        return
    }

    // 发送 voteMsg
    for id := range r.prs {
        if id == r.id {
            continue
        }
        var ctx []byte
        if t == campaignTransfer {
            ctx = []byte(t)
        }
        r.send(pb.Message{Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx})
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当前 leader 变成 follower 之后，会调用 &lt;code&gt;reset&lt;/code&gt;，&lt;code&gt;reset&lt;/code&gt; 将调用 &lt;code&gt;abortLeaderTransfer&lt;/code&gt; 把 &lt;code&gt;r.leadTransferee&lt;/code&gt; 设置为 None，leader transfer 完成。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (r *raft) reset(term uint64) {
    if r.Term != term {
        r.Term = term
        r.Vote = None
    }
    r.lead = None

    r.electionElapsed = 0
    r.heartbeatElapsed = 0
    r.resetRandomizedElectionTimeout()
    r.abortLeaderTransfer()
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Fri, 06 Jul 2018 22:56:37 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-5/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-5/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（Linearizable Read 之 Lease）</title>
        <description>&lt;p&gt;这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 &lt;a href=&quot;https://aphyr.com/posts/313-strong-consistency-models&quot;&gt;《Strong consistency models》&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;除了基于 &lt;a href=&quot;http://masutangu.com/2018/07/etcd-raft-note-3/&quot;&gt;ReadIndex&lt;/a&gt; 之外，raft 论文第 8 节还阐述了另一种基于 heartbeat 的 lease 思路：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Alternatively, the leader could rely on the heartbeat mechanism to provide a form of lease, but this would rely on timing for safety (it
assumes bounded clock skew).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;raft 中，follower 至少会在 election timeout 之后才重新进行选举。leader 定期发送 heartbeat，在收到 quonum 节点的回包后的 election timeout 这段时间间隔内，不会有新一轮的选举（因为各个机器的 cpu 时钟有误差，所以这个方案有风险）。&lt;/p&gt;

&lt;p&gt;lease 模式对应用层提供的接口还是 &lt;code&gt;ReadIndex&lt;/code&gt;，应用层处理的方式也和基于 ReadIndex 模式相同。只是 raft 内部逻辑不同。&lt;/p&gt;

&lt;p&gt;如果指定了 leaseBase 的模式，那要求 &lt;code&gt;CheckQuorum&lt;/code&gt; 为 true，&lt;code&gt;validate&lt;/code&gt; 方法做了这个检查：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (c *Config) validate() error {
    ...
    if c.ReadOnlyOption == ReadOnlyLeaseBased &amp;amp;&amp;amp; !c.CheckQuorum {
        return errors.New(&amp;quot;CheckQuorum must be enabled when ReadOnlyOption is ReadOnlyLeaseBased&amp;quot;)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;指定了 &lt;code&gt;checkQuorum&lt;/code&gt; 为 true 之后，每次 tick 都会看是否应该检查 Quorum（间隔 electionTimeout），通过发送 pb.MsgCheckQuorum 类型的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.
func (r *raft) tickHeartbeat() {
    r.heartbeatElapsed++
    r.electionElapsed++

    if r.electionElapsed &amp;gt;= r.electionTimeout {  // 每隔 electionTimeout 检查一次
        r.electionElapsed = 0
        if r.checkQuorum {
            r.Step(pb.Message{From: r.id, Type: pb.MsgCheckQuorum})  // 检查 Quorum
        }
        // If current leader cannot transfer leadership in electionTimeout, it becomes leader again.
        if r.state == StateLeader &amp;amp;&amp;amp; r.leadTransferee != None {
            r.abortLeaderTransfer()
        }
    }

    if r.state != StateLeader {
        return
    }

    if r.heartbeatElapsed &amp;gt;= r.heartbeatTimeout {
        r.heartbeatElapsed = 0
        r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;stepLeader&lt;/code&gt; 收到 pb.MsgCheckQuorum 后调用 &lt;code&gt;checkQuorumActive&lt;/code&gt; 进行检查，如果返回 false，此时把节点变更为 follower：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgCheckQuorum:
        if !r.checkQuorumActive() {  
            r.becomeFollower(r.Term, None)  // checkQuorumActive 失败，变成 follower
        }
        return nil
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;checkQuorumActive&lt;/code&gt; 即统计 active 的 peers 数量是否超过 quonum：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// checkQuorumActive also resets all RecentActive to false.
func (r *raft) checkQuorumActive() bool {
    var act int

    r.forEachProgress(func(id uint64, pr *Progress) {
        if id == r.id { // self is always active
            act++
            return
        }

        if pr.RecentActive &amp;amp;&amp;amp; !pr.IsLearner {
            act++
        }

        pr.RecentActive = false
    })

    return act &amp;gt;= r.quorum()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;RecentActive&lt;/code&gt; 是 leader 收到 peers 的心跳回包或者 appendEntriesReq 的回包时设置的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // All other message types require a progress for m.From (pr).
    pr := r.getProgress(m.From)

    switch m.Type {
    case pb.MsgAppResp:
        pr.RecentActive = true
        ...
    case pb.MsgHeartbeatResp:
        pr.RecentActive = true
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;文章开头提到， leaseBase 模式下 etcd-raft 对应用层暴露的也是 &lt;code&gt;ReadIndex&lt;/code&gt; 接口。在收到 pb.MsgReadIndex 类型的请求时，由于 CheckQuonum 保证了我们 leader 有效，就可以直接 append 到 r.readStates 中。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgReadIndex:
        // 5.4 safety
        if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
            // Reject read only request when this leader has not committed any log entry at its term.
            return nil
        }

        // thinking: use an interally defined context instead of the user given context.
        // We can express this in terms of the term and index instead of a user-supplied value.
        // This would allow multiple reads to piggyback on the same message.
        switch r.readOnly.option {
        case ReadOnlyLeaseBased: // leaseBase 模式
            ri := r.raftLog.committed
            if m.From == None || m.From == r.id { // from local member
                r.readStates = append(r.readStates, ReadState{Index: r.raftLog.committed, RequestCtx: m.Entries[0].Data})
            } else {
                r.send(pb.Message{To: m.From, Type: pb.MsgReadIndexResp, Index: ri, Entries: m.Entries})
            }
        }

        return nil
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Fri, 06 Jul 2018 08:46:43 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-4/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-4/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（Linearizable Read 之 ReadIndx）</title>
        <description>&lt;p&gt;这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 &lt;a href=&quot;https://aphyr.com/posts/313-strong-consistency-models&quot;&gt;《Strong consistency models》&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;raft 论文第 8 节阐述了思路：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在收到读请求时，leader 节点保存下当前的 commit index，并往 peers 发送心跳。如果确定该节点依然是 leader，则只需要等到该 commit index 的 log entry 被 apply 到状态机时就可以返回客户端结果。&lt;/p&gt;

&lt;p&gt;我们先通过位于 etcd/etcdserver 目录下的样例来看看应用层是如何使用 ReadIndex 来保证 linearizable read 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// v3_server.go

type RaftKV interface {
    Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)
    Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)
    DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)
    Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)
    Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
}

func (s *EtcdServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
    var resp *pb.RangeResponse
    var err error

    if !r.Serializable {
        err = s.linearizableReadNotify(ctx)  // 等待 linearizableReadNotify 返回 才能继续往下走
        if err != nil {
            return nil, err
        }
    }
    // 读取数据逻辑 省略..
    ...
    return resp, err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在读请求 &lt;code&gt;Range&lt;/code&gt; 执行前，调用了 &lt;code&gt;linearizableReadNotify&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *EtcdServer) linearizableReadNotify(ctx context.Context) error {
    s.readMu.RLock()
    nc := s.readNotifier
    s.readMu.RUnlock()

    // signal linearizable loop for current notify if it hasn&amp;#39;t been already
    select {
    case s.readwaitc &amp;lt;- struct{}{}:
    default:
    }

    // wait for read state notification
    select {
    case &amp;lt;-nc.c:
        return nc.err
    case &amp;lt;-ctx.Done():
        return ctx.Err()
    case &amp;lt;-s.done:
        return ErrStopped
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;linearizableReadNotify&lt;/code&gt; 往 &lt;code&gt;readwaitc&lt;/code&gt; 发送个空的结构体，并且等待 &lt;code&gt;nc.c&lt;/code&gt; 的返回。&lt;code&gt;readwaitc&lt;/code&gt; 是在另外的 goroutine &lt;code&gt;linearizableReadLoop&lt;/code&gt; 里监听的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;
func (s *EtcdServer) linearizableReadLoop() {
    var rs raft.ReadState

    for {
        ctx := make([]byte, 8)
        binary.BigEndian.PutUint64(ctx, s.reqIDGen.Next())  // ctx 即请求唯一标识 reqId

        select {
        case &amp;lt;-s.readwaitc:  // 监听 readwaitc
        case &amp;lt;-s.stopping:
            return
        }

        nextnr := newNotifier()
        nr := s.readNotifier
        s.readNotifier = nextnr

        s.r.ReadIndex(cctx, ctx)  // 调用 ReadIndex 接口，往 recvc channel 发送 type 为 pb.MsgReadIndex 的请求

        var (
            timeout bool
            done    bool
        )
        for !timeout &amp;amp;&amp;amp; !done {
            select {
            case rs = &amp;lt;-s.r.readStateC:  // 收到 ready 对象时，会往 readStateC channel 传回来 readState，见 etcd/etcdserver/raft.go 文件的 func (r *raftNode) start(rh *raftReadyHandler)
                done = bytes.Equal(rs.RequestCtx, ctx)  // 比较下 reqId 是否一致
            case &amp;lt;-time.After(s.Cfg.ReqTimeout()):
                nr.notify(ErrTimeout)
                timeout = true
            case &amp;lt;-s.stopping:
                return
            }
        }
        if !done {
            continue
        }

        // 等待 readState 里的 index，也就是收到 pb.MsgReadIndex 请求时，leader 节点当前的 commit index 被 apply 到状态机时，此时调用 nr.notify(nil) 通知应用层可以读取状态机里的数据了，确保读到的不是 stale 数据
        if ai := s.getAppliedIndex(); ai &amp;lt; rs.Index {
            select {
            case &amp;lt;-s.applyWait.Wait(rs.Index):
            case &amp;lt;-s.stopping:
                return
            }
        }
        // unblock all l-reads requested at indices before rs.Index
        nr.notify(nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;linearizableReadLoop&lt;/code&gt; 调用 &lt;code&gt;nr.notify&lt;/code&gt; 后，&lt;code&gt;linearizableReadNotify&lt;/code&gt; 从 select 阻塞中返回，此时就可以继续走 &lt;code&gt;Range&lt;/code&gt; 的逻辑，读取数据，返回给客户端。&lt;/p&gt;

&lt;p&gt;从上面的例子，我们了解了应用层如何使用 Node 的 &lt;code&gt;ReadIndex&lt;/code&gt; 接口来实现 linearizable read。下面我们来介绍 &lt;code&gt;ReadIndex&lt;/code&gt; 这个新接口：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()

    // ReadIndex request a read state. The read state will be set in the ready.
    // Read state has a read index. Once the application advances further than the read
    // index, any linearizable read requests issued before the read request can be
    // processed safely. The read state will have the same rctx attached.
    ReadIndex(ctx context.Context, rctx []byte) error
}

func (n *node) ReadIndex(ctx context.Context, rctx []byte) error {
    return n.step(ctx, pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上篇文章 &lt;a href=&quot;http://masutangu.com/2018/07/etcd-raft-note-2/&quot;&gt;《etcd-raft 源码学习笔记（概览篇）》&lt;/a&gt; 提到当节点为 leader 时，&lt;code&gt;step&lt;/code&gt; 被设置为 &lt;code&gt;stepLeader&lt;/code&gt; 。我们来看看 &lt;code&gt;stepLeader&lt;/code&gt; 是如何处理 type 为 pb.MsgReadIndex 的 readIndexReq 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgReadIndex:
        // raft 5.4 safty 检查
        if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
            // Reject read only request when this leader has not committed any log entry at its term.
            return nil
        }

        // thinking: use an interally defined context instead of the user given context.
        // We can express this in terms of the term and index instead of a user-supplied value.
        // This would allow multiple reads to piggyback on the same message.
        switch r.readOnly.option {
        case ReadOnlySafe:
            r.readOnly.addRequest(r.raftLog.committed, m)  // r.raftLog.committed 为 当前 commit index
            r.bcastHeartbeatWithCtx(m.Entries[0].Data)  // 广播心跳包
        }
        return nil
    }
    return nil
}


&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;收到 readIndexReq 后，首先调用 &lt;code&gt;r.readOnly.addRequest&lt;/code&gt; 保存下，然后调用 &lt;code&gt;bcastHeartbeatWithCtx&lt;/code&gt; 广播心跳包， ctx 即唯一标识 readIndexReq 的 reqId。&lt;/p&gt;

&lt;p&gt;来看看 raft 是如何管理 readIndexReq 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// addRequest adds a read only reuqest into readonly struct.
// `index` is the commit index of the raft state machine when it received
// the read only request.
// `m` is the original read only request message from the local or remote node.
func (ro *readOnly) addRequest(index uint64, m pb.Message) {
    ctx := string(m.Entries[0].Data)  // ctx 即 reqId
    if _, ok := ro.pendingReadIndex[ctx]; ok {
        return
    }
    ro.pendingReadIndex[ctx] = &amp;amp;readIndexStatus{index: index, req: m, acks: make(map[uint64]struct{})}  // acks 用于记录哪些 peer 已经 ack 确认。之后用于统计是否大于 quonum
    ro.readIndexQueue = append(ro.readIndexQueue, ctx)  // append 进 readIndexQueue
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;再看看 &lt;code&gt;stepLeader&lt;/code&gt; 如何处理心跳回包：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgHeartbeatResp:
        pr.RecentActive = true
        pr.resume()

        if r.readOnly.option != ReadOnlySafe || len(m.Context) == 0 {
            return nil
        }

        ackCount := r.readOnly.recvAck(m)
        if ackCount &amp;lt; r.quorum() {  // 判断是否收到 quorum 的心跳回包
            return nil
        }

        // 收到 quorum 的心跳回包了，把 readIndexReq 依次 append r.readStates 中，返回 ready 对象时会包含 r.readStates
        rss := r.readOnly.advance(m)
        for _, rs := range rss {
            req := rs.req
            if req.From == None || req.From == r.id { // from local member
                r.readStates = append(r.readStates, ReadState{Index: rs.index, RequestCtx: req.Entries[0].Data})
            } else {
                r.send(pb.Message{To: req.From, Type: pb.MsgReadIndexResp, Index: rs.index, Entries: req.Entries})
            }
        }
    return nil
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;调用 &lt;code&gt;r.readOnly.recvAck&lt;/code&gt;，根据 readIndeReq 的 reqId 统计收到心跳回包的数量：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// recvAck notifies the readonly struct that the raft state machine received
// an acknowledgment of the heartbeat that attached with the read only request
// context.
func (ro *readOnly) recvAck(m pb.Message) int {
    rs, ok := ro.pendingReadIndex[string(m.Context)]
    if !ok {
        return 0
    }

    rs.acks[m.From] = struct{}{}  // 记录下收到 m.From 这个节点的 ack
    // add one to include an ack from local node
    return len(rs.acks) + 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果超过 quonum 表示该节点依然是 leader，此时从 &lt;code&gt;r.readOnly.advance&lt;/code&gt; 拿到保存的 readIndexReq，append 到 &lt;code&gt;r.readStates&lt;/code&gt; 中：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// advance advances the read only request queue kept by the readonly struct.
// It dequeues the requests until it finds the read only request that has
// the same context as the given `m`.
func (ro *readOnly) advance(m pb.Message) []*readIndexStatus {
    var (
        i     int
        found bool
    )

    ctx := string(m.Context)
    rss := []*readIndexStatus{}

    for _, okctx := range ro.readIndexQueue {
        i++
        rs, ok := ro.pendingReadIndex[okctx]
        if !ok {
            panic(&amp;quot;cannot find corresponding read state from pending map&amp;quot;)
        }
        rss = append(rss, rs)
        if okctx == ctx {
            // 取出 reqId 相同的 ReadState 和其前面的所有 ReadState 
            found = true
            break
        }
    }

    if found {
        ro.readIndexQueue = ro.readIndexQueue[i:]
        for _, rs := range rss {
            delete(ro.pendingReadIndex, string(rs.req.Entries[0].Data))
        }
        return rss
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;之后调用 &lt;code&gt;newReady&lt;/code&gt; 会把 &lt;code&gt;r.readStates&lt;/code&gt; 返回给应用层，应用层取出 readIndexReq 中的 commit index，等到其被 apply 到状态机就可以允许读操作了。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    ...

    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates  // 附上 r.readStates
    }
    ...
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 05 Jul 2018 13:46:43 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-3/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-3/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（概览篇）</title>
        <description>&lt;p&gt;这篇文章主要整体上介绍 etcd-raft 库，包括各个类的作用，类之间的串联。不涉及 raft 算法。先来看看 etcd-raft 几个结构体的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raft struct {
    id uint64

    Term uint64
    Vote uint64

    // the log
    raftLog *raftLog

    state StateType

    // isLearner is true if the local raft node is a learner.
    isLearner bool

    votes map[uint64]bool

    msgs []pb.Message

    // the leader id
    lead uint64

    tick func()
    step stepFunc
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raftLog struct {
    // storage contains all stable entries since the last snapshot.
    storage Storage

    // unstable contains all unstable entries and snapshot.
    // they will be saved into storage.
    unstable unstable

    // committed is the highest log position that is known to be in
    // stable storage on a quorum of nodes.
    committed uint64
    // applied is the highest log position that the application has
    // been instructed to apply to its state machine.
    // Invariant: applied &amp;lt;= committed
    applied uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// unstable.entries[i] has raft log position i+unstable.offset.
// Note that unstable.offset may be less than the highest log
// position in storage; this means that the next write to storage
// might need to truncate the log before persisting unstable.entries.
type unstable struct {
    // the incoming unstable snapshot, if any.
    snapshot *pb.Snapshot
    // all entries that have not yet been written to storage.
    entries []pb.Entry
    offset  uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// node is the canonical implementation of the Node interface
type node struct {
    propc      chan msgWithResult
    recvc      chan pb.Message
    readyc     chan Ready
    advancec   chan struct{}
    tickc      chan struct{}
    done       chan struct{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Ready encapsulates the entries and messages that are ready to read,
// be saved to stable storage, committed or sent to other peers.
// All fields in Ready are read-only.
type Ready struct {
    // The current volatile state of a Node.
    // SoftState will be nil if there is no update.
    // It is not required to consume or store SoftState.
    *SoftState

    // The current state of a Node to be saved to stable storage BEFORE
    // Messages are sent.
    // HardState will be equal to empty state if there is no update.
    pb.HardState

    // ReadStates can be used for node to serve linearizable read requests locally
    // when its applied index is greater than the index in ReadState.
    // Note that the readState will be returned when raft receives msgReadIndex.
    // The returned is only valid for the request that requested to read.
    ReadStates []ReadState

    // Entries specifies entries to be saved to stable storage BEFORE
    // Messages are sent.
    Entries []pb.Entry

    // Snapshot specifies the snapshot to be saved to stable storage.
    Snapshot pb.Snapshot

    // CommittedEntries specifies entries to be committed to a
    // store/state-machine. These have previously been committed to stable
    // store.
    CommittedEntries []pb.Entry

    // Messages specifies outbound messages to be sent AFTER Entries are
    // committed to stable storage.
    // If it contains a MsgSnap message, the application MUST report back to raft
    // when the snapshot has been received or has failed by calling ReportSnapshot.
    Messages []pb.Message

    // MustSync indicates whether the HardState and Entries must be synchronously
    // written to disk or if an asynchronous write is permissible.
    MustSync bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这几个结构体的关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;RaftLog 的 &lt;code&gt;Storage&lt;/code&gt; 和 RaftNode 的 &lt;code&gt;raftStorage&lt;/code&gt; 都是指向同一个 Storage 对象（虚线表示指针）。Storage 在 kvstore 的示例中的实现为 MemoryStorage，可以理解为 WAL 的一个内存缓存。重启时会从 WAL 恢复 MemoryStorage 的数据。整个逻辑由 Node 的 &lt;code&gt;run&lt;/code&gt; 方法的 for loop 驱动，从 &lt;code&gt;recvc&lt;/code&gt; channel 接收请求，调用 raft 的 &lt;code&gt;Step&lt;/code&gt; 函数进行处理。&lt;code&gt;Step&lt;/code&gt; 函数会调用 &lt;code&gt;step&lt;/code&gt;，&lt;code&gt;step&lt;/code&gt; 是函数指针，在节点成为 leader 时将其设置为 &lt;code&gt;stepLeader&lt;/code&gt;，节点变成 follower 时设置为 &lt;code&gt;stepFollower&lt;/code&gt;。&lt;code&gt;step&lt;/code&gt; 处理 append 请求时，会调用 raftLog 的 &lt;code&gt;maybeAppend&lt;/code&gt; 方法，最终会把 entries append 到 &lt;code&gt;unstable&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;在 Node &lt;code&gt;run&lt;/code&gt; 方法的 for loop 中，会定期通过 &lt;code&gt;newReady&lt;/code&gt; 函数构造 Ready 对象。Ready 包括如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HardState 即 raft 节点的 persistent state &lt;/li&gt;
&lt;li&gt;SoftState 即 raft 节点的 volatile state &lt;/li&gt;
&lt;li&gt;CommittedEntries 即已经 commit 的 log entries，需要应用层 apply 到状态机&lt;/li&gt;
&lt;li&gt;Entries 即 unstable 中的 log entries（未落盘的 log entries）&lt;/li&gt;
&lt;li&gt;Snapshot 即需要持久化的 snapshot&lt;/li&gt;
&lt;li&gt;Messages 即 mailbox，所有还未发送的消息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;构造好的 &lt;code&gt;Ready&lt;/code&gt; 对象发送到 &lt;code&gt;readyc&lt;/code&gt; channel，RaftNode 取出后会做如下处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持久化 HardState、Entries、Snapshot 到 Storage 和 WAL (&lt;code&gt;raftStorage.ApplySnapshot()&lt;/code&gt;、&lt;code&gt;raftStorage.Append()&lt;/code&gt; 和 &lt;code&gt;wal.Save(rd.HardState, rd.Entries)&lt;/code&gt; 可以看出 memoryStorage 是 wal 的缓存，写 wal 的同时也写 memoryStorage)&lt;/li&gt;
&lt;li&gt;apply CommittedEntries 到状态机&lt;/li&gt;
&lt;li&gt;广播 Messages &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;处理完后调用 Node.Advance() 通知 Node Ready 对象处理完毕，准备好接收下一个。&lt;/p&gt;

&lt;p&gt;最后看看驱动整个逻辑的 &lt;code&gt;run&lt;/code&gt; 方法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (n *node) run(r *raft) {
    var propc chan msgWithResult
    var readyc chan Ready
    var advancec chan struct{}
    var prevLastUnstablei, prevLastUnstablet uint64
    var havePrevLastUnstablei bool
    var prevSnapi uint64
    var rd Ready

    lead := None
    prevSoftSt := r.softState()
    prevHardSt := emptyState

    for {
        if advancec != nil {
            readyc = nil
        } else {
            // 应用层通知上一个 ready 对象已经处理完毕了 此时 advancec 为 nil 
            rd = newReady(r, prevSoftSt, prevHardSt)
            if rd.containsUpdates() { // 有更新才把 readyc 设为 非空
                readyc = n.readyc
            } else {
                readyc = nil
            }
        }

        select {
        case m := &amp;lt;-n.recvc:
            // filter out response message from unknown From.
            if pr := r.getProgress(m.From); pr != nil || !IsResponseMsg(m.Type) {
                r.Step(m)
            }
        case &amp;lt;-n.tickc:
            r.tick()
        case readyc &amp;lt;- rd:
            if rd.SoftState != nil {
                prevSoftSt = rd.SoftState
            }
            if len(rd.Entries) &amp;gt; 0 {
                prevLastUnstablei = rd.Entries[len(rd.Entries)-1].Index
                prevLastUnstablet = rd.Entries[len(rd.Entries)-1].Term
                havePrevLastUnstablei = true
            }
            if !IsEmptyHardState(rd.HardState) {
                prevHardSt = rd.HardState
            }
            if !IsEmptySnap(rd.Snapshot) {
                prevSnapi = rd.Snapshot.Metadata.Index
            }

            r.msgs = nil
            r.readStates = nil
            advancec = n.advancec
        case &amp;lt;-advancec:
            if prevHardSt.Commit != 0 {
                r.raftLog.appliedTo(prevHardSt.Commit)
            }
            // 应用层处理完了 表示 unstable 的东西不需要了 该清理就清理
            if havePrevLastUnstablei {
                r.raftLog.stableTo(prevLastUnstablei, prevLastUnstablet)
                havePrevLastUnstablei = false
            }
            r.raftLog.stableSnapTo(prevSnapi)
            advancec = nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还有构造 Ready 对象的 &lt;code&gt;newReady&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    if softSt := r.softState(); !softSt.equal(prevSoftSt) {
        rd.SoftState = softSt
    }
    if hardSt := r.hardState(); !isHardStateEqual(hardSt, prevHardSt) {
        rd.HardState = hardSt
    }
    if r.raftLog.unstable.snapshot != nil {
        rd.Snapshot = *r.raftLog.unstable.snapshot
    }
    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates
    }
    rd.MustSync = MustSync(rd.HardState, prevHardSt, len(rd.Entries))
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Wed, 04 Jul 2018 13:33:35 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-2/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（示例篇）</title>
        <description>&lt;p&gt;本系列文章为 &lt;a href=&quot;https://github.com/coreos/etcd/tree/master/raft&quot;&gt;etcd-raft&lt;/a&gt; 源码阅读笔记，采用自顶向下的方式。这篇是开篇，首先来看看 etcd 提供的基于 raft 库实现的 kv store 示例，代码目录位于 contrib/raftexample。&lt;/p&gt;

&lt;p&gt;从 main 函数开始读起：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
    ...
    proposeC := make(chan string)
    defer close(proposeC)

    var kvs *kvstore
    getSnapshot := func() ([]byte, error) { return kvs.getSnapshot() }
    commitC, errorC, snapshotterReady := newRaftNode(*id, strings.Split(*cluster, &amp;quot;,&amp;quot;), *join, getSnapshot, proposeC, confChangeC)

    kvs = newKVStore(&amp;lt;-snapshotterReady, proposeC, commitC, errorC)
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;getSnapshot&lt;/code&gt; 为应用层 kv 提供的 snapshot 方法，在 raft 中调用该方法进行 snapshot。&lt;code&gt;proposeC&lt;/code&gt; 是应用层 kv 向 raftNode 发送请求的 channel，&lt;code&gt;commitC&lt;/code&gt; 为 raftNode 通知应用层 kv 已经提交的请求的 channel。&lt;/p&gt;

&lt;p&gt;先看看 &lt;code&gt;newKVStore&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newKVStore(snapshotter *snap.Snapshotter, proposeC chan&amp;lt;- string, commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) *kvstore {
    s := &amp;amp;kvstore{proposeC: proposeC, kvStore: make(map[string]string), snapshotter: snapshotter}
    // replay log into key-value map
    s.readCommits(commitC, errorC)
    // read commits from raft into kvStore map until error
    go s.readCommits(commitC, errorC)
    return s
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;readCommits&lt;/code&gt; 方法从 &lt;code&gt;commitC&lt;/code&gt; 中读取已经提交的请求进行处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *kvstore) readCommits(commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) {
    for data := range commitC {
        var dataKv kv
        dec := gob.NewDecoder(bytes.NewBufferString(*data))  // decode 
        s.mu.Lock()
        s.kvStore[dataKv.Key] = dataKv.Val  // 更新 kv
        s.mu.Unlock()
    }
    if err, ok := &amp;lt;-errorC; ok {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;再看看 &lt;code&gt;newRaftNode&lt;/code&gt; ，其会调用 &lt;code&gt;startRaft&lt;/code&gt; 启动底层 raft：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) startRaft() {
    oldwal := wal.Exist(rc.waldir)
    rc.wal = rc.replayWAL()

    rpeers := make([]raft.Peer, len(rc.peers))
    for i := range rpeers {
        rpeers[i] = raft.Peer{ID: uint64(i + 1)}
    }
    c := &amp;amp;raft.Config{
        ID:              uint64(rc.id),
        ElectionTick:    10,
        HeartbeatTick:   1,
        Storage:         rc.raftStorage,
        MaxSizePerMsg:   1024 * 1024,
        MaxInflightMsgs: 256,
    }

    if oldwal {
        rc.node = raft.RestartNode(c)
    } else {
        startPeers := rpeers
        if rc.join {
            startPeers = nil
        }
        rc.node = raft.StartNode(c, startPeers)
    }

    go rc.serveRaft()  // 监听 http 
    go rc.serveChannels()  // 监听 proposeC channel，读取应用层请求 进行处理
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;serveChannels&lt;/code&gt; 就做了两个事，1. 另起一个 goroutine，接收 proposeC 里发送自应用层的请求，通过 &lt;code&gt;Propose&lt;/code&gt; 方法交给底层 raft 处理；2. 调用 &lt;code&gt;Ready&lt;/code&gt; 方法，接收发送自 raft 的 ready 对象，调用 &lt;code&gt;publishEntries&lt;/code&gt; 将已经提交的 entries 发送到 &lt;code&gt;commitC&lt;/code&gt; channel，交由应用层处理，再调用 &lt;code&gt;Advance&lt;/code&gt; 方法通知底层 raft 准备好接收下一个 ready 对象了。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) serveChannels() {
    defer rc.wal.Close()

    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    // send proposals over raft
    go func() {
        var confChangeCount uint64 = 0

        for rc.proposeC != nil &amp;amp;&amp;amp; rc.confChangeC != nil {
            select {
            case prop, ok := &amp;lt;-rc.proposeC:
                if !ok {
                    rc.proposeC = nil
                } else {
                    // blocks until accepted by raft state machine
                    rc.node.Propose(context.TODO(), []byte(prop))  // 调用 Propose 发送给 raft 请求
                }
            }
        }
        // client closed channel; shutdown raft if not already
        close(rc.stopc)
    }()

    // event loop on raft state machine updates
    for {
        select {
        case &amp;lt;-ticker.C:
            rc.node.Tick()

        // store raft entries to wal, then publish over commit channel
        case rd := &amp;lt;-rc.node.Ready():  // 应用层调用 Ready() 获取 ready 对象
            if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
                rc.stop()
                return
            }
            rc.node.Advance()  // 应用层调用 Advance() 通知 raft 已经处理完 ready 对象 

        case &amp;lt;-rc.stopc:
            rc.stop()
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;publishEntries&lt;/code&gt; 将 ready 对象里的 &lt;code&gt;CommittedEntries&lt;/code&gt; 发送到 &lt;code&gt;commitC&lt;/code&gt;，由应用层 kv 处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// publishEntries writes committed log entries to commit channel and returns
// whether all entries could be published.
func (rc *raftNode) publishEntries(ents []raftpb.Entry) bool {
    for i := range ents {
        switch ents[i].Type {
        case raftpb.EntryNormal:
            if len(ents[i].Data) == 0 {
                // ignore empty messages
                break
            }
            s := string(ents[i].Data)
            select {
            case rc.commitC &amp;lt;- &amp;amp;s:  // 发送到 commitC channel
            case &amp;lt;-rc.stopc:
                return false
            }
        }

        // after commit, update appliedIndex
        rc.appliedIndex = ents[i].Index

        // special nil commit to signal replay has finished
        if ents[i].Index == rc.lastIndex {
            select {
            case rc.commitC &amp;lt;- nil:
            case &amp;lt;-rc.stopc:
                return false
            }
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;整体架构如下，RaftNode 的角色为应用层和底层 raft 的桥梁：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-1/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出，应用层主要用到 raft.Node 的 &lt;code&gt;Propose&lt;/code&gt;、&lt;code&gt;Ready&lt;/code&gt;、&lt;code&gt;Advance&lt;/code&gt;三个接口：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Tue, 03 Jul 2018 13:21:23 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-1/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-1/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>Libco 之 coctx_swap</title>
        <description>&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;在之前的文章&lt;a href=&quot;http://masutangu.com/2016/10/learn-libco/&quot;&gt;《浅读 Libco》&lt;/a&gt; 粗略的介绍了 libco，这篇文章则重点关注协程上下文切换的实现细节（coctx_swap.S）。&lt;/p&gt;

&lt;p&gt;首先回顾下函数调用的 stack frame layout：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/learn-libco-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2，依次类推。&lt;/p&gt;

&lt;h1&gt;co_resume&lt;/h1&gt;

&lt;p&gt;在之前的文章提到协程的挂起和恢复通过 co_resume 来实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;static int CoRoutineFunc( stCoRoutine_t *co,void * )
{
    if( co-&amp;gt;pfn )
    {
        co-&amp;gt;pfn( co-&amp;gt;arg );
    }
    co-&amp;gt;cEnd = 1;

    stCoRoutineEnv_t *env = co-&amp;gt;env;

    co_yield_env( env );

    return 0;
}

void co_resume( stCoRoutine_t *co )   // 恢复 co 协程
{
    stCoRoutineEnv_t *env = co-&amp;gt;env;
    stCoRoutine_t *lpCurrRoutine = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 1 ];
    if( !co-&amp;gt;cStart )
    {
        coctx_make( &amp;amp;co-&amp;gt;ctx,(coctx_pfn_t)CoRoutineFunc,co,0 );
        co-&amp;gt;cStart = 1;
    }
    env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize++ ] = co;  // 执行协程的时候压入 pCallStack 栈中
    coctx_swap( &amp;amp;(lpCurrRoutine-&amp;gt;ctx),&amp;amp;(co-&amp;gt;ctx) );  // 恢复 co 协程的上下文
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里 coctx_make 函数创建新协程的上下文：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;// 对应 CoRoutineFunc 的两个参数，s1 即 stCoRoutine_t *co，s2 即 void*
struct coctx_param_t
{
    const void *s1;
    const void *s2;
};
struct coctx_t
{
#if defined(__i386__)
    void *regs[ 8 ];
#else
    void *regs[ 14 ];
#endif
    size_t ss_size;
    char *ss_sp;
};

int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 )
{
    // make room for coctx_param
    char *sp = ctx-&amp;gt;ss_sp + ctx-&amp;gt;ss_size - sizeof(coctx_param_t);
    sp = (char*)((unsigned long)sp &amp;amp; -16L); // 16字节对齐

    coctx_param_t* param = (coctx_param_t*)sp ;
    param-&amp;gt;s1 = s;
    param-&amp;gt;s2 = s1;

    memset(ctx-&amp;gt;regs, 0, sizeof(ctx-&amp;gt;regs));

    ctx-&amp;gt;regs[ kESP ] = (char*)(sp) - sizeof(void*);  // 32位下 regs[ kESP ] 即 regs[7]，(char*)(sp) - sizeof(void*) 预留了返回地址的空间

    /*
     ss_sp 是在堆上分配的，地址从低到高增长，而栈是从高到低增长，这里要转下

     高地址  ------  &amp;lt;- ss_sp + ss_size 
           |pading| 
           |s2    |
           |s1    | 
            ------  &amp;lt;- sp
           |void* | 这个返回地址只是预留空间，不需要填。因为 CoRoutineFunc 函数执行完了表示该协程已经跑完，将其 end 标记位置1（co-&amp;gt;cEnd = 1）并调用 co_yield_env 切出。不需要再回到该协程来所以也不需要记录调用 CoRoutineFunc 后的返回地址了
            ------  &amp;lt;- ctx-&amp;gt;regs[ kESP ] 这里为返回地址预留空间的目的在于：参照前言中函数调用的 stack frame layout 图。函数调用压入参数后还需要压入返回地址，这样才能按照约定 ebp + 4 读取参数1，ebp + 8 读取参数2         
           |      |
     低地址  ------  &amp;lt;- ss_sp

                */

    ctx-&amp;gt;regs[ kEIP ] = (char*)pfn;  // 32位下 regs[ kEIP ] 即 regs[0] 保存 pfn 的地址 也就是 CoRoutineFunc 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;co_swap 调用 coctx_swap 来挂起和保存 curr 协程的上下文，恢复 pending 协程的上下文并切换执行流程至 pending 协程：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void co_swap(stCoRoutine_t* curr, stCoRoutine_t* pending_co)
{
    //swap context
    coctx_swap(&amp;amp;(curr-&amp;gt;ctx),&amp;amp;(pending_co-&amp;gt;ctx) );

    //stack buffer may be overwrite, so get again;
    stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;进入 coctx_swap 前 stack frame layout 如下图：
&lt;img src=&quot;/assets/images/learn-libco-2/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;coctx_swap&lt;/h1&gt;

&lt;p&gt;下面是 coctx_swap 的汇编代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;leal 4(%esp), %eax     // 由上图可以看出此时 esp 指向返回地址，esp + 4  即返回地址 + 4（也指向 curr-&amp;gt;ctx 的地址），保存在 %eax                                    
movl 4(%esp), %esp     // 将 esp 移到指向 curr-&amp;gt;ctx    

/*
此时stack layout如下：
对应的ESP地址,此时ESP已经指向了第一个参数 curr-&amp;gt;ctx，为 coctx_t 结构

| *ss_sp  |
| ss_size |
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
---------- &amp;lt;---ESP
*/   

leal 32(%esp), %esp    // 将esp上移 32 个字节

/*
| *ss_sp  |
| ss_size |
----------- &amp;lt;---ESP
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
*/     

pushl %eax         //  curr-&amp;gt;ctx-&amp;gt;regs[7] = %eax 保存返回地址 + 4
pushl %ebp         //  curr-&amp;gt;ctx-&amp;gt;regs[6] = %ebp
pushl %esi         //  curr-&amp;gt;ctx-&amp;gt;regs[5] = %esi
pushl %edi         //  curr-&amp;gt;ctx-&amp;gt;regs[4] = %edi
pushl %edx         //  curr-&amp;gt;ctx-&amp;gt;regs[3] = %edx
pushl %ecx         //  curr-&amp;gt;ctx-&amp;gt;regs[2] = %ecx
pushl %ebx         //  curr-&amp;gt;ctx-&amp;gt;regs[1] = %ebx
pushl -4(%eax)     //  curr-&amp;gt;ctx-&amp;gt;regs[0] = 返回地址 注：%eax - 4 = %old_esp 即返回地址

/*
保存寄存器后的 stack layout
| *ss_sp  |
| ss_size |
| regs[7] |  %eax
| regs[6] |  %ebp
| regs[5] |  %esi
| regs[4] |  %edi
| regs[3] |  %edx
| regs[2] |  %ecx
| regs[1] |  %ebx
| regs[0] |  返回地址
----------- &amp;lt;---ESP
*/     

movl 4(%eax), %esp // 将 esp 移到 curr-&amp;gt;ctx 向上偏移 4 个字节的地址，也即 pending_co-&amp;gt;ctx 的地址，

/*
此时的 stack layout（pending_co-&amp;gt;ctx）
| *ss_sp  |
| ss_size |
| regs[7] | 
| regs[6] | 
| regs[5] |
| regs[4] |
| regs[3] | 
| regs[2] |
| regs[1] |
| regs[0] |
----------- &amp;lt;---ESP  指向第二个参数 pending_co-&amp;gt;ctx-&amp;gt;regs[0]
*/     

// 依次恢复寄存器
popl %eax  // pop from regs[0] regs[0] 保存返回地址
popl %ebx  // pop from regs[1]
popl %ecx  // pop from regs[2]
popl %edx  // pop from regs[3]
popl %edi  // pop from regs[4]
popl %esi  // pop from regs[5]
popl %ebp  // pop from regs[6]
popl %esp  // pop from regs[7] 此时 esp指向 regs[7] 即返回地址 + 4 的位置


/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP
| 返回地址 |

*/

// 下面这行有点ticky, esp 此时指向的是返回地址 + 4的位置，所以这里 push %eax，入栈 %eax 中保存的返回地址，esp 刚好也指向存放该返回地址的位置
pushl %eax

/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
| 返回地址 |
---------- &amp;lt;- ESP
*/


xorl %eax, %eax

ret // ret 指令弹出返回地址，此时 %esp += 4 并跳转到该地址继续执行

/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP / EBP
| 返回地址 | 弹出返回地址

在 coctx_make 的情况下，将跳转到 pfn 执行，esp 执行预留的返回地址 void*，此时stack frame layout 和平台函数调用一样，同样通过 %ebp + 4 访问参数1，%ebp + 8 访问参数2
*/

&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://kaiyuan.me/2017/07/10/libco/&quot;&gt;《libco 分析(上)：协程的实现》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27409164&quot;&gt;《libco协程库上下文切换原理详解》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27339191&quot;&gt;《x86-64 下函数调用及栈帧原理》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rangechow.com/2016/09/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86.html&quot;&gt;《函数调用原理》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 20:57:21 +0800</pubDate>
        <link>http://masutangu.com/2018/04/learn-libco-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/learn-libco-2/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>Programming Language Part B 课程笔记</title>
        <description>&lt;p&gt;本文是学习&lt;a href=&quot;https://www.coursera.org/learn/programming-languages-part-b/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;课程的学习笔记，文章内容及代码均取自课程材料。&lt;/p&gt;

&lt;h1&gt;Interpreter or Compiler&lt;/h1&gt;

&lt;p&gt;实现编程语言的 workflow 如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/programming-language-b/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Parser 读取程序文本，检查 syntax，如果语法正确则输出 AST（abstract syntax tree）。如果该编程语言有 type checker，则将 AST 丢给 type checker 检查，通过 type check 后，就由 interpreter 或 compile 来运行程序并输出结果。&lt;/p&gt;

&lt;p&gt;在实现编程语言 B 通常有下面两种办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用另一种编程语言 A 来实现 interpreter（命名为 evaluator 或 executor 更恰当），输入 B 语言写的代码，输出结果&lt;/li&gt;
&lt;li&gt;使用另一种编程语言 A 实现 compiler（命名为 translator 更恰当），将 B 翻译成第三种编程语言 C&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Skipping Parsing&lt;/h1&gt;

&lt;p&gt;如果基于编程语言 A 来实现编程语言 B，就可以跳过 parsing 阶段：&lt;strong&gt;Have B programmers write ASTs directly in PL A&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ML from a Racket perspective&lt;/h1&gt;

&lt;p&gt;ML is like a well-defined subset of Racket&lt;/p&gt;

&lt;h1&gt;Racket from an ML Perspective&lt;/h1&gt;

&lt;p&gt;One way to describe Racket is that &lt;strong&gt;it has “one big datatype”&lt;/strong&gt;：all values have this type.&lt;/p&gt;

&lt;p&gt;我的理解由于 Racket 是 dynamic typing，所以 ML 程序员看来 Racket 只有一个类型（这样 static type check 都能成功）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constructors are applied implicitly (&lt;strong&gt;values are tagged&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;42 is really like Int 42&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Primitives implicitly check tags and extract data, raising errors for wrong constructors&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun car v = case v of Pair(a,b) =&amp;gt; a | _ =&amp;gt; raise …

fun pair? v = case v of Pair _ =&amp;gt; true | _ =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Weak Typing&lt;/h1&gt;

&lt;p&gt;There exist programs that, by definition, must pass static checking but then when run can &amp;quot;set the computer on fire&amp;quot;?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ease of language implementation: Checks left to the programmer&lt;/li&gt;
&lt;li&gt;Performance: Dynamic checks take time&lt;/li&gt;
&lt;li&gt;Lower level: Compiler does not insert information like array sizes, so it cannot do the checks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Racket is not weakly typed&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It just checks most things dynamically*&lt;/li&gt;
&lt;li&gt;Dynamic checking is the definition – if the implementation can analyze the code to ensure some checks are not needed, then it can optimize them away&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 19:10:35 +0800</pubDate>
        <link>http://masutangu.com/2018/04/programing-language-b/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/programing-language-b/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>The Part-Time Parliament 论文笔记</title>
        <description>&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;Paxos 岛兼职议会类似容错式分布式系统面对的问题：&lt;strong&gt;议员对应分布式系统中的进程，议员缺席对应进程挂掉。Paxos 设计的议会协议在议员经常缺席的情况下可以保证法令的一致性。&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;The Single-Decree Synod&lt;/h1&gt;

&lt;p&gt;单一法令的神会协议的演化如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先由几个&lt;strong&gt;能保证一致性和允许进展性的约束&lt;/strong&gt;推导出&lt;strong&gt;初级协议（preliminary protocol)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preliminary protocol&lt;/strong&gt;的约束版本得到&lt;strong&gt;基本协议（basic protocol）&lt;/strong&gt;，其满足一致性但不保证进展性&lt;/li&gt;
&lt;li&gt;进一步约束&lt;strong&gt;basic protocol&lt;/strong&gt;得到完整的神会协议，既满足一致性又保证进展性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来四小节先讲解保证一致性的约束，再依次得出 preliminary protocol、basic protocol 和完整的神会协议。&lt;/p&gt;

&lt;h2&gt;一致性的约束条件&lt;/h2&gt;

&lt;p&gt;神会法令通过多轮带编号的&lt;strong&gt;表决（ballot）&lt;/strong&gt;选出。每一轮 ballot 是对单一法令的投票。每轮 ballot 牧师只能选择投票（表示赞成）或不投票（表示不赞成）。每轮 ballot 都关联一个&lt;strong&gt;法定人数集（quorum）&lt;/strong&gt;的牧师集合。只有当 quorum 中的每一位牧师都投票，这轮 ballot 才算成功。一轮 ballot B 包括以下四个元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B(dec): 被投票的法令&lt;/li&gt;
&lt;li&gt;B(qrm): 该轮 ballot 的 quorum&lt;/li&gt;
&lt;li&gt;B(vot): 投票的牧师集合&lt;/li&gt;
&lt;li&gt;B(bal): ballot 的编号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当且仅当 B(qrm) ⊆ B(vot) 时，这轮 ballot 才算成功。&lt;strong&gt;B(bal) 值的大小和进行 ballot 的顺序无关，B(bal) 比较大的 ballot 有可能在 B(bal) 比较小的 ballot 之前发生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Paxos 数学家在由多轮 ballot 组成的集合 𝜷 上定义了三个约束条件，如果集合中的 ballot 都满足这些条件，则可以保证一致性会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(𝜷): 𝜷 中的每一轮 ballot 都拥有唯一的编号&lt;/li&gt;
&lt;li&gt;B2(𝜷): 𝜷 中任意两轮 ballot 的 quorum 至少有一个公共成员&lt;/li&gt;
&lt;li&gt;B3(𝜷): 𝜷 中任意一轮 ballot B，如果 B(qrm) 中任何一个牧师在 𝜷 中更早的 ballot 中投过票，则 B(dec) 与所有更早的 ballots 中最后那轮 ballot 的法令相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是对 B3(𝜷) 的图解。五轮 ballot 组成集合 𝜷，A、B、Γ、∆ 和 E 表示五位牧师，方框圈起的表示投票的牧师。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编号 2 是最早的一轮 ballot，因此显而易见三个条件都满足（没有比他更早的 ballot了）&lt;/li&gt;
&lt;li&gt;编号 5 的 ballot，四位 quorum 都没有在更早的 ballot 中投过票，因此三个条件也满足&lt;/li&gt;
&lt;li&gt;编号 14 的 ballot 中，∆ 是 quorum 中唯一一位在更早的 ballot 中投过票的，因此这一轮的法令必须和编号为 2 的 ballot 一致，都为 𝜶&lt;/li&gt;
&lt;li&gt;编号 27 是一轮成功的 ballot，A、Γ 和 ∆ 为该轮的 quorum 成员。Γ 在编号 5 的 ballot 中投过票，∆ 在编号为 2 的 ballot 中投过票，根据 B3(𝜷)，这一轮的法令必须和编号 5 的法令一致（编号 5 比编号 2 更新）&lt;/li&gt;
&lt;li&gt;编号 29 的 quorum 成员为 B、Γ 和 ∆。B 在编号 14 的 ballot 投过票，Γ 在编号 5 和 27 的 ballots 都投过票，∆ 在编号为 2 和 27 的ballots 也投过票，这些 ballots 中最新的编号为 27，因此这轮 ballot 的法令必须和编号 27 的法令一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面给出 B1(𝜷) B2(𝜷) B3(𝜷) 的数学定义：&lt;/p&gt;

&lt;p&gt;符号 v 表示一次投票，其中 v(pst) 表示投票的牧师，v(bal) 表示投票的编号，v(dec) 表示投票的法令。集合 Votes(𝜷) 表示满足以下条件的投票 v 的集合：v(pst) ∈ B(vot)，v(bal) = B(bal)，v(dec) = B(dec)，B ∈ 𝜷。定义 p 为牧师，b 为 ballot 编号，则 MaxVote(b, p, 𝜷) 表示集合 &lt;strong&gt;{ v ∈ Votes(B): (v(pst) = p) ∧ (v(bal) &amp;lt; b) } ∪ { null(p) }&lt;/strong&gt; 中 ballot 最大的投票。&lt;em&gt;注：null(p) 表示 null 投票，即 v(bal) 为-∞, v(dec) 为 BLANK 且 v(pst) = p&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对任意非空的牧师集合 Q，MaxVote(b, Q, 𝜷) 定义为 Q 中的所有牧师 p 的 MaxVote(b, p, 𝜷) 的最大值。&lt;em&gt;注：翻译得不太妥当，原文：For any nonempty set Q of priests, MaxVote(b, Q, B) was defined to equal the maximum of all votes MaxVote(b, p, B) with p in Q.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;B1(𝜷) B2(𝜷) B3(𝜷) 的数学定义如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(𝜷) ≜ ∀B, B&amp;#39; ∈ 𝜷 : (B ≠ B&amp;#39;) ⇒ (B(bal) ≠ B&amp;#39;(bal))&lt;/li&gt;
&lt;li&gt;B2(𝜷) ≜ ∀B, B&amp;#39; ∈ 𝜷 : B(qrm) ∩ B&amp;#39;(qrm) ≠ ∅&lt;/li&gt;
&lt;li&gt;B3(𝜷) ≜ ∀B ∈ 𝜷 : (MaxVote(B(bal) , B(qrm), 𝜷)bal ≠ −∞) ⇒ (B(dec) = MaxVote(B(bal) , B(qrm) , 𝜷)dec)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;引理：如果满足 B1(𝜷) B2(𝜷) B3(𝜷)，则 ((B(qrm) ⊆ B(vot)) ∧ (B&amp;#39;(bal) &amp;gt; B(bal))) ⇒ (B(dec) = B&amp;#39;(dec))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引理证明如下：&lt;/p&gt;

&lt;p&gt;对 𝜷 中任意 ballot B，定义 Ψ(B, 𝜷) 表示 𝜷 中所有编号大于 B(bal) 且法令不等于 B(dec) 的 ballot 的集合：&lt;strong&gt;Ψ(B, 𝜷) ≜ {B&amp;#39; ∈ 𝜷 : (B&amp;#39;(bal) &amp;gt; B(bal) ∧ (B&amp;#39;(dec) ≠ B(dec))}&lt;/strong&gt;。如果证明 B(qrm) ⊆ B(vot) 则 Ψ(B, 𝜷) 为空，引理即成立。下面是反证法，假设存在 B 满足 B(qrm) ⊆ B(vot) 且 Ψ(B, 𝜷) 不为空，下面推导得出矛盾的结论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选择 C ∈ Ψ(B, B) 满足 C(bal) = min{ B&amp;#39;(bal) : B&amp;#39; ∈ Ψ(B, 𝜷)}&lt;/li&gt;
&lt;li&gt;C(bal) &amp;gt; B(bal)：由 1 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;B(vot) ∩ C(qrm) ≠ ∅：由 B2(𝜷) 和 B(qrm) ⊆ B(vot) 得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal ≥ B(bal)：由 2、3 和 MaxVote 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷) ∈ Votes(B)：由 4 知道 MaxVote(C(bal), C(qrm) , 𝜷) 不是 null 投票&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)dec = C(dec)：由 5 和 B3(𝜷) 得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)dec ≠ B(dec)：由 6、1 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal &amp;gt; B(bal)：由 4 7 和 B1(𝜷) 的出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷) ∈ Votes(Ψ(B, 𝜷))：由 7 8 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal &amp;lt; C(bal)：由 MaxVote(C(bal), C(qrm), 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;由 9 10 1 得出矛盾，因为 1 中定义了 C(bal) 是 Ψ(B, 𝜷) 中编号最小的，由 9 知道 MaxVote(C(bal), C(qrm), 𝜷) 属于 Votes(Ψ(B, 𝜷))，那么 MaxVote(C(bal), C(qrm), 𝜷) 必须大于等于 C(bal)，这与 10 得到的 MaxVote(C(bal), C(qrm), 𝜷)bal &amp;lt; C(bal) 矛盾&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由引理得出，如果满足 B1(𝜷) B2(𝜷) B3(𝜷)，则任意两轮成功的 ballots 都是相同的法令，数学表示：&lt;strong&gt;((B(qrm) ⊆ B(vot)) ∧ (B&amp;#39;(qrm) ⊆ B&amp;#39;(vot))) ⇒ (B&amp;#39;dec = Bdec)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;The Preliminary Protocol&lt;/h2&gt;

&lt;p&gt;为了遵守 B3(𝜷)，牧师在发起表决前需要先确定 MaxVote(b, Q, 𝜷)dec，因此需要确定 Q 中的每一个 p 的 MaxVote(b, q, 𝜷)dec。Preliminary protocol 的前两步如下：&lt;/p&gt;

&lt;p&gt;(1) 牧师 p 选择新的 ballot number b，发送一条 NextBallot(b) 消息给某些牧师&lt;/p&gt;

&lt;p&gt;(2) 牧师 q 收到 NextBallot(b) 消息后，发送 LastVote(b, v) 消息给 p，v 为 MaxVote(b, q, 𝜷)&lt;/p&gt;

&lt;p&gt;发送完 LastVote(b, v)，&lt;strong&gt;q 承诺不再给编号在 [v(bal), b] 区间的表决投票。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：这个承诺是为了解决乱序的问题， ballot 编号大的投票发生在编号小的之前时，如下图，B 和 C 投票的法令出现了不一致［参考自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21438357&quot;&gt;Paxos理论介绍(1): 朴素Paxos算法理论推导与证明&lt;/a&gt;］：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来两个步骤是：&lt;/p&gt;

&lt;p&gt;(3) 在收到 majority 的 LastVote(b, v) 之后，p 发起一轮编号为 b，quorum 为 Q 且法令为 d（d 需要满足B3(𝜷)）的表决，给 Q 中每一个牧师发送 BeginBallot(b, d) 消息&lt;/p&gt;

&lt;p&gt;(4) 在收到 BeginBallot(b, d) 消息后，q 决定是否投票，如果可以投票（不违背上面的承诺），则发送 Voted(b, q) 消息给 p&lt;/p&gt;

&lt;p&gt;步骤 3 将表决 B 加入到集合 𝜷 中，其中 B(bal) = b，B(qrm) = Q，B(vot) = ∅。步骤 4 中，如果牧师 q 投票了，则将 q 加入 B(vot) 中。&lt;/p&gt;

&lt;p&gt;协议的剩余步骤如下：&lt;/p&gt;

&lt;p&gt;(5) 如果 p 收到了 Q 中每一个 q 的 Voted(b, q) 消息，那么 p 在律簿上记录下法令 d，并且发送 Success(d) 给每一个牧师&lt;/p&gt;

&lt;p&gt;(6) 牧师 q 收到 Success(d) 消息后，将法令 d 记录在自己的律簿上&lt;/p&gt;

&lt;h2&gt;The Basic Protocol&lt;/h2&gt;

&lt;p&gt;在 preliminary protocol 中，每一个牧师都必须记录 &lt;strong&gt;(i) 他发起的每一个ballot number (ii) 他投过的每一次票 (iii) 他发送过的每一个 LastVote 消息&lt;/strong&gt;。要记录这么多信息是非常困难的，因此 Paxos 人对 preliminary protocol 做了进一步约束，得到更实用的 basic protocol，每个牧师只需要在律簿上记录下面三个信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lastTried[p]&lt;/strong&gt;：p 发起的最后一个表决的编号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prevVote[p]&lt;/strong&gt;：p 投过的所有表决中编号最大的那次投票&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextBal[p]&lt;/strong&gt;：p 发过的所有 LastVote(b, v) 消息中 b 的最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preliminary protocol 允许牧师并行管理任意数量的表决，basic protocol 中牧师在一个时间内只管理一个表决，编号为 lastTried[p]，忽略和之前发起的表决相关的消息。Basic protocol 中对 LastVote 做了更强的承诺：&lt;strong&gt;不再对编号小于 b 的表决进行投票。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basic protocol 步骤如下：&lt;/p&gt;

&lt;p&gt;(1) 牧师 p 选择新的 ballot number b，必须大于 lastTried[p]，并更新 lastTried[p] 置为 b，然后发送 NextBallot(b) 消息给某些牧师&lt;/p&gt;

&lt;p&gt;(2) 牧师 q 收到 NextBallot(b) 消息，如果 b 大于 nextBal(q)，则更新 nextBal(q) 置为 b 并发送 LastVote(b, v) 消息给 p，v 即 prevVote[q]。如果 b 小于等于 nextBal(q) 则忽略该 NextBallot 消息。&lt;/p&gt;

&lt;p&gt;(3) 在收到 majority 的 LastVote(b, v) 消息后，如果 b 等于 lastTried[p]，则 p 发起一轮新的表决，指定编号为 b，quorum 为 Q，法令为 d，d 需要满足 B3(𝜷)。p 发送 BeginBallot(b, d) 消息给 Q 中所有牧师。&lt;/p&gt;

&lt;p&gt;(4) 在收到 BeginBallot(b, d) 消息后，如果 b 等于 nextBal[q]，牧师 q 投票，并将 prevVote[q] 设置为本次投票，然后发送 Voted(b, q) 消息给 p。如果 b 不等于 nextBal[q]，则忽略该 BeginBallot 消息&lt;/p&gt;

&lt;p&gt;(5) 如果 p 收到 Q 中所有牧师的 Voted(b, q) 消息，并且 b 等于 lastTried[p]，他在律簿上记录下法令 d，并发送 Success(d) 消息给所有的牧师。&lt;/p&gt;

&lt;p&gt;(6) 在收到 Success(d) 消息后，牧师在律簿上记录下法令 d&lt;/p&gt;

&lt;p&gt;Basic protocol 是 preliminary protocol 的约束版本，preliminary protocol 满足一致性的条件，那么 basic protocol 也一定满足。不过和 preliminary protocol 一样，basic protocol 也没要求必须执行某个操作，因此同样没有解决进展性的问题。&lt;/p&gt;

&lt;h2&gt;The Complete Synod Protocol&lt;/h2&gt;

&lt;p&gt;为了保证进展性，&lt;strong&gt;关键在于决定牧师什么时候应该发起表决&lt;/strong&gt;。永远不发起表决和太频繁的发起表决都会影响进展性。完整的神会协议在 basic protocol 的基础上新增一个流程来选择唯一的牧师--总统，来发起表决。这部分细节参照论文的 2.4 节。&lt;/p&gt;

&lt;h1&gt;The Multi-Decree Parliament&lt;/h1&gt;

&lt;h2&gt;The Protocol&lt;/h2&gt;

&lt;p&gt;Paxos 议会需要通过一系列法令而不仅仅单一一个法令。法令提议给总统，由总统赋予 ballot number 并尝试通过它。协议对每个法令使用不同实例的 Complete Synod Protocol，但这系列实例只需要一位总统来负责，并且神会协议的前两步只需要执行一次。&lt;/p&gt;

&lt;p&gt;在神会协议中，总统在第三步之前不会选择法令和 quorum，因此总统可以为所有实例发送一条 NextBallot(b) 消息，议员回复一条 LastVote 消息，规则和单一法令的协议相同，只是把所有待表决的实例信息包含在一条 LastVote 信息里。&lt;/p&gt;

&lt;p&gt;当总统收到 majority 的回复后，就为每个待表决的实例执行 Complete Synod Protocol 的第三步。&lt;/p&gt;

&lt;p&gt;因此 Paxon 的议会协议如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已经知道结果的表决不再需要再走一遍 Complete Synod Protocol 的流程，因此当新选举的总统 p 在律簿上已经记录有编号小于等于 n 的法令，那他将发送 NextBallot(b, n) 代替之前的 NextBallot(b) 消息。议员收到 NextBallot 消息后，将他律簿上所有编号大于 n 的法令返回给 p，并且告诉 p 他缺失的编号小于等于 n 的法令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Properties of the Protocol&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在总统提议任何法令之前，必须先向 majority 学习他们已经投过票的法令。&lt;/strong&gt;任何一个已经通过的法令一定被至少一个多数集合中的议员投过票。这样就保证了总统在提议新法令前律簿上不会有空缺。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 20:36:16 +0800</pubDate>
        <link>http://masutangu.com/2018/03/the-part-time-parliament-note/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/the-part-time-parliament-note/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>多排行榜数据刷新方案</title>
        <description>&lt;h2&gt;一. 背景&lt;/h2&gt;

&lt;p&gt;最近工作遇到一个棘手的问题：&lt;strong&gt;多个不同的排行榜的玩家信息如何保持一致&lt;/strong&gt;。简单描述下场景，以小游戏跳一跳为例子，一开始游戏只有一个好友排行榜，好友排行榜以玩家的最高分数进行排序，这样好处理，搭一个关系链svr，该 svr 上缓存玩家好友的信息（避免每次去 DB 查询），并使用玩家信息中的最高分数进行排序。客户端请求时下方相应的排名和玩家信息，包括最高分数信息（客户端需要展示）即可。但如果我们要新增一个全国排行榜，全国排行榜以玩家的最高步数＋耗时进行排行。这时需要搭一个全国排行榜svr，该svr上同样缓存进入全国排行榜的玩家的信息，使用玩家信息中的最高分数＋耗时进行排序。同样的在客户端请求时下发相应的排名和玩家信息。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;方案一：各个排行榜有自己的玩家缓存：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二. 问题&lt;/h2&gt;

&lt;p&gt;但问题来了，&lt;strong&gt;如何保证出现在两个榜单的同一玩家数据是一致的？&lt;/strong&gt;（不一致是因为两个排行 svr 分别缓存了玩家的信息，每个svr的排行数据缓存刷新周期也不一致）。&lt;/p&gt;

&lt;p&gt;这时候就需要使用一个全局的 data svr 来缓存玩家的信息，&lt;strong&gt;保证不同排行 svr 取到的玩家数据是一致的，同时两个排行svr刷新缓存的周期需要保持一致&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;方案二：每个排行榜都从data svr 拉取玩家数据：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据源都从 data svr 拉取这个很简单，关键在于&lt;strong&gt;如何让不同排行榜的刷新周期保持一致&lt;/strong&gt;。本文提出一个不成熟有待考验的方案解决这个问题，并给出简单的协议例子说明。&lt;/p&gt;

&lt;h2&gt;三. 方案&lt;/h2&gt;

&lt;h3&gt;1. 协议&lt;/h3&gt;

&lt;p&gt;CSProto 表示从客户端到服务器的协议，SSProto 表示服务器之间的协议。Common 为公用协议。定义排行榜相关协议如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;公用协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package Common;

message PlayerInfo {
    int32 uid              = 1;  // 玩家 uid
    int64 udpate_timestamp = 2;  // 玩家信息的更新时间
    // 玩家信息 包括例如最高分 耗时 具体字段略过略
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;客户端和服务器之间的协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import &amp;quot;common.proto&amp;quot;;

package CSProto;

message RankReq {
    int32 rank_type = 1; // 排行榜类型 例如好友排行榜 全国排行榜
}

message RankInfo {
    Common.PlayerInfo info = 1; // 玩家信息 客户端展示用
    int32 rank_idx         = 2; // 玩家排名
}

message RankRes {
    int32 rank_type             = 1; // 排行榜类型 例如好友排行榜 全国排行榜
    repeated RankInfo rank_list = 2; // 排行数据
    int64 update_timestamp      = 3; // 排行榜更新时间
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;服务器和服务器之间的协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package SSProto;

message GetPlayerInfoReq {
    repeated int32 uid_list = 1;
} 

message GetPlayerInfoRes {
    repeated Common.PlayerInfo info_list = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;消息流如下：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2. 保证排行榜 svr 刷新周期一致&lt;/h3&gt;

&lt;p&gt;排行榜 svr 从 Data svr 中拉取玩家的信息进行排序，而 Data svr 会定期去更新玩家的信息，可以推导出：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;排行榜的刷新时间等于max(排行榜上榜的玩家数据的更新时间戳)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此回包给客户端的 RankRes 中的 update_timestamp 取值的伪代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_res.update_timestamp =  max([rankinfo.info.udpate_timestamp for rankinfo in rank_res.rank_list])
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;客户端使用 map 来管理每个排行榜的更新时间：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# rank_map
&amp;lt;ranktype1, udpate_timestamp1&amp;gt;
&amp;lt;ranktype2, update_timestamp2&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;并定义所有排行榜的最新更新时间 rank_max_update_timestamp，取值伪代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_max_update_timestamp = max([update_timestamp for _, update_timestamp in rank_map]) 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当玩家点击某个排行榜，客户端发现该排行榜的 update_timestamp 小于 rank_max_update_timestamp，就能判定该排行榜上存在过时的玩家数据，这时就应该向后台发起 RankReq 获取排行榜请求。&lt;strong&gt;通过及时请求过时排行榜数据，保证每个排行榜的 update_timestamp 一致，就能保证排行榜上玩家信息的一致，也就保证了在多个排行榜上玩家信息的一致。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3. 优化&lt;/h3&gt;

&lt;p&gt;上面提到，每次 update_timestamp 小于 rank_max_update_timestamp，客户端都会重新请求一次排行榜，后台会返回最新的排行榜数据，这里其实可以做下优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-4.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;客户端先请求了 ranktype1 的排行榜，可以看出 ranktype1 的 update_timestamp 为 t1。之后又请求了 rank_type2 的排行榜，返回 ranktype2 的 update_timestamp 为 t2。由于 t1 &amp;lt; t2，客户端会发现需要更新 ranktype1。但从图上可以看出其实后台不需要再返回一次 ranktype1 的排行数据了（ranktype1 榜上的玩家 uid1 uid2 uid3 的数据并没有变化）。因此我们在 RankReq 里加上客户端本地该排行榜的 update_timestamp，如果后台发现客户端的 update_timestamp 和后台的是一致的，就返回特定的错误码告诉客户端排行榜依然有效。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;新增客户端本地该排行榜的 update_timestamp：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;message RankReq {
    int32 rank_type               = 1; // 排行榜类型 例如好友排行榜 全国排行榜
    int64 client_update_timestamp = 2; // 客户端本地该排行榜的 update_timestamp
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;采用这种方式的话，每次点击该排行榜客户端还是需要发起一次（无效）的后台请求，如何做优化呢？这里用了一个简单的方案，如果客户端收到排行榜依然有效的错误码，就把本地该排行榜 update_timestamp 更新为 rank_max_update_timestamp：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-5.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;每次客户端请求，rank svr 都需要到 data svr 查询玩家信息。可以在 rank svr 上缓存玩家的信息，到 data svr 查询时如果玩家数据无变化，则返回特定错误码，rank svr 继续使用本地的玩家信息缓存。&lt;/p&gt;

&lt;h2&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;本文提出了一个有待考验的多排行榜数据刷新方案，为解决多个排行榜数据不一致的问题。该方案还有一些细节有待考量，欢迎大家有任何想法或有更好的方案邮件我一起讨论。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 09:00:42 +0800</pubDate>
        <link>http://masutangu.com/2018/03/multi-rank-refresh-design/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/multi-rank-refresh-design/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>Programming Language 课程笔记</title>
        <description>&lt;p&gt;本文是学习&lt;a href=&quot;https://www.coursera.org/learn/programming-languages/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;课程的学习笔记，文章内容及代码均取自课程材料。&lt;/p&gt;

&lt;h2&gt;一. 声明式编程和命令式编程&lt;/h2&gt;

&lt;h4&gt;声明式编程（Declarative Programming）&lt;/h4&gt;

&lt;p&gt;Building the structure and elements of computer programs, that &lt;strong&gt;expresses the logic of a computation without describing its control flow&lt;/strong&gt;.&lt;/p&gt;

&lt;h4&gt;命令式编程（Imperative Programming）&lt;/h4&gt;

&lt;p&gt;Describes computation &lt;strong&gt;in terms of statements that change a program state&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;左图为 Declarative Programming 范式，右图为 Imperative Programming 范式：&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二. 函数式编程&lt;/h2&gt;

&lt;p&gt;三大特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No Mutation&lt;/li&gt;
&lt;li&gt;First Class Function&lt;/li&gt;
&lt;li&gt;Tail Recursion Optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;1. No Mutation&lt;/h3&gt;

&lt;p&gt;知乎上&lt;a href=&quot;https://www.zhihu.com/question/28292740&quot;&gt;《什么是函数式编程思维》&lt;/a&gt;其中一个回到写得很好：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;函数式编程的本质：
函数式编程中的&lt;strong&gt;函数&lt;/strong&gt;这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。在函数式语言中，&lt;strong&gt;函数作为一等公民&lt;/strong&gt;，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。纯函数式编程语言中的&lt;strong&gt;变量&lt;/strong&gt;也不是命令式编程语言中的变量表示存储状态的单元，而是&lt;strong&gt;代数中的变量&lt;/strong&gt;，即一个值的名称。变量的值是&lt;strong&gt;不可变的（immutable）&lt;/strong&gt;，也就是说不允许像命令式编程语言中那样多次给一个变量赋值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有 Mutation 带来的好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No code can ever distinguish aliasing vs. identical copies&lt;/li&gt;
&lt;li&gt;No need to think about aliasing: focus on other things&lt;/li&gt;
&lt;li&gt;Can use aliasing, which saves space, without danger &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. How to build bigger types&lt;/h3&gt;

&lt;p&gt;3 most important type building-blocks in any language&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Each of&lt;/strong&gt;: A t value contains values of each of t1 t2 … tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One of&lt;/strong&gt;: A t value contains values of one of t1 t2 … tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self reference&lt;/strong&gt;: A t value can refer to other t values&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3. Tail Recursion and Accumulators&lt;/h3&gt;

&lt;p&gt;ML recognizes these tail calls in the compiler and treats them differently: &lt;strong&gt;pop the caller before the call, allowing callee to reuse the same stack space&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;非尾递归的调用堆栈&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;尾递归优化后的调用堆栈&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4. Higher Order Function&lt;/h3&gt;

&lt;h4&gt;Map&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun map (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xs’ =&amp;gt; (f x)::(map(f,xs’))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Filter&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun filter (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xs’ =&amp;gt; if f x
 then x::(filter(f,xs’))
 else filter(f,xs’)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Fold&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun fold f acc xs =
 case xs of
 [] =&amp;gt; acc
 | x::xs’ =&amp;gt; fold f (f(acc,x)) xs’
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Higher Order Function vs For Loop&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Fold&lt;/strong&gt;  is another very famous iterator over recursive structures. This pattern separates recursive traversal from data processing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same traversal for different data processing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same data processing for different data structures&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In both cases, using common vocabulary concisely communicates intent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;遍历函数和处理函数分离，提高复用性。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;5. Function Closure&lt;/h3&gt;

&lt;p&gt;A function value has two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The code&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The environment&lt;/strong&gt; that was current when the function was defined&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This pair is called a &lt;strong&gt;function closure&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;6. Abstract Data Types With Closure&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;datatype set = S of { insert : int -&amp;gt; set, 
              member : int -&amp;gt; bool, 
              size   : unit -&amp;gt; int }

val empty_set =
    let
        fun make_set xs = (* xs is a &amp;quot;private field&amp;quot; in result *)
            let (* contains a &amp;quot;private method&amp;quot; in result *)
                fun contains i = List.exists (fn j =&amp;gt; i=j) xs
            in
                S { insert = fn i =&amp;gt; if contains i 
                                     then make_set xs 
                                     else make_set (i::xs),
                    member = contains,
                    size   = fn () =&amp;gt; length xs
                  }
            end
    in
        make_set []
    end 

fun use_sets () =
    let val S s1 = empty_set
        val S s2 = (#insert s1) 34
        val S s3 = (#insert s2) 34
        val S s4 = #insert s3 19
    in
        if (#member s4) 42
        then 99
        else if (#member s4) 19
        then 17 + (#size s3) ()
        else 0
    end 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;使用 Java 实现：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;interface Func&amp;lt;B,A&amp;gt; {
    B m(A x);
}
interface Pred&amp;lt;A&amp;gt; {
    boolean m(A x);
}

class List&amp;lt;T&amp;gt; {
    T       head;
    List&amp;lt;T&amp;gt; tail;
    List(T x, List&amp;lt;T&amp;gt; xs) {
    head = x;
    tail = xs;
    }

    // * the advantage of a static method is it allows xs to be null
    //    -- a more OO way would be a subclass for empty lists
    // * a more efficient way in Java would be a messy while loop
    //   where you keep a pointer to the previous element and mutate it
    //   -- (try it if you do not believe it is messy)
    static &amp;lt;A,B&amp;gt; List&amp;lt;B&amp;gt; map(Func&amp;lt;B,A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        return new List&amp;lt;B&amp;gt;(f.m(xs.head), map(f,xs.tail));
    }

    static &amp;lt;A&amp;gt; List&amp;lt;A&amp;gt; filter(Pred&amp;lt;A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        if(f.m(xs.head))
            return new List&amp;lt;A&amp;gt;(xs.head, filter(f,xs.tail));
        return filter(f,xs.tail);
    }

    // * again recursion would be more elegant but less efficient
    // * again an instance method would be more common, but then
    //   all clients have to special-case null 
    static &amp;lt;A&amp;gt; int length(List&amp;lt;A&amp;gt; xs) {
        int ans = 0;
        while(xs != null) {
            ++ans;
            xs = xs.tail;
        }
        return ans;
    }
}

class ExampleClients {
    static List&amp;lt;Integer&amp;gt; doubleAll(List&amp;lt;Integer&amp;gt; xs) {
        return List.map((new Func&amp;lt;Integer,Integer&amp;gt;() { 
                     public Integer m(Integer x) { return x * 2; } 
                         }), xs);
    }
    static int countNs(List&amp;lt;Integer&amp;gt; xs, final int n) {
        return List.length(List.filter(
           (new Pred&amp;lt;Integer&amp;gt;() { 
               public boolean m(Integer x) { return x==n; } 
           }), xs));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;使用 C 实现:&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;typedef struct List list_t;
struct List {
  void * head;
  list_t * tail;
};

list_t * makelist (void * x, list_t * xs) {
  list_t * ans = (list_t *)malloc(sizeof(list_t));
  ans-&amp;gt;head = x;
  ans-&amp;gt;tail = xs;
  return ans;
}

list_t * map(void* (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  return makelist(f(env,xs-&amp;gt;head), map(f,env,xs-&amp;gt;tail));
}

list_t * filter(bool (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  if(f(env,xs-&amp;gt;head))
    return makelist(xs-&amp;gt;head, filter(f,env,xs-&amp;gt;tail));
  return filter(f,env,xs-&amp;gt;tail);
}

int length(list_t* xs) {
  int ans = 0;
  while(xs != NULL) {
    ++ans;
    xs = xs-&amp;gt;tail;
  }
  return ans;
}

// clients of our list implementation:
// [the clients that cast from void* to intptr_t are technically not legal C, 
//  as explained in detail below if curious]

// awful type casts to match what map expects
void* doubleInt(void* ignore, void* i) {
  return (void*)(((intptr_t)i)*2);
}

// assumes list holds intptr_t fields
list_t * doubleAll(list_t * xs) {
  return map(doubleInt, NULL, xs);
}

// awful type casts to match what filter expects
bool isN(void* n, void* i) {
  return ((intptr_t)n)==((intptr_t)i);
}

// assumes list hold intptr_t fields
int countNs(list_t * xs, intptr_t n) {
  return length(filter(isN, (void*)n, xs));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Fri, 02 Mar 2018 19:45:24 +0800</pubDate>
        <link>http://masutangu.com/2018/03/programing-language/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/programing-language/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
  </channel>
</rss>
