<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Masutangu</title>
    <description>也許我這一生　始終在追逐那顆九號球</description>
    <link>http://masutangu.com/</link>
    <atom:link href="http://masutangu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 05 Jul 2018 21:16:57 +0800</pubDate>
    <lastBuildDate>Thu, 05 Jul 2018 21:16:57 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>etcd-raft 源码学习笔记（Linearizable Read 篇）</title>
        <description>&lt;p&gt;这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 &lt;a href=&quot;https://aphyr.com/posts/313-strong-consistency-models&quot;&gt;《Strong consistency models》&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;raft 论文第 8 节阐述了思路：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在收到读请求时，leader 节点保存下当前的 commit index，并往 peers 发送心跳。如果确定该节点依然是 leader，则只需要等到该 commit index 的 log entry 被 apply 到状态机时就可以返回客户端结果。&lt;/p&gt;

&lt;p&gt;我们先通过位于 etcd/etcdserver 目录下的样例来看看应用层是如何使用 ReadIndex 来保证 linearizable read 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// v3_server.go

type RaftKV interface {
    Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)
    Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)
    DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)
    Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)
    Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
}

func (s *EtcdServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
    var resp *pb.RangeResponse
    var err error

    if !r.Serializable {
        err = s.linearizableReadNotify(ctx)  // 等待 linearizableReadNotify 返回 才能继续往下走
        if err != nil {
            return nil, err
        }
    }
    // 读取数据逻辑 省略..
    ...
    return resp, err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在读请求 &lt;code&gt;Range&lt;/code&gt; 执行前，调用了 &lt;code&gt;linearizableReadNotify&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *EtcdServer) linearizableReadNotify(ctx context.Context) error {
    s.readMu.RLock()
    nc := s.readNotifier
    s.readMu.RUnlock()

    // signal linearizable loop for current notify if it hasn&amp;#39;t been already
    select {
    case s.readwaitc &amp;lt;- struct{}{}:
    default:
    }

    // wait for read state notification
    select {
    case &amp;lt;-nc.c:
        return nc.err
    case &amp;lt;-ctx.Done():
        return ctx.Err()
    case &amp;lt;-s.done:
        return ErrStopped
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;linearizableReadNotify&lt;/code&gt; 往 &lt;code&gt;readwaitc&lt;/code&gt; 发送个空的结构体，并且等待 &lt;code&gt;nc.c&lt;/code&gt; 的返回。&lt;code&gt;readwaitc&lt;/code&gt; 是在另外的 goroutine &lt;code&gt;linearizableReadLoop&lt;/code&gt; 里监听的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;
func (s *EtcdServer) linearizableReadLoop() {
    var rs raft.ReadState

    for {
        ctx := make([]byte, 8)
        binary.BigEndian.PutUint64(ctx, s.reqIDGen.Next())  // ctx 即请求唯一标识 reqId

        select {
        case &amp;lt;-s.readwaitc:  // 监听 readwaitc
        case &amp;lt;-s.stopping:
            return
        }

        nextnr := newNotifier()
        nr := s.readNotifier
        s.readNotifier = nextnr

        s.r.ReadIndex(cctx, ctx)  // 调用 ReadIndex 接口，往 recvc channel 发送 type 为 pb.MsgReadIndex 的请求

        var (
            timeout bool
            done    bool
        )
        for !timeout &amp;amp;&amp;amp; !done {
            select {
            case rs = &amp;lt;-s.r.readStateC:  // 收到 ready 对象时，会往 readStateC channel 传回来 readState，见 etcd/etcdserver/raft.go 文件的 func (r *raftNode) start(rh *raftReadyHandler)
                done = bytes.Equal(rs.RequestCtx, ctx)  // 比较下 reqId 是否一致
            case &amp;lt;-time.After(s.Cfg.ReqTimeout()):
                nr.notify(ErrTimeout)
                timeout = true
            case &amp;lt;-s.stopping:
                return
            }
        }
        if !done {
            continue
        }

        // 等待 readState 里的 index，也就是收到 pb.MsgReadIndex 请求时，leader 节点当前的 commit index 被 apply 到状态机时，此时调用 nr.notify(nil) 通知应用层可以读取状态机里的数据了，确保读到的不是 stale 数据
        if ai := s.getAppliedIndex(); ai &amp;lt; rs.Index {
            select {
            case &amp;lt;-s.applyWait.Wait(rs.Index):
            case &amp;lt;-s.stopping:
                return
            }
        }
        // unblock all l-reads requested at indices before rs.Index
        nr.notify(nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;linearizableReadLoop&lt;/code&gt; 调用 &lt;code&gt;nr.notify&lt;/code&gt; 后，&lt;code&gt;linearizableReadNotify&lt;/code&gt; 从 select 阻塞中返回，此时就可以继续走 &lt;code&gt;Range&lt;/code&gt; 的逻辑，读取数据，返回给客户端。&lt;/p&gt;

&lt;p&gt;从上面的例子，我们了解了应用层如何使用 Node 的 &lt;code&gt;ReadIndex&lt;/code&gt; 接口来实现 linearizable read。下面我们来介绍 &lt;code&gt;ReadIndex&lt;/code&gt; 这个新接口：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()

    // ReadIndex request a read state. The read state will be set in the ready.
    // Read state has a read index. Once the application advances further than the read
    // index, any linearizable read requests issued before the read request can be
    // processed safely. The read state will have the same rctx attached.
    ReadIndex(ctx context.Context, rctx []byte) error
}

func (n *node) ReadIndex(ctx context.Context, rctx []byte) error {
    return n.step(ctx, pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上篇文章 &lt;a href=&quot;http://masutangu.com/2018/07/etcd-raft-note-2/&quot;&gt;《etcd-raft 源码学习笔记（概览篇）》&lt;/a&gt; 提到当节点为 leader 时，&lt;code&gt;step&lt;/code&gt; 被设置为 &lt;code&gt;stepLeader&lt;/code&gt; 。我们来看看 &lt;code&gt;stepLeader&lt;/code&gt; 是如何处理 type 为 pb.MsgReadIndex 的 readIndexReq 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgReadIndex:
        // raft 5.4 safty 检查
        if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
            // Reject read only request when this leader has not committed any log entry at its term.
            return nil
        }

        // thinking: use an interally defined context instead of the user given context.
        // We can express this in terms of the term and index instead of a user-supplied value.
        // This would allow multiple reads to piggyback on the same message.
        switch r.readOnly.option {
        case ReadOnlySafe:
            r.readOnly.addRequest(r.raftLog.committed, m)  // r.raftLog.committed 为 当前 commit index
            r.bcastHeartbeatWithCtx(m.Entries[0].Data)  // 广播心跳包
        }
        return nil
    }
    return nil
}


&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;收到 readIndexReq 后，首先调用 &lt;code&gt;r.readOnly.addRequest&lt;/code&gt; 保存下，然后调用 &lt;code&gt;bcastHeartbeatWithCtx&lt;/code&gt; 广播心跳包， ctx 即唯一标识 readIndexReq 的 reqId。&lt;/p&gt;

&lt;p&gt;来看看 raft 是如何管理 readIndexReq 的：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// addRequest adds a read only reuqest into readonly struct.
// `index` is the commit index of the raft state machine when it received
// the read only request.
// `m` is the original read only request message from the local or remote node.
func (ro *readOnly) addRequest(index uint64, m pb.Message) {
    ctx := string(m.Entries[0].Data)  // ctx 即 reqId
    if _, ok := ro.pendingReadIndex[ctx]; ok {
        return
    }
    ro.pendingReadIndex[ctx] = &amp;amp;readIndexStatus{index: index, req: m, acks: make(map[uint64]struct{})}  // acks 用于记录哪些 peer 已经 ack 确认。之后用于统计是否大于 quonum
    ro.readIndexQueue = append(ro.readIndexQueue, ctx)  // append 进 readIndexQueue
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;再看看 &lt;code&gt;stepLeader&lt;/code&gt; 如何处理心跳回包：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgHeartbeatResp:
        pr.RecentActive = true
        pr.resume()

        if r.readOnly.option != ReadOnlySafe || len(m.Context) == 0 {
            return nil
        }

        ackCount := r.readOnly.recvAck(m)
        if ackCount &amp;lt; r.quorum() {  // 判断是否收到 quorum 的心跳回包
            return nil
        }

        // 收到 quorum 的心跳回包了，把 readIndexReq 依次 append r.readStates 中，返回 ready 对象时会包含 r.readStates
        rss := r.readOnly.advance(m)
        for _, rs := range rss {
            req := rs.req
            if req.From == None || req.From == r.id { // from local member
                r.readStates = append(r.readStates, ReadState{Index: rs.index, RequestCtx: req.Entries[0].Data})
            } else {
                r.send(pb.Message{To: req.From, Type: pb.MsgReadIndexResp, Index: rs.index, Entries: req.Entries})
            }
        }
    return nil
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;调用 &lt;code&gt;r.readOnly.recvAck&lt;/code&gt;，根据 readIndeReq 的 reqId 统计收到心跳回包的数量：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// recvAck notifies the readonly struct that the raft state machine received
// an acknowledgment of the heartbeat that attached with the read only request
// context.
func (ro *readOnly) recvAck(m pb.Message) int {
    rs, ok := ro.pendingReadIndex[string(m.Context)]
    if !ok {
        return 0
    }

    rs.acks[m.From] = struct{}{}  // 记录下收到 m.From 这个节点的 ack
    // add one to include an ack from local node
    return len(rs.acks) + 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果超过 quonum 表示该节点依然是 leader，此时从 &lt;code&gt;r.readOnly.advance&lt;/code&gt; 拿到保存的 readIndexReq，append 到 &lt;code&gt;r.readStates&lt;/code&gt; 中：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// advance advances the read only request queue kept by the readonly struct.
// It dequeues the requests until it finds the read only request that has
// the same context as the given `m`.
func (ro *readOnly) advance(m pb.Message) []*readIndexStatus {
    var (
        i     int
        found bool
    )

    ctx := string(m.Context)
    rss := []*readIndexStatus{}

    for _, okctx := range ro.readIndexQueue {
        i++
        rs, ok := ro.pendingReadIndex[okctx]
        if !ok {
            panic(&amp;quot;cannot find corresponding read state from pending map&amp;quot;)
        }
        rss = append(rss, rs)
        if okctx == ctx {
            // 取出 reqId 相同的 ReadState 和其前面的所有 ReadState 
            found = true
            break
        }
    }

    if found {
        ro.readIndexQueue = ro.readIndexQueue[i:]
        for _, rs := range rss {
            delete(ro.pendingReadIndex, string(rs.req.Entries[0].Data))
        }
        return rss
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;之后调用 &lt;code&gt;newReady&lt;/code&gt; 会把 &lt;code&gt;r.readStates&lt;/code&gt; 返回给应用层，应用层取出 readIndexReq 中的 commit index，等到其被 apply 到状态机就可以允许读操作了。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    ...

    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates  // 附上 r.readStates
    }
    ...
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 05 Jul 2018 13:46:43 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-3/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-3/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（概览篇）</title>
        <description>&lt;p&gt;这篇文章主要整体上介绍 etcd-raft 库，包括各个类的作用，类之间的串联。不涉及 raft 算法。先来看看 etcd-raft 几个结构体的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raft struct {
    id uint64

    Term uint64
    Vote uint64

    // the log
    raftLog *raftLog

    state StateType

    // isLearner is true if the local raft node is a learner.
    isLearner bool

    votes map[uint64]bool

    msgs []pb.Message

    // the leader id
    lead uint64

    tick func()
    step stepFunc
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;type raftLog struct {
    // storage contains all stable entries since the last snapshot.
    storage Storage

    // unstable contains all unstable entries and snapshot.
    // they will be saved into storage.
    unstable unstable

    // committed is the highest log position that is known to be in
    // stable storage on a quorum of nodes.
    committed uint64
    // applied is the highest log position that the application has
    // been instructed to apply to its state machine.
    // Invariant: applied &amp;lt;= committed
    applied uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// unstable.entries[i] has raft log position i+unstable.offset.
// Note that unstable.offset may be less than the highest log
// position in storage; this means that the next write to storage
// might need to truncate the log before persisting unstable.entries.
type unstable struct {
    // the incoming unstable snapshot, if any.
    snapshot *pb.Snapshot
    // all entries that have not yet been written to storage.
    entries []pb.Entry
    offset  uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// node is the canonical implementation of the Node interface
type node struct {
    propc      chan msgWithResult
    recvc      chan pb.Message
    readyc     chan Ready
    advancec   chan struct{}
    tickc      chan struct{}
    done       chan struct{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Ready encapsulates the entries and messages that are ready to read,
// be saved to stable storage, committed or sent to other peers.
// All fields in Ready are read-only.
type Ready struct {
    // The current volatile state of a Node.
    // SoftState will be nil if there is no update.
    // It is not required to consume or store SoftState.
    *SoftState

    // The current state of a Node to be saved to stable storage BEFORE
    // Messages are sent.
    // HardState will be equal to empty state if there is no update.
    pb.HardState

    // ReadStates can be used for node to serve linearizable read requests locally
    // when its applied index is greater than the index in ReadState.
    // Note that the readState will be returned when raft receives msgReadIndex.
    // The returned is only valid for the request that requested to read.
    ReadStates []ReadState

    // Entries specifies entries to be saved to stable storage BEFORE
    // Messages are sent.
    Entries []pb.Entry

    // Snapshot specifies the snapshot to be saved to stable storage.
    Snapshot pb.Snapshot

    // CommittedEntries specifies entries to be committed to a
    // store/state-machine. These have previously been committed to stable
    // store.
    CommittedEntries []pb.Entry

    // Messages specifies outbound messages to be sent AFTER Entries are
    // committed to stable storage.
    // If it contains a MsgSnap message, the application MUST report back to raft
    // when the snapshot has been received or has failed by calling ReportSnapshot.
    Messages []pb.Message

    // MustSync indicates whether the HardState and Entries must be synchronously
    // written to disk or if an asynchronous write is permissible.
    MustSync bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这几个结构体的关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;RaftLog 的 &lt;code&gt;Storage&lt;/code&gt; 和 RaftNode 的 &lt;code&gt;raftStorage&lt;/code&gt; 都是指向同一个 Storage 对象（虚线表示指针）。Storage 在 kvstore 的示例中的实现为 MemoryStorage，可以理解为 WAL 的一个内存缓存。重启时会从 WAL 恢复 MemoryStorage 的数据。整个逻辑由 Node 的 &lt;code&gt;run&lt;/code&gt; 方法的 for loop 驱动，从 &lt;code&gt;recvc&lt;/code&gt; channel 接收请求，调用 raft 的 &lt;code&gt;Step&lt;/code&gt; 函数进行处理。&lt;code&gt;Step&lt;/code&gt; 函数会调用 &lt;code&gt;step&lt;/code&gt;，&lt;code&gt;step&lt;/code&gt; 是函数指针，在节点成为 leader 时将其设置为 &lt;code&gt;stepLeader&lt;/code&gt;，节点变成 follower 时设置为 &lt;code&gt;stepFollower&lt;/code&gt;。&lt;code&gt;step&lt;/code&gt; 处理 append 请求时，会调用 raftLog 的 &lt;code&gt;maybeAppend&lt;/code&gt; 方法，最终会把 entries append 到 &lt;code&gt;unstable&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;在 Node &lt;code&gt;run&lt;/code&gt; 方法的 for loop 中，会定期通过 &lt;code&gt;newReady&lt;/code&gt; 函数构造 Ready 对象。Ready 包括如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HardState 即 raft 节点的 persistent state &lt;/li&gt;
&lt;li&gt;SoftState 即 raft 节点的 volatile state &lt;/li&gt;
&lt;li&gt;CommittedEntries 即已经 commit 的 log entries，需要应用层 apply 到状态机&lt;/li&gt;
&lt;li&gt;Entries 即 unstable 中的 log entries（未落盘的 log entries）&lt;/li&gt;
&lt;li&gt;Snapshot 即需要持久化的 snapshot&lt;/li&gt;
&lt;li&gt;Messages 即 mailbox，所有还未发送的消息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;构造好的 &lt;code&gt;Ready&lt;/code&gt; 对象发送到 &lt;code&gt;readyc&lt;/code&gt; channel，RaftNode 取出后会做如下处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持久化 HardState、Entries、Snapshot 到 Storage 和 WAL (&lt;code&gt;raftStorage.ApplySnapshot()&lt;/code&gt;、&lt;code&gt;raftStorage.Append()&lt;/code&gt; 和 &lt;code&gt;wal.Save(rd.HardState, rd.Entries)&lt;/code&gt; 可以看出 memoryStorage 是 wal 的缓存，写 wal 的同时也写 memoryStorage)&lt;/li&gt;
&lt;li&gt;apply CommittedEntries 到状态机&lt;/li&gt;
&lt;li&gt;广播 Messages &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;处理完后调用 Node.Advance() 通知 Node Ready 对象处理完毕，准备好接收下一个。&lt;/p&gt;

&lt;p&gt;最后看看驱动整个逻辑的 &lt;code&gt;run&lt;/code&gt; 方法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (n *node) run(r *raft) {
    var propc chan msgWithResult
    var readyc chan Ready
    var advancec chan struct{}
    var prevLastUnstablei, prevLastUnstablet uint64
    var havePrevLastUnstablei bool
    var prevSnapi uint64
    var rd Ready

    lead := None
    prevSoftSt := r.softState()
    prevHardSt := emptyState

    for {
        if advancec != nil {
            readyc = nil
        } else {
            // 应用层通知上一个 ready 对象已经处理完毕了 此时 advancec 为 nil 
            rd = newReady(r, prevSoftSt, prevHardSt)
            if rd.containsUpdates() { // 有更新才把 readyc 设为 非空
                readyc = n.readyc
            } else {
                readyc = nil
            }
        }

        select {
        case m := &amp;lt;-n.recvc:
            // filter out response message from unknown From.
            if pr := r.getProgress(m.From); pr != nil || !IsResponseMsg(m.Type) {
                r.Step(m)
            }
        case &amp;lt;-n.tickc:
            r.tick()
        case readyc &amp;lt;- rd:
            if rd.SoftState != nil {
                prevSoftSt = rd.SoftState
            }
            if len(rd.Entries) &amp;gt; 0 {
                prevLastUnstablei = rd.Entries[len(rd.Entries)-1].Index
                prevLastUnstablet = rd.Entries[len(rd.Entries)-1].Term
                havePrevLastUnstablei = true
            }
            if !IsEmptyHardState(rd.HardState) {
                prevHardSt = rd.HardState
            }
            if !IsEmptySnap(rd.Snapshot) {
                prevSnapi = rd.Snapshot.Metadata.Index
            }

            r.msgs = nil
            r.readStates = nil
            advancec = n.advancec
        case &amp;lt;-advancec:
            if prevHardSt.Commit != 0 {
                r.raftLog.appliedTo(prevHardSt.Commit)
            }
            // 应用层处理完了 表示 unstable 的东西不需要了 该清理就清理
            if havePrevLastUnstablei {
                r.raftLog.stableTo(prevLastUnstablei, prevLastUnstablet)
                havePrevLastUnstablei = false
            }
            r.raftLog.stableSnapTo(prevSnapi)
            advancec = nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还有构造 Ready 对象的 &lt;code&gt;newReady&lt;/code&gt; 函数：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    if softSt := r.softState(); !softSt.equal(prevSoftSt) {
        rd.SoftState = softSt
    }
    if hardSt := r.hardState(); !isHardStateEqual(hardSt, prevHardSt) {
        rd.HardState = hardSt
    }
    if r.raftLog.unstable.snapshot != nil {
        rd.Snapshot = *r.raftLog.unstable.snapshot
    }
    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates
    }
    rd.MustSync = MustSync(rd.HardState, prevHardSt, len(rd.Entries))
    return rd
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Wed, 04 Jul 2018 13:33:35 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-2/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>etcd-raft 源码学习笔记（示例篇）</title>
        <description>&lt;p&gt;本系列文章为 &lt;a href=&quot;https://github.com/coreos/etcd/tree/master/raft&quot;&gt;etcd-raft&lt;/a&gt; 源码阅读笔记，采用自顶向下的方式。这篇是开篇，首先来看看 etcd 提供的基于 raft 库实现的 kv store 示例，代码目录位于 contrib/raftexample。&lt;/p&gt;

&lt;p&gt;从 main 函数开始读起：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func main() {
    ...
    proposeC := make(chan string)
    defer close(proposeC)

    var kvs *kvstore
    getSnapshot := func() ([]byte, error) { return kvs.getSnapshot() }
    commitC, errorC, snapshotterReady := newRaftNode(*id, strings.Split(*cluster, &amp;quot;,&amp;quot;), *join, getSnapshot, proposeC, confChangeC)

    kvs = newKVStore(&amp;lt;-snapshotterReady, proposeC, commitC, errorC)
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;getSnapshot&lt;/code&gt; 为应用层 kv 提供的 snapshot 方法，在 raft 中调用该方法进行 snapshot。&lt;code&gt;proposeC&lt;/code&gt; 是应用层 kv 向 raftNode 发送请求的 channel，&lt;code&gt;commitC&lt;/code&gt; 为 raftNode 通知应用层 kv 已经提交的请求的 channel。&lt;/p&gt;

&lt;p&gt;先看看 &lt;code&gt;newKVStore&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func newKVStore(snapshotter *snap.Snapshotter, proposeC chan&amp;lt;- string, commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) *kvstore {
    s := &amp;amp;kvstore{proposeC: proposeC, kvStore: make(map[string]string), snapshotter: snapshotter}
    // replay log into key-value map
    s.readCommits(commitC, errorC)
    // read commits from raft into kvStore map until error
    go s.readCommits(commitC, errorC)
    return s
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;readCommits&lt;/code&gt; 方法从 &lt;code&gt;commitC&lt;/code&gt; 中读取已经提交的请求进行处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (s *kvstore) readCommits(commitC &amp;lt;-chan *string, errorC &amp;lt;-chan error) {
    for data := range commitC {
        var dataKv kv
        dec := gob.NewDecoder(bytes.NewBufferString(*data))  // decode 
        s.mu.Lock()
        s.kvStore[dataKv.Key] = dataKv.Val  // 更新 kv
        s.mu.Unlock()
    }
    if err, ok := &amp;lt;-errorC; ok {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;再看看 &lt;code&gt;newRaftNode&lt;/code&gt; ，其会调用 &lt;code&gt;startRaft&lt;/code&gt; 启动底层 raft：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) startRaft() {
    oldwal := wal.Exist(rc.waldir)
    rc.wal = rc.replayWAL()

    rpeers := make([]raft.Peer, len(rc.peers))
    for i := range rpeers {
        rpeers[i] = raft.Peer{ID: uint64(i + 1)}
    }
    c := &amp;amp;raft.Config{
        ID:              uint64(rc.id),
        ElectionTick:    10,
        HeartbeatTick:   1,
        Storage:         rc.raftStorage,
        MaxSizePerMsg:   1024 * 1024,
        MaxInflightMsgs: 256,
    }

    if oldwal {
        rc.node = raft.RestartNode(c)
    } else {
        startPeers := rpeers
        if rc.join {
            startPeers = nil
        }
        rc.node = raft.StartNode(c, startPeers)
    }

    go rc.serveRaft()  // 监听 http 
    go rc.serveChannels()  // 监听 proposeC channel，读取应用层请求 进行处理
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;serveChannels&lt;/code&gt; 就做了两个事，1. 另起一个 goroutine，接收 proposeC 里发送自应用层的请求，通过 &lt;code&gt;Propose&lt;/code&gt; 方法交给底层 raft 处理；2. 调用 &lt;code&gt;Ready&lt;/code&gt; 方法，接收发送自 raft 的 ready 对象，调用 &lt;code&gt;publishEntries&lt;/code&gt; 将已经提交的 entries 发送到 &lt;code&gt;commitC&lt;/code&gt; channel，交由应用层处理，再调用 &lt;code&gt;Advance&lt;/code&gt; 方法通知底层 raft 准备好接收下一个 ready 对象了。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;func (rc *raftNode) serveChannels() {
    defer rc.wal.Close()

    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    // send proposals over raft
    go func() {
        var confChangeCount uint64 = 0

        for rc.proposeC != nil &amp;amp;&amp;amp; rc.confChangeC != nil {
            select {
            case prop, ok := &amp;lt;-rc.proposeC:
                if !ok {
                    rc.proposeC = nil
                } else {
                    // blocks until accepted by raft state machine
                    rc.node.Propose(context.TODO(), []byte(prop))  // 调用 Propose 发送给 raft 请求
                }
            }
        }
        // client closed channel; shutdown raft if not already
        close(rc.stopc)
    }()

    // event loop on raft state machine updates
    for {
        select {
        case &amp;lt;-ticker.C:
            rc.node.Tick()

        // store raft entries to wal, then publish over commit channel
        case rd := &amp;lt;-rc.node.Ready():  // 应用层调用 Ready() 获取 ready 对象
            if ok := rc.publishEntries(rc.entriesToApply(rd.CommittedEntries)); !ok {
                rc.stop()
                return
            }
            rc.node.Advance()  // 应用层调用 Advance() 通知 raft 已经处理完 ready 对象 

        case &amp;lt;-rc.stopc:
            rc.stop()
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;publishEntries&lt;/code&gt; 将 ready 对象里的 &lt;code&gt;CommittedEntries&lt;/code&gt; 发送到 &lt;code&gt;commitC&lt;/code&gt;，由应用层 kv 处理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// publishEntries writes committed log entries to commit channel and returns
// whether all entries could be published.
func (rc *raftNode) publishEntries(ents []raftpb.Entry) bool {
    for i := range ents {
        switch ents[i].Type {
        case raftpb.EntryNormal:
            if len(ents[i].Data) == 0 {
                // ignore empty messages
                break
            }
            s := string(ents[i].Data)
            select {
            case rc.commitC &amp;lt;- &amp;amp;s:  // 发送到 commitC channel
            case &amp;lt;-rc.stopc:
                return false
            }
        }

        // after commit, update appliedIndex
        rc.appliedIndex = ents[i].Index

        // special nil commit to signal replay has finished
        if ents[i].Index == rc.lastIndex {
            select {
            case rc.commitC &amp;lt;- nil:
            case &amp;lt;-rc.stopc:
                return false
            }
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;整体架构如下，RaftNode 的角色为应用层和底层 raft 的桥梁：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/etcd-raft-node-1/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出，应用层主要用到 raft.Node 的 &lt;code&gt;Propose&lt;/code&gt;、&lt;code&gt;Ready&lt;/code&gt;、&lt;code&gt;Advance&lt;/code&gt;三个接口：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &amp;lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Tue, 03 Jul 2018 13:21:23 +0800</pubDate>
        <link>http://masutangu.com/2018/07/etcd-raft-note-1/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/07/etcd-raft-note-1/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>Libco 之 coctx_swap</title>
        <description>&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;在之前的文章&lt;a href=&quot;http://masutangu.com/2016/10/learn-libco/&quot;&gt;《浅读 Libco》&lt;/a&gt; 粗略的介绍了 libco，这篇文章则重点关注协程上下文切换的实现细节（coctx_swap.S）。&lt;/p&gt;

&lt;p&gt;首先回顾下函数调用的 stack frame layout：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/learn-libco-2/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2，依次类推。&lt;/p&gt;

&lt;h1&gt;co_resume&lt;/h1&gt;

&lt;p&gt;在之前的文章提到协程的挂起和恢复通过 co_resume 来实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;static int CoRoutineFunc( stCoRoutine_t *co,void * )
{
    if( co-&amp;gt;pfn )
    {
        co-&amp;gt;pfn( co-&amp;gt;arg );
    }
    co-&amp;gt;cEnd = 1;

    stCoRoutineEnv_t *env = co-&amp;gt;env;

    co_yield_env( env );

    return 0;
}

void co_resume( stCoRoutine_t *co )   // 恢复 co 协程
{
    stCoRoutineEnv_t *env = co-&amp;gt;env;
    stCoRoutine_t *lpCurrRoutine = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 1 ];
    if( !co-&amp;gt;cStart )
    {
        coctx_make( &amp;amp;co-&amp;gt;ctx,(coctx_pfn_t)CoRoutineFunc,co,0 );
        co-&amp;gt;cStart = 1;
    }
    env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize++ ] = co;  // 执行协程的时候压入 pCallStack 栈中
    coctx_swap( &amp;amp;(lpCurrRoutine-&amp;gt;ctx),&amp;amp;(co-&amp;gt;ctx) );  // 恢复 co 协程的上下文
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里 coctx_make 函数创建新协程的上下文：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;// 对应 CoRoutineFunc 的两个参数，s1 即 stCoRoutine_t *co，s2 即 void*
struct coctx_param_t
{
    const void *s1;
    const void *s2;
};
struct coctx_t
{
#if defined(__i386__)
    void *regs[ 8 ];
#else
    void *regs[ 14 ];
#endif
    size_t ss_size;
    char *ss_sp;
};

int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 )
{
    // make room for coctx_param
    char *sp = ctx-&amp;gt;ss_sp + ctx-&amp;gt;ss_size - sizeof(coctx_param_t);
    sp = (char*)((unsigned long)sp &amp;amp; -16L); // 16字节对齐

    coctx_param_t* param = (coctx_param_t*)sp ;
    param-&amp;gt;s1 = s;
    param-&amp;gt;s2 = s1;

    memset(ctx-&amp;gt;regs, 0, sizeof(ctx-&amp;gt;regs));

    ctx-&amp;gt;regs[ kESP ] = (char*)(sp) - sizeof(void*);  // 32位下 regs[ kESP ] 即 regs[7]，(char*)(sp) - sizeof(void*) 预留了返回地址的空间

    /*
     ss_sp 是在堆上分配的，地址从低到高增长，而栈是从高到低增长，这里要转下

     高地址  ------  &amp;lt;- ss_sp + ss_size 
           |pading| 
           |s2    |
           |s1    | 
            ------  &amp;lt;- sp
           |void* | 这个返回地址只是预留空间，不需要填。因为 CoRoutineFunc 函数执行完了表示该协程已经跑完，将其 end 标记位置1（co-&amp;gt;cEnd = 1）并调用 co_yield_env 切出。不需要再回到该协程来所以也不需要记录调用 CoRoutineFunc 后的返回地址了
            ------  &amp;lt;- ctx-&amp;gt;regs[ kESP ] 这里为返回地址预留空间的目的在于：参照前言中函数调用的 stack frame layout 图。函数调用压入参数后还需要压入返回地址，这样才能按照约定 ebp + 4 读取参数1，ebp + 8 读取参数2         
           |      |
     低地址  ------  &amp;lt;- ss_sp

                */

    ctx-&amp;gt;regs[ kEIP ] = (char*)pfn;  // 32位下 regs[ kEIP ] 即 regs[0] 保存 pfn 的地址 也就是 CoRoutineFunc 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;co_swap 调用 coctx_swap 来挂起和保存 curr 协程的上下文，恢复 pending 协程的上下文并切换执行流程至 pending 协程：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void co_swap(stCoRoutine_t* curr, stCoRoutine_t* pending_co)
{
    //swap context
    coctx_swap(&amp;amp;(curr-&amp;gt;ctx),&amp;amp;(pending_co-&amp;gt;ctx) );

    //stack buffer may be overwrite, so get again;
    stCoRoutineEnv_t* curr_env = co_get_curr_thread_env();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;进入 coctx_swap 前 stack frame layout 如下图：
&lt;img src=&quot;/assets/images/learn-libco-2/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;coctx_swap&lt;/h1&gt;

&lt;p&gt;下面是 coctx_swap 的汇编代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;leal 4(%esp), %eax     // 由上图可以看出此时 esp 指向返回地址，esp + 4  即返回地址 + 4（也指向 curr-&amp;gt;ctx 的地址），保存在 %eax                                    
movl 4(%esp), %esp     // 将 esp 移到指向 curr-&amp;gt;ctx    

/*
此时stack layout如下：
对应的ESP地址,此时ESP已经指向了第一个参数 curr-&amp;gt;ctx，为 coctx_t 结构

| *ss_sp  |
| ss_size |
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
---------- &amp;lt;---ESP
*/   

leal 32(%esp), %esp    // 将esp上移 32 个字节

/*
| *ss_sp  |
| ss_size |
----------- &amp;lt;---ESP
| regs[7] |
| regs[6] |
| regs[5] |
| regs[4] |
| regs[3] |
| regs[2] |
| regs[1] |
| regs[0] |
*/     

pushl %eax         //  curr-&amp;gt;ctx-&amp;gt;regs[7] = %eax 保存返回地址 + 4
pushl %ebp         //  curr-&amp;gt;ctx-&amp;gt;regs[6] = %ebp
pushl %esi         //  curr-&amp;gt;ctx-&amp;gt;regs[5] = %esi
pushl %edi         //  curr-&amp;gt;ctx-&amp;gt;regs[4] = %edi
pushl %edx         //  curr-&amp;gt;ctx-&amp;gt;regs[3] = %edx
pushl %ecx         //  curr-&amp;gt;ctx-&amp;gt;regs[2] = %ecx
pushl %ebx         //  curr-&amp;gt;ctx-&amp;gt;regs[1] = %ebx
pushl -4(%eax)     //  curr-&amp;gt;ctx-&amp;gt;regs[0] = 返回地址 注：%eax - 4 = %old_esp 即返回地址

/*
保存寄存器后的 stack layout
| *ss_sp  |
| ss_size |
| regs[7] |  %eax
| regs[6] |  %ebp
| regs[5] |  %esi
| regs[4] |  %edi
| regs[3] |  %edx
| regs[2] |  %ecx
| regs[1] |  %ebx
| regs[0] |  返回地址
----------- &amp;lt;---ESP
*/     

movl 4(%eax), %esp // 将 esp 移到 curr-&amp;gt;ctx 向上偏移 4 个字节的地址，也即 pending_co-&amp;gt;ctx 的地址，

/*
此时的 stack layout（pending_co-&amp;gt;ctx）
| *ss_sp  |
| ss_size |
| regs[7] | 
| regs[6] | 
| regs[5] |
| regs[4] |
| regs[3] | 
| regs[2] |
| regs[1] |
| regs[0] |
----------- &amp;lt;---ESP  指向第二个参数 pending_co-&amp;gt;ctx-&amp;gt;regs[0]
*/     

// 依次恢复寄存器
popl %eax  // pop from regs[0] regs[0] 保存返回地址
popl %ebx  // pop from regs[1]
popl %ecx  // pop from regs[2]
popl %edx  // pop from regs[3]
popl %edi  // pop from regs[4]
popl %esi  // pop from regs[5]
popl %ebp  // pop from regs[6]
popl %esp  // pop from regs[7] 此时 esp指向 regs[7] 即返回地址 + 4 的位置


/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP
| 返回地址 |

*/

// 下面这行有点ticky, esp 此时指向的是返回地址 + 4的位置，所以这里 push %eax，入栈 %eax 中保存的返回地址，esp 刚好也指向存放该返回地址的位置
pushl %eax

/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
| 返回地址 |
---------- &amp;lt;- ESP
*/


xorl %eax, %eax

ret // ret 指令弹出返回地址，此时 %esp += 4 并跳转到该地址继续执行

/*
此时的堆栈
|   s2    |
|   s1    |
|  void*  | 
---------- &amp;lt;- ESP / EBP
| 返回地址 | 弹出返回地址

在 coctx_make 的情况下，将跳转到 pfn 执行，esp 执行预留的返回地址 void*，此时stack frame layout 和平台函数调用一样，同样通过 %ebp + 4 访问参数1，%ebp + 8 访问参数2
*/

&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://kaiyuan.me/2017/07/10/libco/&quot;&gt;《libco 分析(上)：协程的实现》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27409164&quot;&gt;《libco协程库上下文切换原理详解》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27339191&quot;&gt;《x86-64 下函数调用及栈帧原理》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rangechow.com/2016/09/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86.html&quot;&gt;《函数调用原理》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 20:57:21 +0800</pubDate>
        <link>http://masutangu.com/2018/04/learn-libco-2/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/learn-libco-2/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>Programming Language Part B 课程笔记</title>
        <description>&lt;p&gt;本文是学习&lt;a href=&quot;https://www.coursera.org/learn/programming-languages-part-b/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;课程的学习笔记，文章内容及代码均取自课程材料。&lt;/p&gt;

&lt;h1&gt;Interpreter or Compiler&lt;/h1&gt;

&lt;p&gt;实现编程语言的 workflow 如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/programming-language-b/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Parser 读取程序文本，检查 syntax，如果语法正确则输出 AST（abstract syntax tree）。如果该编程语言有 type checker，则将 AST 丢给 type checker 检查，通过 type check 后，就由 interpreter 或 compile 来运行程序并输出结果。&lt;/p&gt;

&lt;p&gt;在实现编程语言 B 通常有下面两种办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用另一种编程语言 A 来实现 interpreter（命名为 evaluator 或 executor 更恰当），输入 B 语言写的代码，输出结果&lt;/li&gt;
&lt;li&gt;使用另一种编程语言 A 实现 compiler（命名为 translator 更恰当），将 B 翻译成第三种编程语言 C&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Skipping Parsing&lt;/h1&gt;

&lt;p&gt;如果基于编程语言 A 来实现编程语言 B，就可以跳过 parsing 阶段：&lt;strong&gt;Have B programmers write ASTs directly in PL A&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ML from a Racket perspective&lt;/h1&gt;

&lt;p&gt;ML is like a well-defined subset of Racket&lt;/p&gt;

&lt;h1&gt;Racket from an ML Perspective&lt;/h1&gt;

&lt;p&gt;One way to describe Racket is that &lt;strong&gt;it has “one big datatype”&lt;/strong&gt;：all values have this type.&lt;/p&gt;

&lt;p&gt;我的理解由于 Racket 是 dynamic typing，所以 ML 程序员看来 Racket 只有一个类型（这样 static type check 都能成功）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Constructors are applied implicitly (&lt;strong&gt;values are tagged&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;42 is really like Int 42&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Primitives implicitly check tags and extract data, raising errors for wrong constructors&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun car v = case v of Pair(a,b) =&amp;gt; a | _ =&amp;gt; raise …

fun pair? v = case v of Pair _ =&amp;gt; true | _ =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Weak Typing&lt;/h1&gt;

&lt;p&gt;There exist programs that, by definition, must pass static checking but then when run can &amp;quot;set the computer on fire&amp;quot;?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ease of language implementation: Checks left to the programmer&lt;/li&gt;
&lt;li&gt;Performance: Dynamic checks take time&lt;/li&gt;
&lt;li&gt;Lower level: Compiler does not insert information like array sizes, so it cannot do the checks&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Racket is not weakly typed&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It just checks most things dynamically*&lt;/li&gt;
&lt;li&gt;Dynamic checking is the definition – if the implementation can analyze the code to ensure some checks are not needed, then it can optimize them away&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 19:10:35 +0800</pubDate>
        <link>http://masutangu.com/2018/04/programing-language-b/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/04/programing-language-b/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>The Part-Time Parliament 论文笔记</title>
        <description>&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;Paxos 岛兼职议会类似容错式分布式系统面对的问题：&lt;strong&gt;议员对应分布式系统中的进程，议员缺席对应进程挂掉。Paxos 设计的议会协议在议员经常缺席的情况下可以保证法令的一致性。&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;The Single-Decree Synod&lt;/h1&gt;

&lt;p&gt;单一法令的神会协议的演化如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先由几个&lt;strong&gt;能保证一致性和允许进展性的约束&lt;/strong&gt;推导出&lt;strong&gt;初级协议（preliminary protocol)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preliminary protocol&lt;/strong&gt;的约束版本得到&lt;strong&gt;基本协议（basic protocol）&lt;/strong&gt;，其满足一致性但不保证进展性&lt;/li&gt;
&lt;li&gt;进一步约束&lt;strong&gt;basic protocol&lt;/strong&gt;得到完整的神会协议，既满足一致性又保证进展性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来四小节先讲解保证一致性的约束，再依次得出 preliminary protocol、basic protocol 和完整的神会协议。&lt;/p&gt;

&lt;h2&gt;一致性的约束条件&lt;/h2&gt;

&lt;p&gt;神会法令通过多轮带编号的&lt;strong&gt;表决（ballot）&lt;/strong&gt;选出。每一轮 ballot 是对单一法令的投票。每轮 ballot 牧师只能选择投票（表示赞成）或不投票（表示不赞成）。每轮 ballot 都关联一个&lt;strong&gt;法定人数集（quorum）&lt;/strong&gt;的牧师集合。只有当 quorum 中的每一位牧师都投票，这轮 ballot 才算成功。一轮 ballot B 包括以下四个元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B(dec): 被投票的法令&lt;/li&gt;
&lt;li&gt;B(qrm): 该轮 ballot 的 quorum&lt;/li&gt;
&lt;li&gt;B(vot): 投票的牧师集合&lt;/li&gt;
&lt;li&gt;B(bal): ballot 的编号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当且仅当 B(qrm) ⊆ B(vot) 时，这轮 ballot 才算成功。&lt;strong&gt;B(bal) 值的大小和进行 ballot 的顺序无关，B(bal) 比较大的 ballot 有可能在 B(bal) 比较小的 ballot 之前发生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Paxos 数学家在由多轮 ballot 组成的集合 𝜷 上定义了三个约束条件，如果集合中的 ballot 都满足这些条件，则可以保证一致性会：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(𝜷): 𝜷 中的每一轮 ballot 都拥有唯一的编号&lt;/li&gt;
&lt;li&gt;B2(𝜷): 𝜷 中任意两轮 ballot 的 quorum 至少有一个公共成员&lt;/li&gt;
&lt;li&gt;B3(𝜷): 𝜷 中任意一轮 ballot B，如果 B(qrm) 中任何一个牧师在 𝜷 中更早的 ballot 中投过票，则 B(dec) 与所有更早的 ballots 中最后那轮 ballot 的法令相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是对 B3(𝜷) 的图解。五轮 ballot 组成集合 𝜷，A、B、Γ、∆ 和 E 表示五位牧师，方框圈起的表示投票的牧师。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编号 2 是最早的一轮 ballot，因此显而易见三个条件都满足（没有比他更早的 ballot了）&lt;/li&gt;
&lt;li&gt;编号 5 的 ballot，四位 quorum 都没有在更早的 ballot 中投过票，因此三个条件也满足&lt;/li&gt;
&lt;li&gt;编号 14 的 ballot 中，∆ 是 quorum 中唯一一位在更早的 ballot 中投过票的，因此这一轮的法令必须和编号为 2 的 ballot 一致，都为 𝜶&lt;/li&gt;
&lt;li&gt;编号 27 是一轮成功的 ballot，A、Γ 和 ∆ 为该轮的 quorum 成员。Γ 在编号 5 的 ballot 中投过票，∆ 在编号为 2 的 ballot 中投过票，根据 B3(𝜷)，这一轮的法令必须和编号 5 的法令一致（编号 5 比编号 2 更新）&lt;/li&gt;
&lt;li&gt;编号 29 的 quorum 成员为 B、Γ 和 ∆。B 在编号 14 的 ballot 投过票，Γ 在编号 5 和 27 的 ballots 都投过票，∆ 在编号为 2 和 27 的ballots 也投过票，这些 ballots 中最新的编号为 27，因此这轮 ballot 的法令必须和编号 27 的法令一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面给出 B1(𝜷) B2(𝜷) B3(𝜷) 的数学定义：&lt;/p&gt;

&lt;p&gt;符号 v 表示一次投票，其中 v(pst) 表示投票的牧师，v(bal) 表示投票的编号，v(dec) 表示投票的法令。集合 Votes(𝜷) 表示满足以下条件的投票 v 的集合：v(pst) ∈ B(vot)，v(bal) = B(bal)，v(dec) = B(dec)，B ∈ 𝜷。定义 p 为牧师，b 为 ballot 编号，则 MaxVote(b, p, 𝜷) 表示集合 &lt;strong&gt;{ v ∈ Votes(B): (v(pst) = p) ∧ (v(bal) &amp;lt; b) } ∪ { null(p) }&lt;/strong&gt; 中 ballot 最大的投票。&lt;em&gt;注：null(p) 表示 null 投票，即 v(bal) 为-∞, v(dec) 为 BLANK 且 v(pst) = p&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对任意非空的牧师集合 Q，MaxVote(b, Q, 𝜷) 定义为 Q 中的所有牧师 p 的 MaxVote(b, p, 𝜷) 的最大值。&lt;em&gt;注：翻译得不太妥当，原文：For any nonempty set Q of priests, MaxVote(b, Q, B) was defined to equal the maximum of all votes MaxVote(b, p, B) with p in Q.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;B1(𝜷) B2(𝜷) B3(𝜷) 的数学定义如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;B1(𝜷) ≜ ∀B, B&amp;#39; ∈ 𝜷 : (B ≠ B&amp;#39;) ⇒ (B(bal) ≠ B&amp;#39;(bal))&lt;/li&gt;
&lt;li&gt;B2(𝜷) ≜ ∀B, B&amp;#39; ∈ 𝜷 : B(qrm) ∩ B&amp;#39;(qrm) ≠ ∅&lt;/li&gt;
&lt;li&gt;B3(𝜷) ≜ ∀B ∈ 𝜷 : (MaxVote(B(bal) , B(qrm), 𝜷)bal ≠ −∞) ⇒ (B(dec) = MaxVote(B(bal) , B(qrm) , 𝜷)dec)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;引理：如果满足 B1(𝜷) B2(𝜷) B3(𝜷)，则 ((B(qrm) ⊆ B(vot)) ∧ (B&amp;#39;(bal) &amp;gt; B(bal))) ⇒ (B(dec) = B&amp;#39;(dec))&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引理证明如下：&lt;/p&gt;

&lt;p&gt;对 𝜷 中任意 ballot B，定义 Ψ(B, 𝜷) 表示 𝜷 中所有编号大于 B(bal) 且法令不等于 B(dec) 的 ballot 的集合：&lt;strong&gt;Ψ(B, 𝜷) ≜ {B&amp;#39; ∈ 𝜷 : (B&amp;#39;(bal) &amp;gt; B(bal) ∧ (B&amp;#39;(dec) ≠ B(dec))}&lt;/strong&gt;。如果证明 B(qrm) ⊆ B(vot) 则 Ψ(B, 𝜷) 为空，引理即成立。下面是反证法，假设存在 B 满足 B(qrm) ⊆ B(vot) 且 Ψ(B, 𝜷) 不为空，下面推导得出矛盾的结论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选择 C ∈ Ψ(B, B) 满足 C(bal) = min{ B&amp;#39;(bal) : B&amp;#39; ∈ Ψ(B, 𝜷)}&lt;/li&gt;
&lt;li&gt;C(bal) &amp;gt; B(bal)：由 1 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;B(vot) ∩ C(qrm) ≠ ∅：由 B2(𝜷) 和 B(qrm) ⊆ B(vot) 得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal ≥ B(bal)：由 2、3 和 MaxVote 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷) ∈ Votes(B)：由 4 知道 MaxVote(C(bal), C(qrm) , 𝜷) 不是 null 投票&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)dec = C(dec)：由 5 和 B3(𝜷) 得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)dec ≠ B(dec)：由 6、1 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal &amp;gt; B(bal)：由 4 7 和 B1(𝜷) 的出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷) ∈ Votes(Ψ(B, 𝜷))：由 7 8 和 Ψ(B, 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;MaxVote(C(bal), C(qrm), 𝜷)bal &amp;lt; C(bal)：由 MaxVote(C(bal), C(qrm), 𝜷) 的定义得出&lt;/li&gt;
&lt;li&gt;由 9 10 1 得出矛盾，因为 1 中定义了 C(bal) 是 Ψ(B, 𝜷) 中编号最小的，由 9 知道 MaxVote(C(bal), C(qrm), 𝜷) 属于 Votes(Ψ(B, 𝜷))，那么 MaxVote(C(bal), C(qrm), 𝜷) 必须大于等于 C(bal)，这与 10 得到的 MaxVote(C(bal), C(qrm), 𝜷)bal &amp;lt; C(bal) 矛盾&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由引理得出，如果满足 B1(𝜷) B2(𝜷) B3(𝜷)，则任意两轮成功的 ballots 都是相同的法令，数学表示：&lt;strong&gt;((B(qrm) ⊆ B(vot)) ∧ (B&amp;#39;(qrm) ⊆ B&amp;#39;(vot))) ⇒ (B&amp;#39;dec = Bdec)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;The Preliminary Protocol&lt;/h2&gt;

&lt;p&gt;为了遵守 B3(𝜷)，牧师在发起表决前需要先确定 MaxVote(b, Q, 𝜷)dec，因此需要确定 Q 中的每一个 p 的 MaxVote(b, q, 𝜷)dec。Preliminary protocol 的前两步如下：&lt;/p&gt;

&lt;p&gt;(1) 牧师 p 选择新的 ballot number b，发送一条 NextBallot(b) 消息给某些牧师&lt;/p&gt;

&lt;p&gt;(2) 牧师 q 收到 NextBallot(b) 消息后，发送 LastVote(b, v) 消息给 p，v 为 MaxVote(b, q, 𝜷)&lt;/p&gt;

&lt;p&gt;发送完 LastVote(b, v)，&lt;strong&gt;q 承诺不再给编号在 [v(bal), b] 区间的表决投票。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：这个承诺是为了解决乱序的问题， ballot 编号大的投票发生在编号小的之前时，如下图，B 和 C 投票的法令出现了不一致［参考自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21438357&quot;&gt;Paxos理论介绍(1): 朴素Paxos算法理论推导与证明&lt;/a&gt;］：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/the-part-time-parliament-note/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来两个步骤是：&lt;/p&gt;

&lt;p&gt;(3) 在收到 majority 的 LastVote(b, v) 之后，p 发起一轮编号为 b，quorum 为 Q 且法令为 d（d 需要满足B3(𝜷)）的表决，给 Q 中每一个牧师发送 BeginBallot(b, d) 消息&lt;/p&gt;

&lt;p&gt;(4) 在收到 BeginBallot(b, d) 消息后，q 决定是否投票，如果可以投票（不违背上面的承诺），则发送 Voted(b, q) 消息给 p&lt;/p&gt;

&lt;p&gt;步骤 3 将表决 B 加入到集合 𝜷 中，其中 B(bal) = b，B(qrm) = Q，B(vot) = ∅。步骤 4 中，如果牧师 q 投票了，则将 q 加入 B(vot) 中。&lt;/p&gt;

&lt;p&gt;协议的剩余步骤如下：&lt;/p&gt;

&lt;p&gt;(5) 如果 p 收到了 Q 中每一个 q 的 Voted(b, q) 消息，那么 p 在律簿上记录下法令 d，并且发送 Success(d) 给每一个牧师&lt;/p&gt;

&lt;p&gt;(6) 牧师 q 收到 Success(d) 消息后，将法令 d 记录在自己的律簿上&lt;/p&gt;

&lt;h2&gt;The Basic Protocol&lt;/h2&gt;

&lt;p&gt;在 preliminary protocol 中，每一个牧师都必须记录 &lt;strong&gt;(i) 他发起的每一个ballot number (ii) 他投过的每一次票 (iii) 他发送过的每一个 LastVote 消息&lt;/strong&gt;。要记录这么多信息是非常困难的，因此 Paxos 人对 preliminary protocol 做了进一步约束，得到更实用的 basic protocol，每个牧师只需要在律簿上记录下面三个信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;lastTried[p]&lt;/strong&gt;：p 发起的最后一个表决的编号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prevVote[p]&lt;/strong&gt;：p 投过的所有表决中编号最大的那次投票&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextBal[p]&lt;/strong&gt;：p 发过的所有 LastVote(b, v) 消息中 b 的最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Preliminary protocol 允许牧师并行管理任意数量的表决，basic protocol 中牧师在一个时间内只管理一个表决，编号为 lastTried[p]，忽略和之前发起的表决相关的消息。Basic protocol 中对 LastVote 做了更强的承诺：&lt;strong&gt;不再对编号小于 b 的表决进行投票。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basic protocol 步骤如下：&lt;/p&gt;

&lt;p&gt;(1) 牧师 p 选择新的 ballot number b，必须大于 lastTried[p]，并更新 lastTried[p] 置为 b，然后发送 NextBallot(b) 消息给某些牧师&lt;/p&gt;

&lt;p&gt;(2) 牧师 q 收到 NextBallot(b) 消息，如果 b 大于 nextBal(q)，则更新 nextBal(q) 置为 b 并发送 LastVote(b, v) 消息给 p，v 即 prevVote[q]。如果 b 小于等于 nextBal(q) 则忽略该 NextBallot 消息。&lt;/p&gt;

&lt;p&gt;(3) 在收到 majority 的 LastVote(b, v) 消息后，如果 b 等于 lastTried[p]，则 p 发起一轮新的表决，指定编号为 b，quorum 为 Q，法令为 d，d 需要满足 B3(𝜷)。p 发送 BeginBallot(b, d) 消息给 Q 中所有牧师。&lt;/p&gt;

&lt;p&gt;(4) 在收到 BeginBallot(b, d) 消息后，如果 b 等于 nextBal[q]，牧师 q 投票，并将 prevVote[q] 设置为本次投票，然后发送 Voted(b, q) 消息给 p。如果 b 不等于 nextBal[q]，则忽略该 BeginBallot 消息&lt;/p&gt;

&lt;p&gt;(5) 如果 p 收到 Q 中所有牧师的 Voted(b, q) 消息，并且 b 等于 lastTried[p]，他在律簿上记录下法令 d，并发送 Success(d) 消息给所有的牧师。&lt;/p&gt;

&lt;p&gt;(6) 在收到 Success(d) 消息后，牧师在律簿上记录下法令 d&lt;/p&gt;

&lt;p&gt;Basic protocol 是 preliminary protocol 的约束版本，preliminary protocol 满足一致性的条件，那么 basic protocol 也一定满足。不过和 preliminary protocol 一样，basic protocol 也没要求必须执行某个操作，因此同样没有解决进展性的问题。&lt;/p&gt;

&lt;h2&gt;The Complete Synod Protocol&lt;/h2&gt;

&lt;p&gt;为了保证进展性，&lt;strong&gt;关键在于决定牧师什么时候应该发起表决&lt;/strong&gt;。永远不发起表决和太频繁的发起表决都会影响进展性。完整的神会协议在 basic protocol 的基础上新增一个流程来选择唯一的牧师--总统，来发起表决。这部分细节参照论文的 2.4 节。&lt;/p&gt;

&lt;h1&gt;The Multi-Decree Parliament&lt;/h1&gt;

&lt;h2&gt;The Protocol&lt;/h2&gt;

&lt;p&gt;Paxos 议会需要通过一系列法令而不仅仅单一一个法令。法令提议给总统，由总统赋予 ballot number 并尝试通过它。协议对每个法令使用不同实例的 Complete Synod Protocol，但这系列实例只需要一位总统来负责，并且神会协议的前两步只需要执行一次。&lt;/p&gt;

&lt;p&gt;在神会协议中，总统在第三步之前不会选择法令和 quorum，因此总统可以为所有实例发送一条 NextBallot(b) 消息，议员回复一条 LastVote 消息，规则和单一法令的协议相同，只是把所有待表决的实例信息包含在一条 LastVote 信息里。&lt;/p&gt;

&lt;p&gt;当总统收到 majority 的回复后，就为每个待表决的实例执行 Complete Synod Protocol 的第三步。&lt;/p&gt;

&lt;p&gt;因此 Paxon 的议会协议如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已经知道结果的表决不再需要再走一遍 Complete Synod Protocol 的流程，因此当新选举的总统 p 在律簿上已经记录有编号小于等于 n 的法令，那他将发送 NextBallot(b, n) 代替之前的 NextBallot(b) 消息。议员收到 NextBallot 消息后，将他律簿上所有编号大于 n 的法令返回给 p，并且告诉 p 他缺失的编号小于等于 n 的法令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Properties of the Protocol&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;在总统提议任何法令之前，必须先向 majority 学习他们已经投过票的法令。&lt;/strong&gt;任何一个已经通过的法令一定被至少一个多数集合中的议员投过票。这样就保证了总统在提议新法令前律簿上不会有空缺。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 20:36:16 +0800</pubDate>
        <link>http://masutangu.com/2018/03/the-part-time-parliament-note/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/the-part-time-parliament-note/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>多排行榜数据刷新方案</title>
        <description>&lt;h2&gt;一. 背景&lt;/h2&gt;

&lt;p&gt;最近工作遇到一个棘手的问题：&lt;strong&gt;多个不同的排行榜的玩家信息如何保持一致&lt;/strong&gt;。简单描述下场景，以小游戏跳一跳为例子，一开始游戏只有一个好友排行榜，好友排行榜以玩家的最高分数进行排序，这样好处理，搭一个关系链svr，该 svr 上缓存玩家好友的信息（避免每次去 DB 查询），并使用玩家信息中的最高分数进行排序。客户端请求时下方相应的排名和玩家信息，包括最高分数信息（客户端需要展示）即可。但如果我们要新增一个全国排行榜，全国排行榜以玩家的最高步数＋耗时进行排行。这时需要搭一个全国排行榜svr，该svr上同样缓存进入全国排行榜的玩家的信息，使用玩家信息中的最高分数＋耗时进行排序。同样的在客户端请求时下发相应的排名和玩家信息。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;方案一：各个排行榜有自己的玩家缓存：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二. 问题&lt;/h2&gt;

&lt;p&gt;但问题来了，&lt;strong&gt;如何保证出现在两个榜单的同一玩家数据是一致的？&lt;/strong&gt;（不一致是因为两个排行 svr 分别缓存了玩家的信息，每个svr的排行数据缓存刷新周期也不一致）。&lt;/p&gt;

&lt;p&gt;这时候就需要使用一个全局的 data svr 来缓存玩家的信息，&lt;strong&gt;保证不同排行 svr 取到的玩家数据是一致的，同时两个排行svr刷新缓存的周期需要保持一致&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;方案二：每个排行榜都从data svr 拉取玩家数据：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;数据源都从 data svr 拉取这个很简单，关键在于&lt;strong&gt;如何让不同排行榜的刷新周期保持一致&lt;/strong&gt;。本文提出一个不成熟有待考验的方案解决这个问题，并给出简单的协议例子说明。&lt;/p&gt;

&lt;h2&gt;三. 方案&lt;/h2&gt;

&lt;h3&gt;1. 协议&lt;/h3&gt;

&lt;p&gt;CSProto 表示从客户端到服务器的协议，SSProto 表示服务器之间的协议。Common 为公用协议。定义排行榜相关协议如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;公用协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package Common;

message PlayerInfo {
    int32 uid              = 1;  // 玩家 uid
    int64 udpate_timestamp = 2;  // 玩家信息的更新时间
    // 玩家信息 包括例如最高分 耗时 具体字段略过略
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;客户端和服务器之间的协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import &amp;quot;common.proto&amp;quot;;

package CSProto;

message RankReq {
    int32 rank_type = 1; // 排行榜类型 例如好友排行榜 全国排行榜
}

message RankInfo {
    Common.PlayerInfo info = 1; // 玩家信息 客户端展示用
    int32 rank_idx         = 2; // 玩家排名
}

message RankRes {
    int32 rank_type             = 1; // 排行榜类型 例如好友排行榜 全国排行榜
    repeated RankInfo rank_list = 2; // 排行数据
    int64 update_timestamp      = 3; // 排行榜更新时间
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;服务器和服务器之间的协议：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;package SSProto;

message GetPlayerInfoReq {
    repeated int32 uid_list = 1;
} 

message GetPlayerInfoRes {
    repeated Common.PlayerInfo info_list = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;消息流如下：&lt;/em&gt;
&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2. 保证排行榜 svr 刷新周期一致&lt;/h3&gt;

&lt;p&gt;排行榜 svr 从 Data svr 中拉取玩家的信息进行排序，而 Data svr 会定期去更新玩家的信息，可以推导出：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;排行榜的刷新时间等于max(排行榜上榜的玩家数据的更新时间戳)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此回包给客户端的 RankRes 中的 update_timestamp 取值的伪代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_res.update_timestamp =  max([rankinfo.info.udpate_timestamp for rankinfo in rank_res.rank_list])
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;客户端使用 map 来管理每个排行榜的更新时间：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# rank_map
&amp;lt;ranktype1, udpate_timestamp1&amp;gt;
&amp;lt;ranktype2, update_timestamp2&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;并定义所有排行榜的最新更新时间 rank_max_update_timestamp，取值伪代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;rank_max_update_timestamp = max([update_timestamp for _, update_timestamp in rank_map]) 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当玩家点击某个排行榜，客户端发现该排行榜的 update_timestamp 小于 rank_max_update_timestamp，就能判定该排行榜上存在过时的玩家数据，这时就应该向后台发起 RankReq 获取排行榜请求。&lt;strong&gt;通过及时请求过时排行榜数据，保证每个排行榜的 update_timestamp 一致，就能保证排行榜上玩家信息的一致，也就保证了在多个排行榜上玩家信息的一致。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3. 优化&lt;/h3&gt;

&lt;p&gt;上面提到，每次 update_timestamp 小于 rank_max_update_timestamp，客户端都会重新请求一次排行榜，后台会返回最新的排行榜数据，这里其实可以做下优化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-4.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;客户端先请求了 ranktype1 的排行榜，可以看出 ranktype1 的 update_timestamp 为 t1。之后又请求了 rank_type2 的排行榜，返回 ranktype2 的 update_timestamp 为 t2。由于 t1 &amp;lt; t2，客户端会发现需要更新 ranktype1。但从图上可以看出其实后台不需要再返回一次 ranktype1 的排行数据了（ranktype1 榜上的玩家 uid1 uid2 uid3 的数据并没有变化）。因此我们在 RankReq 里加上客户端本地该排行榜的 update_timestamp，如果后台发现客户端的 update_timestamp 和后台的是一致的，就返回特定的错误码告诉客户端排行榜依然有效。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;新增客户端本地该排行榜的 update_timestamp：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;message RankReq {
    int32 rank_type               = 1; // 排行榜类型 例如好友排行榜 全国排行榜
    int64 client_update_timestamp = 2; // 客户端本地该排行榜的 update_timestamp
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;采用这种方式的话，每次点击该排行榜客户端还是需要发起一次（无效）的后台请求，如何做优化呢？这里用了一个简单的方案，如果客户端收到排行榜依然有效的错误码，就把本地该排行榜 update_timestamp 更新为 rank_max_update_timestamp：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/multi-rank-refresh-design/illustration-5.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;每次客户端请求，rank svr 都需要到 data svr 查询玩家信息。可以在 rank svr 上缓存玩家的信息，到 data svr 查询时如果玩家数据无变化，则返回特定错误码，rank svr 继续使用本地的玩家信息缓存。&lt;/p&gt;

&lt;h2&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;本文提出了一个有待考验的多排行榜数据刷新方案，为解决多个排行榜数据不一致的问题。该方案还有一些细节有待考量，欢迎大家有任何想法或有更好的方案邮件我一起讨论。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Mar 2018 09:00:42 +0800</pubDate>
        <link>http://masutangu.com/2018/03/multi-rank-refresh-design/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/multi-rank-refresh-design/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>Programming Language 课程笔记</title>
        <description>&lt;p&gt;本文是学习&lt;a href=&quot;https://www.coursera.org/learn/programming-languages/home/info&quot;&gt;Coursera Programming Language&lt;/a&gt;课程的学习笔记，文章内容及代码均取自课程材料。&lt;/p&gt;

&lt;h2&gt;一. 声明式编程和命令式编程&lt;/h2&gt;

&lt;h4&gt;声明式编程（Declarative Programming）&lt;/h4&gt;

&lt;p&gt;Building the structure and elements of computer programs, that &lt;strong&gt;expresses the logic of a computation without describing its control flow&lt;/strong&gt;.&lt;/p&gt;

&lt;h4&gt;命令式编程（Imperative Programming）&lt;/h4&gt;

&lt;p&gt;Describes computation &lt;strong&gt;in terms of statements that change a program state&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;左图为 Declarative Programming 范式，右图为 Imperative Programming 范式：&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二. 函数式编程&lt;/h2&gt;

&lt;p&gt;三大特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No Mutation&lt;/li&gt;
&lt;li&gt;First Class Function&lt;/li&gt;
&lt;li&gt;Tail Recursion Optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;1. No Mutation&lt;/h3&gt;

&lt;p&gt;知乎上&lt;a href=&quot;https://www.zhihu.com/question/28292740&quot;&gt;《什么是函数式编程思维》&lt;/a&gt;其中一个回到写得很好：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;函数式编程的本质：
函数式编程中的&lt;strong&gt;函数&lt;/strong&gt;这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。在函数式语言中，&lt;strong&gt;函数作为一等公民&lt;/strong&gt;，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。纯函数式编程语言中的&lt;strong&gt;变量&lt;/strong&gt;也不是命令式编程语言中的变量表示存储状态的单元，而是&lt;strong&gt;代数中的变量&lt;/strong&gt;，即一个值的名称。变量的值是&lt;strong&gt;不可变的（immutable）&lt;/strong&gt;，也就是说不允许像命令式编程语言中那样多次给一个变量赋值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有 Mutation 带来的好处:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No code can ever distinguish aliasing vs. identical copies&lt;/li&gt;
&lt;li&gt;No need to think about aliasing: focus on other things&lt;/li&gt;
&lt;li&gt;Can use aliasing, which saves space, without danger &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. How to build bigger types&lt;/h3&gt;

&lt;p&gt;3 most important type building-blocks in any language&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Each of&lt;/strong&gt;: A t value contains values of each of t1 t2 … tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One of&lt;/strong&gt;: A t value contains values of one of t1 t2 … tn&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Self reference&lt;/strong&gt;: A t value can refer to other t values&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3. Tail Recursion and Accumulators&lt;/h3&gt;

&lt;p&gt;ML recognizes these tail calls in the compiler and treats them differently: &lt;strong&gt;pop the caller before the call, allowing callee to reuse the same stack space&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;非尾递归的调用堆栈&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;尾递归优化后的调用堆栈&lt;/em&gt;
&lt;img src=&quot;/assets/images/programming-language/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4. Higher Order Function&lt;/h3&gt;

&lt;h4&gt;Map&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun map (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xs’ =&amp;gt; (f x)::(map(f,xs’))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Filter&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun filter (f,xs) =
 case xs of
 [] =&amp;gt; []
 | x::xs’ =&amp;gt; if f x
 then x::(filter(f,xs’))
 else filter(f,xs’)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Fold&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;fun fold f acc xs =
 case xs of
 [] =&amp;gt; acc
 | x::xs’ =&amp;gt; fold f (f(acc,x)) xs’
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Higher Order Function vs For Loop&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Fold&lt;/strong&gt;  is another very famous iterator over recursive structures. This pattern separates recursive traversal from data processing:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same traversal for different data processing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Can reuse same data processing for different data structures&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;In both cases, using common vocabulary concisely communicates intent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;遍历函数和处理函数分离，提高复用性。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;5. Function Closure&lt;/h3&gt;

&lt;p&gt;A function value has two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The code&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The environment&lt;/strong&gt; that was current when the function was defined&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This pair is called a &lt;strong&gt;function closure&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;6. Abstract Data Types With Closure&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;datatype set = S of { insert : int -&amp;gt; set, 
              member : int -&amp;gt; bool, 
              size   : unit -&amp;gt; int }

val empty_set =
    let
        fun make_set xs = (* xs is a &amp;quot;private field&amp;quot; in result *)
            let (* contains a &amp;quot;private method&amp;quot; in result *)
                fun contains i = List.exists (fn j =&amp;gt; i=j) xs
            in
                S { insert = fn i =&amp;gt; if contains i 
                                     then make_set xs 
                                     else make_set (i::xs),
                    member = contains,
                    size   = fn () =&amp;gt; length xs
                  }
            end
    in
        make_set []
    end 

fun use_sets () =
    let val S s1 = empty_set
        val S s2 = (#insert s1) 34
        val S s3 = (#insert s2) 34
        val S s4 = #insert s3 19
    in
        if (#member s4) 42
        then 99
        else if (#member s4) 19
        then 17 + (#size s3) ()
        else 0
    end 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;使用 Java 实现：&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;interface Func&amp;lt;B,A&amp;gt; {
    B m(A x);
}
interface Pred&amp;lt;A&amp;gt; {
    boolean m(A x);
}

class List&amp;lt;T&amp;gt; {
    T       head;
    List&amp;lt;T&amp;gt; tail;
    List(T x, List&amp;lt;T&amp;gt; xs) {
    head = x;
    tail = xs;
    }

    // * the advantage of a static method is it allows xs to be null
    //    -- a more OO way would be a subclass for empty lists
    // * a more efficient way in Java would be a messy while loop
    //   where you keep a pointer to the previous element and mutate it
    //   -- (try it if you do not believe it is messy)
    static &amp;lt;A,B&amp;gt; List&amp;lt;B&amp;gt; map(Func&amp;lt;B,A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        return new List&amp;lt;B&amp;gt;(f.m(xs.head), map(f,xs.tail));
    }

    static &amp;lt;A&amp;gt; List&amp;lt;A&amp;gt; filter(Pred&amp;lt;A&amp;gt; f, List&amp;lt;A&amp;gt; xs) {
        if(xs==null)
            return null;
        if(f.m(xs.head))
            return new List&amp;lt;A&amp;gt;(xs.head, filter(f,xs.tail));
        return filter(f,xs.tail);
    }

    // * again recursion would be more elegant but less efficient
    // * again an instance method would be more common, but then
    //   all clients have to special-case null 
    static &amp;lt;A&amp;gt; int length(List&amp;lt;A&amp;gt; xs) {
        int ans = 0;
        while(xs != null) {
            ++ans;
            xs = xs.tail;
        }
        return ans;
    }
}

class ExampleClients {
    static List&amp;lt;Integer&amp;gt; doubleAll(List&amp;lt;Integer&amp;gt; xs) {
        return List.map((new Func&amp;lt;Integer,Integer&amp;gt;() { 
                     public Integer m(Integer x) { return x * 2; } 
                         }), xs);
    }
    static int countNs(List&amp;lt;Integer&amp;gt; xs, final int n) {
        return List.length(List.filter(
           (new Pred&amp;lt;Integer&amp;gt;() { 
               public boolean m(Integer x) { return x==n; } 
           }), xs));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;使用 C 实现:&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;typedef struct List list_t;
struct List {
  void * head;
  list_t * tail;
};

list_t * makelist (void * x, list_t * xs) {
  list_t * ans = (list_t *)malloc(sizeof(list_t));
  ans-&amp;gt;head = x;
  ans-&amp;gt;tail = xs;
  return ans;
}

list_t * map(void* (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  return makelist(f(env,xs-&amp;gt;head), map(f,env,xs-&amp;gt;tail));
}

list_t * filter(bool (*f)(void*,void*), void* env, list_t * xs) {
  if(xs==NULL)
    return NULL;
  if(f(env,xs-&amp;gt;head))
    return makelist(xs-&amp;gt;head, filter(f,env,xs-&amp;gt;tail));
  return filter(f,env,xs-&amp;gt;tail);
}

int length(list_t* xs) {
  int ans = 0;
  while(xs != NULL) {
    ++ans;
    xs = xs-&amp;gt;tail;
  }
  return ans;
}

// clients of our list implementation:
// [the clients that cast from void* to intptr_t are technically not legal C, 
//  as explained in detail below if curious]

// awful type casts to match what map expects
void* doubleInt(void* ignore, void* i) {
  return (void*)(((intptr_t)i)*2);
}

// assumes list holds intptr_t fields
list_t * doubleAll(list_t * xs) {
  return map(doubleInt, NULL, xs);
}

// awful type casts to match what filter expects
bool isN(void* n, void* i) {
  return ((intptr_t)n)==((intptr_t)i);
}

// assumes list hold intptr_t fields
int countNs(list_t * xs, intptr_t n) {
  return length(filter(isN, (void*)n, xs));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Fri, 02 Mar 2018 19:45:24 +0800</pubDate>
        <link>http://masutangu.com/2018/03/programing-language/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/03/programing-language/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>基于 Replicated State Machine 实现游戏进程恢复</title>
        <description>&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;游戏服务器实现的业务逻辑普遍比较复杂，且大部分是带有状态的。如果进程重启或意外崩溃，会导致该服务器上的玩家断线，丢失进行中的游戏数据，带来极差的游戏体验。为了避免这种情况出现，一般游戏服务器都会持久化玩家数据以实现进程恢复，当重启或进程意外崩溃时，重新拉起进程后可以恢复到之前的状态。&lt;strong&gt;常用的做法是将玩家的状态信息保存在共享内存中，重启时加载共享内存进行恢复。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;共享内存虽然方便，但会有许多限制。比如 C++ 涉及到&lt;strong&gt;多态（虚函数表）、STL容器（heap分配）&lt;/strong&gt;，都不能直接映射到共享内存中：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-1.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这篇文章提供了新的思路，提出一个实现游戏进程恢复更简洁的做法。&lt;/p&gt;

&lt;h2&gt;Replicated State Machine&lt;/h2&gt;

&lt;p&gt;在分布式系统中，&lt;strong&gt;replicated State Machine 是实现 fault tolerance 的一个重要方式&lt;/strong&gt;，通常由复制日志来实现。每一台服务器保存一份日志，日志中包含一系列的命令，状态机会按顺序执行这些命令。因为每一台计算机的状态机都是确定的（deterministic state machine），执行的命令相同，最后输出的结果也相同。&lt;/p&gt;

&lt;h2&gt;Combine&lt;/h2&gt;

&lt;p&gt;如果我们能&lt;strong&gt;以确定状态机（deterministic state machine）来实现游戏逻辑&lt;/strong&gt;，就可以运用 replicated State Machine 的思想。只要我们把所有触发状态机状态变更的 event 都保存下来，重启时直接重放一遍，就可以回到重启前的状态了。&lt;/p&gt;

&lt;p&gt;假设实现一个回合制 pvp 的对战游戏逻辑。RoomSvr 上有若干个房间。我们&lt;strong&gt;以 state machine 来实现业务逻辑，每个房间通过 state machine 维护自己的状态信息，将玩家的请求和定时器超时都转化为 event，通过 event distributer 分发给相应房间处理，并且将 event 通过 logging module 序列化保存到本地&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-2.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进程重启时直接加载日志，读取 event 丢给房间的 state machine 进行重放，就能将每个房间恢复到进程重启/挂掉之前的状态了。&lt;/p&gt;

&lt;h2&gt;How to Snapshot&lt;/h2&gt;

&lt;p&gt;日积月累，序列化的日志会越来越多，如何能清理到不再需要的日志，提高重启时加载的速度呢？由于游戏逻辑不是简单的 kv 存储，无法直接做 snapshot，也无法参考 leveldb LSM-Tree 的做法，需要换一种方式来减少日志的堆积。&lt;/p&gt;

&lt;p&gt;当这一局已经结束时，这局的相关 event 就可以全部删掉了。如果将 event 序列化到日志中，要删除会比较麻烦。所以考虑利用共享内存来实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-3.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;实现 ShmStore 来管理共享内存的存储，替换掉上图的 Logging Module。&lt;code&gt;ShmArr&lt;/code&gt; 为映射到共享内存的 &lt;code&gt;RoomInfo&lt;/code&gt;数组，&lt;code&gt;RoomInfo&lt;/code&gt; 是 C struct 结构，记录了房间id、房间的状态（是否有效）和房间的所有 event。  &lt;code&gt;room_idx_map_&lt;/code&gt; 维护着房间 id 到 &lt;code&gt;ShmArr&lt;/code&gt; 下标的关系，&lt;code&gt;free_idx_&lt;/code&gt; 保存着 &lt;code&gt;ShmArr&lt;/code&gt; 中空闲的下标。当创建新房间时，从 &lt;code&gt;free_idx_&lt;/code&gt; 中取一个空闲下标，并把房间 id 到该下标的映射关系保存于 &lt;code&gt;room_idx_map_&lt;/code&gt; 中，将 &lt;code&gt;RoomInfo&lt;/code&gt; 的 status 置为有效。之后该房间的所有 event 就保存在对应的 &lt;code&gt;RoomInfo&lt;/code&gt; 结构里。当房间销毁时，将对应的 &lt;code&gt;RoomInfo&lt;/code&gt; 结构清空，同时从&lt;code&gt;room_idx_map_&lt;/code&gt;删除对应的映射关系，并把该 &lt;code&gt;RoomInfo&lt;/code&gt; 的下标添加回 &lt;code&gt;free_idx_&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当读取共享内存重建房间状态时，只加载 status 为有效的 &lt;code&gt;RoomInfo&lt;/code&gt; 结构。&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;最终模块图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/game-recover-based-on-replicated-state-machine/illustration-4.png&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Jan 2018 11:30:24 +0800</pubDate>
        <link>http://masutangu.com/2018/01/game-recover-based-on-replicated-state-machine/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/01/game-recover-based-on-replicated-state-machine/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>MIT 6.824 学习笔记（四）</title>
        <description>&lt;p&gt;本系列文章是对 &lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot;&gt;MIT 6.824&lt;/a&gt; 课程的学习笔记。&lt;/p&gt;

&lt;h1&gt;ZooKeeper&lt;/h1&gt;

&lt;h2&gt;Abstract&lt;/h2&gt;

&lt;p&gt;ZooKeeper 旨在提供简单高效的内核以供客户端实现更复杂的 coordination primitives。In addition to the wait-free
property, ZooKeeper provides a &lt;strong&gt;per client guarantee of FIFO execution of requests&lt;/strong&gt; and &lt;strong&gt;linearizability for all requests that change the ZooKeeper state&lt;/strong&gt;.&lt;/p&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;为了保证状态更新操作（写请求）的 linearizability，ZooKeeper 实现了 &lt;strong&gt;Zab，一个基于 leader 的原子广播协议&lt;/strong&gt;。In ZooKeeper, &lt;strong&gt;servers process read operations locally, and we do not use Zab to totally order them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在客户端缓存数据是提高读性能的重要技术，&lt;strong&gt;ZooKeeper 提供了 watch 机制&lt;/strong&gt;，不直接管理客户端缓存。&lt;/p&gt;

&lt;h2&gt;Service overview&lt;/h2&gt;

&lt;p&gt;ZooKeeper 提供给客户端 znode 的抽象，znode 有下列两种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt; : 由客户端显式创建和删除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ephemeral&lt;/strong&gt;: 由客户端创建，可以由客户端显式删除，当会话终止时系统也会自动删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ZooKeeper 实现了 watch 机制，当数据发生改变时通知客户端，而不必通过让客户端轮询服务器的方式。&lt;/p&gt;

&lt;p&gt;客户端连接到 ZooKeeper 时会初始化一个 session。Session 有超时机制，当 ZooKeeper 在超时时间内没有收到来自客户端 session的任何信息时，会判定该客户端已经挂掉。&lt;/p&gt;

&lt;h2&gt;ZooKeeper guarantees&lt;/h2&gt;

&lt;p&gt;ZooKeeper 具备以下两个基础保证：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linearizable writes&lt;/strong&gt;: all requests that update the state of ZooKeeper are serializable and respect precedence;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;FIFO client order&lt;/strong&gt;: all requests from a given client are executed in the order that they were sent by the client.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Examples of primitives&lt;/h2&gt;

&lt;h3&gt;Simple Locks without Herd Effect&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Lock
1 n = create(l + “/lock-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for watch event
6 goto 2

Unlock
1 delete(n)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Write Lock
1 n = create(l + “/write-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 2

Read Lock
1 n = create(l + “/read-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if no write znodes lower than n in C, exit
4 p = write znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 3
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;ZooKeeper Implementation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mit-6824-note-4/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;收到请求时，由 request processor 处理。如果是写请求，则使用 zab 协议，最终提交到 ZooKeeper 数据库的修改将会被复制到该系统上所有的服务器。&lt;/p&gt;

&lt;p&gt;复制数据库是一个内存数据库，&lt;strong&gt;在变更被应到到内存数据库之前，我们强制将更新记录刷到磁盘上以实现 recoverability&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个 ZooKeeper 服务器都接收处理来自客户端的请求。 读操作由每个服务器的本地数据库来处理，写请求则由 zab 协议处理。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Request Processor&lt;/h3&gt;

&lt;p&gt;与客户端发送的请求不同，&lt;strong&gt;事务是幂等的&lt;/strong&gt;。When the leader receives a write request, it calculates what the state of the system will be when the write is applied and transforms it into a transaction that captures this new state. The future state must be calculated because there may be outstanding transactions that have not yet been applied to the database. （尽管 transaction 可能执行多次，但通过计算 state 的方式，且保证多次执行的 transaction 也按照原先的顺序，就能保证幂等性）&lt;/p&gt;

&lt;h3&gt;Atomic Broadcast&lt;/h3&gt;

&lt;p&gt;所有更新 ZooKeeper 状态的请求都被转发到 leader。 Leader 执行请求并通过 Zab，一个原子广播协议广播该变更。Zab 采用majority quorums 来决定一个建议，因此 ZooKeeper 在 2F + 1 服务器的场景下最多可以容忍 F 台服务器故障。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Because state changes depend on the application of previous state changes, Zab provides stronger order guarantees than regular atomic broadcast.&lt;/strong&gt; More specifically, Zab guarantees that &lt;strong&gt;changes broadcast by a leader are delivered in the order they were sent&lt;/strong&gt; and &lt;strong&gt;all changes from previous leaders are delivered to an established leader before it broadcasts its own changes&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;Replicated Database&lt;/h3&gt;

&lt;p&gt;重放消息以恢复状态非常耗时，因此 ZooKeeper 定期进行快照，恢复时只需要重放快照后的消息。 为了不锁住状态，ZooKeeper 采用&lt;strong&gt;模糊快照&lt;/strong&gt;的方式。对树进行深度优先扫描，原子读取每个 znode 的数据和元数据并写入磁盘。Since the resulting fuzzy snapshot may have applied some subset of the state changes delivered during the generation of the snapshot, the result may not correspond to the state of ZooKeeper at any point in time. However, since state changes are idempotent, we can apply them twice as long as we apply the state changes in order.&lt;/p&gt;

&lt;h3&gt;Client-Server Interactions&lt;/h3&gt;

&lt;p&gt;读请求由服务器本地处理。每个读请求都被一个 zxid 标记，表示服务器看到的最后一个事务。本地读取的方式提高了性能，但可能返回旧数据。客户端可以在读操作后调用 sync 来保证返回的是最新的值。In our implementation, we do not need to atomically broadcast sync as we use a leader-based algorithm, and we simply place the sync operation at the end of the queue of requests between the leader and the server executing the call to sync. In order for this to work, the follower must be sure that the leader is still the leader. If there are pending transactions that commit, then the server does not suspect the leader. If the pending queue is empty, the leader needs to issue a null transaction to commit and orders the sync after that transaction.&lt;/p&gt;

&lt;p&gt;ZooKeeper 服务器以 FIFO 的顺序来处理客户端的请求。Response 包含了 zxid。Even heartbeat messages during intervals of no activity include the last zxid seen by the server that the client is connected to. If the client connects to a new server, that new server ensures that its view of the ZooKeeper data is at least as recent as the view of the client by checking the last zxid of the client against its last zxid. If the client has a more recent view than the server, the server does not reestablish the session with the client until the server has caught up.&lt;/p&gt;

&lt;h1&gt;Linearizability versus Serializability&lt;/h1&gt;

&lt;p&gt;注：摘自 &lt;a href=&quot;http://www.bailis.org/blog/linearizability-versus-serializability/&quot;&gt;Linearizability versus Serializability&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Linearizability: single-operation, single-object, real-time order&lt;/h2&gt;

&lt;p&gt;Linearizability is a guarantee about single operations on single objects. It provides a real-time  guarantee on the behavior of a set of single operations.&lt;/p&gt;

&lt;p&gt;In plain English, under linearizability, writes should appear to be instantaneous. Imprecisely, once a write completes, all later reads (where “later” is defined by wall-clock start time) should return the value of that write or the value of a later write. Once a read returns a particular value, all later reads should return that value or the value of a later write.&lt;/p&gt;

&lt;p&gt;Linearizability for read and write operations is synonymous with the term “atomic consistency” and is the “C,” or “consistency,” in Gilbert and Lynch’s proof of the CAP Theorem. We say linearizability is composable (or “local”) because, if operations on each object in a system are linearizable, then all operations in the system are linearizable.&lt;/p&gt;

&lt;h2&gt;Serializability: multi-operation, multi-object, arbitrary total order&lt;/h2&gt;

&lt;p&gt;Serializability is a guarantee about transactions, or groups of one or more operations over one or more objects. It guarantees that the execution of a set of transactions (usually containing read and write operations) over multiple items is equivalent to some serial execution (total ordering) of the transactions.&lt;/p&gt;

&lt;p&gt;Serializability is the traditional “I,” or isolation, in ACID. If users’ transactions each preserve application correctness (“C,” or consistency, in ACID), a serializable execution also preserves correctness. Therefore, serializability is a mechanism for guaranteeing database correctness.&lt;/p&gt;

&lt;p&gt;Serializability is not composable. Serializability does not imply any kind of deterministic order—it simply requires that some equivalent serial execution exists.&lt;/p&gt;

&lt;p&gt;关于 Serializability 和 Linearizability，可以读读&lt;a href=&quot;https://36kr.com/p/5037166.html&quot;&gt;分布式系统一致性的发展历史&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Transaction Management in the R* Distributed Database Management System&lt;/h1&gt;

&lt;p&gt;这篇论文的主题是关于分布式数据库系统的事务管理，着重描述了 R* 提交协议：Presumed Abort（PA）和 Presumed Commit（PC）。PA 和 PC 是著名的 two-phase（2P）提交协议的扩展。&lt;/p&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;p&gt;R* is an experimental, distributed database management system (DDBMS). In a distributed database
system, the actions of a transaction (an atomic unit of consistency and recovery) may occur at more than one site. &lt;strong&gt;A commit protocol is needed to guarantee the uniform commitment of distributed transaction executions.&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;Some of the desirable characteristics in a commit protocol are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;guaranteed transaction atomicity always&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ability to “forget” outcome of commit processing after a short amount of time（不需要一直记录结果）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minimal overhead in terms of log writes and message traffic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;optimized performance in the no-failure case&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exploitation of completely or partially read-only transactions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maximizing the ability to perform unilateral aborts&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Multilevel hierarchical commit protocols are suggested to be more natural than the conventional two-level (one coordinator and a set of subordinates) protocols.&lt;/strong&gt; With these goals in mind, we extended the conventional 2P commit protocol to support a tree of processes and defined the &lt;strong&gt;Presumed Abort (PA)&lt;/strong&gt; and the &lt;strong&gt;Presumed Commit (PC)&lt;/strong&gt; protocols to improve the performance of distributed transaction commit. &lt;/p&gt;

&lt;h2&gt;The Two-Phase Commit Protocol&lt;/h2&gt;

&lt;p&gt;在 2P 提交协议中，分布式事务执行模型包括了一个 coordinator 进程，它连接了客户端应用程序和其他称为 subordinates 的进程。Subordinates 进程彼此之间不交互，只和 coordinator 交互。每个事务分配一个全局唯一的名字。&lt;/p&gt;

&lt;h3&gt;2P Under Normal Operation&lt;/h3&gt;

&lt;p&gt;当 coordinator 接收到来自用户的事务提交请求时，并行的发送 PREPARE 消息给 subordinates，此时进入提交协议的第一阶段。如果该事务可以提交，subordinate 先 force-write 一条 prepare log record，之后发送 YES VOTE 给 coordinator，再等待 coordinator 返回最后的决策（commit 还是 abort），之后 subordinate 进入 &lt;strong&gt;prepare&lt;/strong&gt; 状态，无法单方面终止或提交事务。如果 subordinate 决定终止事务，先 force-write 一条 abort record，之后发送 NO VOTE 给 coordinator。因为 NO VOTE 表示否决，subordinate 不需要等待 coordinator，直接终止该事务，释放锁并“忘记”该事务（不需要记录任何信息了）。&lt;/p&gt;

&lt;p&gt;当 coordinator 接收到所有 subordinates 的投票时，进入提交协议的第二阶段。如果所有投票都是 YES，则 coordinator 进入 &lt;strong&gt;committing&lt;/strong&gt; 状态：首先 force-write 一条 commit record，发送 COMMIT 消息给所有 subordinates. 在 force-write 成功执行后，事务即可提交，且通知客户端事务已经成功提交。如果 coordinator 有收到 NO VOTE，则进入 &lt;strong&gt;aborting&lt;/strong&gt; 状态：force-write 一条 abort record，发送 ABORT 消息给处于准备状态的或者没有回 PREPARE 消息的 subordinates。&lt;/p&gt;

&lt;p&gt;如果 subordinate 收到 COMMIT 消息，则进入 &lt;strong&gt;committing&lt;/strong&gt; 状态：先 force-write 一条 commit record，发送 ACK 消息给 coordinator，然后提交事务并且“忘记”该事务。如果收到的是 ABORT 消息，进入 &lt;strong&gt;aborting&lt;/strong&gt; 状态：force-write 一条 abort record，发送 ACK 消息给 coordinator，然后终止事务并且“忘记”该事务。当 coordinator 收到所有 subordinates 的 ACK 消息（不包括 NO VOTE 的 subordinates），写一条 end record 然后“忘记”该事务。&lt;/p&gt;

&lt;p&gt;The general principle on which the protocols described in this paper are based is that if a subordinate acknowledges the receipt of any particular message, then it should make sure (by forcing a log record with the information in that message before sending the ACK) that it will never ask the coordinator about that piece of information. &lt;/p&gt;

&lt;p&gt;log 包含了如下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;the type (prepare, end, etc.) of the record&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identity of the process that writes the record&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the name of the transaction&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identity of the coordinator&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the names of the exclusive locks held by the writer in the case of prepare records&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;the identities of the subordinates in the case of the commit/abort records written by the coordinator&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结下，提交事务总共需要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;subordinate 写两条记录：prepare record 和 commit record，且发送两条消息：YES VOTE 和 ACK&lt;/li&gt;
&lt;li&gt;coordinator 发送两条消息：PREPARE 和 COMMIT，以及写两条记录：commit record（force-write）和 end record（非 force-write） &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2P and Failures&lt;/h3&gt;

&lt;p&gt;每个站点都存在一个 recovery 进程，处理来自其他站点的 recovery 进程的信息。当从 crash 中恢复时，recovery 进程读取 stable storage 的 log，并且在 virtual storage 中重建。在 virtual storage 的这部分信息有下列用途：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应答其他站点发来的事务查询请求，这些事务的 coordinators 是运行在该挂掉的站点上（answer queries from other sites about transactions that had their coordinators at this site）&lt;/li&gt;
&lt;li&gt;发送事务的查询信息给其他站点的 subordinates，这些事务的 coordinators 是运行在该挂掉的站点上（send unsolicited information to other sites that had subordinates for transactions that had their coordinators at this site）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 virtual storage 构建的好处在于可以快速回应其他站点的查询，而不需要从 stable storage 查询日志。&lt;/p&gt;

&lt;p&gt;当 recovery 进程发现有事务处于 &lt;strong&gt;prepare&lt;/strong&gt; 状态，则会定期向 coordinator 询问该事务应该如何处理（commit 还是 abort）。如果 recovery 进程发现有事务在执行过程中崩溃，没有留下任何日志，则直接回滚操作，写一条 abort record，然后“忘记”。&lt;/p&gt;

&lt;p&gt;如果 recovery 进程发现事务处于 &lt;strong&gt;committing/aborting&lt;/strong&gt; 状态，它将尝试定期发送 COMMIT/ABORT 给所有还没 ACK 过的 subordinates。一旦收到所有 ACK，则写一条 end record 并且“忘记”该事务。&lt;/p&gt;

&lt;p&gt;如果 recovery 进程收到一条事务查询，但 virtual storage 中没有该事务的信息，则直接返回 ABORT。&lt;/p&gt;

&lt;h2&gt;The Presumed Abort Protocol&lt;/h2&gt;

&lt;p&gt;上一节提到，在找不到关于事务的信息时，recovery 进程将返回 ABORT。这意味着当 coordinator 决定要 abort 事务时，可以直接“忘记”该事务，coordinator 和 subordinates 不再需要 force-write 一条 abort record，subordinates 也不需要 ACK 来自 coordinator 的 ABORT 消息。coordinator 也不在需要记录 end record 了。&lt;/p&gt;

&lt;p&gt;只读事务的情况下，leaf 进程直接返回 READ VOTE，释放锁，且“忘记”该事务。 A nonroot, nonleaf sends a READ VOTE only if its own vote and those of its subordinates’ are also READ VOTES. Otherwise, as long as none of the latter is a NO VOTE, it sends a YES VOTE.（存在部分只读事务）&lt;/p&gt;

&lt;p&gt;There will not be a second phase of the protocol if the root process is readonly and it gets only READ VOTES. In this case the root process, just like the other processes, writes no log records for the transaction. &lt;/p&gt;

&lt;p&gt;总结下，完全只读事务，所有进程都不需要写任何 log record。每个 nonleaf 进程发送一条 PREPARE 消息，每个 nonroot 进程发送一条信息 READ VOTE 消息。&lt;/p&gt;

&lt;h2&gt;ZooKeeper Note&lt;/h2&gt;

&lt;p&gt;Zookeeper: &lt;strong&gt;a generic &amp;quot;master&amp;quot; service&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Design challenges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What API?&lt;/li&gt;
&lt;li&gt;How to make master fault tolerant?&lt;/li&gt;
&lt;li&gt;How to get good performance?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Challenges interact: good performance may influence API e.g., asynchronous interface to allow pipelining&lt;/p&gt;

&lt;p&gt;Sessions: clients sign into zookeeper&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Session allows a client to fail-over to another zookeeper service
Client know the term and index of last completed operationsend it on each request. &lt;strong&gt;Service performs operation only if caught up with what client has seen.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sessions can timeout
Client must refresh a session continuously send a heartbeat to the server (like a lease). &lt;strong&gt;Zookeeper considers client &amp;quot;dead&amp;quot; if doesn&amp;#39;t hear from a client.&lt;/strong&gt; Client may keep doing its thing (e.g., network partition) but cannot perform other zookeeper ops in that session&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Challenge: Duplicates client requests&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scenario
Primary receives client request, fails
Client resends client request to new primary&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lab 3: 
&lt;strong&gt;Table to detect duplicates&lt;/strong&gt;
&lt;strong&gt;Limitation: one outstanding op per client&lt;/strong&gt;（缓存回包，所以需要等上一个请求处理完，才能处理下一个请求，对比是否重复，重复的话返回已经缓存好的回包）
Problem problem: cannot pipeline client requests&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Zookeeper:
Some ops are idempotent period
Some ops are easy to make idempotent: &lt;strong&gt;test-version-and-then-do-op&lt;/strong&gt;
Some ops &lt;strong&gt;the client is responsible for detecting dups&lt;/strong&gt;
 Consider the lock example.
   Create a file name that includes its session ID
     &amp;quot;app/lock/request-sessionID-seqno&amp;quot;
     zookeeper informs client when switch to new primary
 client runs getChildren()
   if new requests is there, all set
   if not, re-issue create&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Problem: read may return stale data if only master performs it&lt;/p&gt;

&lt;p&gt;Zookeeper solution: don&amp;#39;t promise non-stale data (by default)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reads are allowed to return stale data&lt;/li&gt;
&lt;li&gt;Reads can be executed by any replica&lt;/li&gt;
&lt;li&gt;Read throughput increases as number of servers increases&lt;/li&gt;
&lt;li&gt;Read returns the last zxid it has seen
 So that new primary can catch up to zxid before serving the read
 Avoids reading from past&lt;/li&gt;
&lt;li&gt;Only sync-read() guarantees data is not stale&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sync optimization: &lt;strong&gt;avoid ZAB layer for sync-read&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Must ensure that read observes last committed txn. &lt;strong&gt;Leader puts sync in queue between it and replica.&lt;/strong&gt; If ops ahead of in the queue commit, then leader must be leader, otherwise, issue null transaction.(&lt;strong&gt;In same spirit read optimization in Raft paper&lt;/strong&gt;, see last par section 8 of raft paper)&lt;/p&gt;

&lt;h2&gt;2P Note&lt;/h2&gt;

&lt;p&gt;What about concurrent transactions?&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;x and y are bank balances
x and y start out as $10

T1 is doing a transfer of $1 from x to y
T1:
  add(x, 1)  -- server A
  add(y, -1) -- server B
T2:
  tmp1 = get(x)
  tmp2 = get(y)
  print tmp1, tmp2
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Problem: &lt;strong&gt;What if T2 runs between the two add() RPCs?&lt;/strong&gt; Then T2 will print 11, 10 money will have been created!  T2 should print 10,10 or 9,11.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The traditional correctness definition is &amp;quot;serializability&amp;quot;.&lt;/strong&gt;  Results should be as if transactions ran one at a time in some order as if T1, then T2; or T2, then T1. The results for the two differ, either is OK.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;quot;Two-phase locking&amp;quot; is one way to implement serializability&lt;/strong&gt;. Each database record has a lock. The lock is stored at the server that stores the record. Transaction must wait for and acquire a record&amp;#39;s lock before using it. Thus add() handler implicitly acquires lock when it uses record. x or y transaction holds its locks until &lt;em&gt;after&lt;/em&gt; commit or abort.&lt;/p&gt;

&lt;p&gt;What are locks really doing?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When transactions conflict, locks delay one to force serial execution.&lt;/li&gt;
&lt;li&gt;When transactions don&amp;#39;t conflict, locks allow fast parallel execution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Raft and two-phase commit solve different problems!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use Raft to get high availability by replicating&lt;/strong&gt;, i.e. to be able to operate when some servers are crashed. The servers all do the &lt;em&gt;same&lt;/em&gt; thing&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use 2PC when each subordinate does something different&lt;/strong&gt; and &lt;strong&gt;all of them must do their part&lt;/strong&gt;. &lt;strong&gt;2PC does not help availability&lt;/strong&gt; since all servers must be up to get anything done. &lt;strong&gt;Raft does not ensure that all servers do something&lt;/strong&gt; since only a majority have to be alive.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What if you want &lt;strong&gt;high availability and distributed commit&lt;/strong&gt;?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each &amp;quot;server&amp;quot; should be a Raft-replicated service&lt;/li&gt;
&lt;li&gt;And the Transaction Coordinator(TC) should be Raft-replicated&lt;/li&gt;
&lt;li&gt;Run two-phase commit among the replicated services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then you can tolerate failures and still make progress.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jan 2018 19:53:45 +0800</pubDate>
        <link>http://masutangu.com/2018/01/mit-6824-note-4/</link>
        <guid isPermaLink="true">http://masutangu.com/2018/01/mit-6824-note-4/</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
  </channel>
</rss>
