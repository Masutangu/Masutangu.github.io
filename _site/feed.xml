<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Masutangu</title>
    <description>也許我這一生　始終在追逐那顆九號球</description>
    <link>http://masutangu.com/</link>
    <atom:link href="http://masutangu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 13 Oct 2016 15:49:19 +0800</pubDate>
    <lastBuildDate>Thu, 13 Oct 2016 15:49:19 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>libuv 源码阅读</title>
        <description>&lt;p&gt;花了几天时间读了下 libuv 的源码，整理成这篇文章。&lt;a href = #section_1&gt;第一节&lt;/a&gt;是读官方教程做的笔记，主要是供自己备忘用，读者可以跳过。&lt;a href = #section_2&gt;第二节&lt;/a&gt;解读 libuv 的源码，重点在 libuv 队列的实现和如何用线程池实现异步文件 IO。&lt;/p&gt;

&lt;h1&gt;&lt;span id=&quot;section_1&quot;&gt;概念&lt;/span&gt;&lt;/h1&gt;

&lt;h2&gt;handles 和 requests&lt;/h2&gt;

&lt;p&gt;libuv 提供了两个抽象：handles 和 requests。handles 是 long－lived 的，会在其 active 的时候做特定的操作。requests 则为 short-lived 操作，request 可以独自执行或被 handle 调用执行。&lt;/p&gt;

&lt;h2&gt;I/O loop&lt;/h2&gt;

&lt;p&gt;I/O loop（或 event loop）是 libuv 的核心。每个 I/O loop 绑定单一的线程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The libuv event loop (or any other API involving the loop or handles, for that matter) is not thread-safe except where stated otherwise.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;event loop 采用单线程异步 IO 的形式：所有网络操作都使用 non-blocking 套接字，并使用各个平台上性能最好的 poll 机制例如 linux 上的 epoll，OSX 的 kqueue 等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/libuv-source-code/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I/O loop 的流程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;event loop 在每次循环周期开始前都会缓存当前时间，以减少时间相关的系统调用&lt;/li&gt;
&lt;li&gt;执行到期定时器的 callback &lt;/li&gt;
&lt;li&gt;执行上一轮循环推迟的 I/O callback &lt;/li&gt;
&lt;li&gt;执行 Idle handle 的 callback &lt;/li&gt;
&lt;li&gt;执行 Prepare handle 的 callback&lt;/li&gt;
&lt;li&gt;计算 poll timeout&lt;/li&gt;
&lt;li&gt;阻塞处理 I/O，超时时间为上一步计算的 poll timeout &lt;/li&gt;
&lt;li&gt;执行 Check handle 的 callback&lt;/li&gt;
&lt;li&gt;执行 Close callback&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;libuv uses a thread pool to make asynchronous file I/O operations possible, but network I/O is always performed in a single thread, each loop’s thread.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;File I/O&lt;/h2&gt;

&lt;p&gt;libuv 的异步文件 I/O 是通过线程池实现的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;libuv provides a threadpool which can be used to run user code and get notified in the loop thread. &lt;strong&gt;This thread pool is internally used to run all filesystem operations&lt;/strong&gt;, as well as getaddrinfo and getnameinfo requests.&lt;/p&gt;

&lt;p&gt;The threadpool is global and shared across all event loops. When a particular function makes use of the threadpool (i.e. when using &lt;code&gt;uv_queue_work()&lt;/code&gt;) libuv preallocates and initializes the maximum number of threads allowed by UV_THREADPOOL_SIZE.&lt;/p&gt;

&lt;p&gt;libuv currently uses a global thread pool on which all loops can queue work on. 3 types of operations are currently run on this pool:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Filesystem operations&lt;/li&gt;
&lt;li&gt;DNS functions (getaddrinfo and getnameinfo)&lt;/li&gt;
&lt;li&gt;User specified code via uv_queue_work()&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2&gt;主要结构体&lt;/h2&gt;

&lt;h3&gt;uv_loop_t&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;The event loop is the central part of libuv’s functionality. It takes care of polling for i/o and scheduling callbacks to be run based on different sources of events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;uv_loop_t 执行的三种模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UV_RUN_DEFAULT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Runs the event loop until there are no more active and referenced handles or requests. Returns non-zero if uv_stop() was called and there are still active handles or requests. Returns zero in all other cases.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UV_RUN_ONCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Poll for i/o once. Note that this function blocks if there are no pending callbacks. Returns zero when done (no active handles or requests left), or non-zero if more callbacks are expected (meaning you should run the event loop again sometime in the future).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;UV_RUN_NOWAIT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Poll for i/o once but don’t block if there are no pending callbacks. Returns zero if done (no active handles or requests left), or non-zero if more callbacks are expected (meaning you should run the event loop again sometime in the future).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;uv_handle_t&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;uv_handle_t is the base type for all libuv handle types.&lt;/p&gt;

&lt;p&gt;Structures are aligned so that any libuv handle can be cast to uv_handle_t. All API functions defined here work with any handle type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;void uv_ref(uv_handle_t* handle)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Reference the given handle. References are idempotent, that is, if a handle is already referenced calling this function again will have no effect.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;void uv_unref(uv_handle_t* handle)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Un-reference the given handle. References are idempotent, that is, if a handle is not referenced calling this function again will have no effect.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;uv_unref 主要用于计时器。&lt;a href=&quot;https://nikhilm.github.io/uvbook/utilities.html#reference-count&quot;&gt;例子在此&lt;/a&gt;，摘抄如下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;These functions can be used to allow a loop to exit even when a watcher is active or to use custom objects to keep the loop alive.&lt;/p&gt;

&lt;p&gt;The latter can be used with interval timers. You might have a garbage collector which runs every X seconds, or your network service might send a heartbeat to others periodically, but you don’t want to have to stop them along all clean exit paths or error scenarios. Or you want the program to exit when all your other watchers are done. In that case just unref the timer immediately after creation so that if it is the only watcher running then uv_run will still exit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;uv_loop_t *loop;
uv_timer_t gc_req;
uv_timer_t fake_job_req;

int main() {
    loop = uv_default_loop();

    uv_timer_init(loop, &amp;amp;gc_req);
    uv_unref((uv_handle_t*) &amp;amp;gc_req);

    uv_timer_start(&amp;amp;gc_req, gc, 0, 2000);

    // could actually be a TCP download or something
    uv_timer_init(loop, &amp;amp;fake_job_req);
    uv_timer_start(&amp;amp;fake_job_req, fake_job, 9000, 0);
    return uv_run(loop, UV_RUN_DEFAULT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;We initialize the garbage collector timer, then immediately unref it. Observe how after 9 seconds, when the fake job is done, the program automatically exits, even though the garbage collector is still running.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;uv_req_t&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;uv_req_t is the base type for all libuv request types.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;&lt;span id=&quot;section_2&quot;&gt;代码解读&lt;/span&gt;&lt;/h1&gt;

&lt;h2&gt;队列&lt;/h2&gt;

&lt;p&gt;libuv 的队列是循环双向链表，队列在 libuv 中用到的地方很多，例如 event loop 用队列来存储 handle（handle_queue)，待监听的io事件（watcher_queue）等等。&lt;/p&gt;

&lt;h3&gt;定义&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;typedef void *QUEUE[2];
#define QUEUE_NEXT(q)       (*(QUEUE **) &amp;amp;((*(q))[0]))
#define QUEUE_PREV(q)       (*(QUEUE **) &amp;amp;((*(q))[1]))
#define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT(QUEUE_PREV(q)))
#define QUEUE_NEXT_PREV(q)  (QUEUE_PREV(QUEUE_NEXT(q)))

#define QUEUE_INIT(q)                                                         \
  do {                                                                        \
    QUEUE_NEXT(q) = (q);                                                      \
    QUEUE_PREV(q) = (q);                                                      \
  }                                                                           \
  while (0)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这段定义了 QUEUE 是元素类型为 void* 的数组，数组长度为 2。
如果按下面这样定义：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#define QUEUE_NEXT(q)       ((QUEUE *) ((*(q))[0]))
#define QUEUE_PREV(q)       ((QUEUE *) ((*(q))[1]))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;返回值不是左值，在 QUEUE_INIT 函数中对 QUEUE_NEXT 和 QUEUE_PREV 的赋值会编译失败。
C/C++ 中类型转换有可能会返回左值（可以看 &lt;a href=&quot;http://stackoverflow.com/questions/26508609/is-the-result-of-a-cast-an-rvalue&quot;&gt;stackoverflow&lt;/a&gt; 的讲解)：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The result of the expression (T) cast-expression is of type T. The result is an lvalue if T is an lvalue reference type or an rvalue reference to function type and an xvalue if T is an rvalue reference to object type; &lt;strong&gt;otherwise the result is a prvalue.&lt;/strong&gt;[ Note: if T is a non-class type that is cv-qualified, the cv-qualifiers are ignored when determining the type of the resulting prvalue; see 3.10. —end note ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此需要先将 ((*(q))[0])) 取址再解引用（解引用返回左值）。&lt;/p&gt;

&lt;h3&gt;接口&lt;/h3&gt;

&lt;p&gt;下面是 QUEUE 几个重要的接口：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
// 取出数据，具体例子可参考：https://gist.github.com/bodokaiser/5657156
#define QUEUE_DATA(ptr, type, field)                                          \
  ((type *) ((char *) (ptr) - offsetof(type, field)))

// 将 n 队列的元素添加到 h 队列，保留 h 队列原先的元素。注意操作后 n 队列的结构被破坏，不能在遍历 n 队列
#define QUEUE_ADD(h, n)                                                       \
  do {                                                                        \
    QUEUE_PREV_NEXT(h) = QUEUE_NEXT(n);                                       \
    QUEUE_NEXT_PREV(n) = QUEUE_PREV(h);                                       \
    QUEUE_PREV(h) = QUEUE_PREV(n);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
  }                                                                           \
  while (0)

// QUEUE_MOVE 的 helper 函数
#define QUEUE_SPLIT(h, q, n)                                                  \
  do {                                                                        \
    QUEUE_PREV(n) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(n) = (n);                                                 \
    QUEUE_NEXT(n) = (q);                                                      \
    QUEUE_PREV(h) = QUEUE_PREV(q);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
    QUEUE_PREV(q) = (n);                                                      \
  }                                                                           \
  while (0)

// 将 h 队列的元素添加到 n 队列， h 队列被清空，n 队列原先的元素也被清空
#define QUEUE_MOVE(h, n)                                                      \
  do {                                                                        \
    if (QUEUE_EMPTY(h))                                                       \
      QUEUE_INIT(n);                                                          \
    else {                                                                    \
      QUEUE* q = QUEUE_HEAD(h);                                               \
      QUEUE_SPLIT(h, q, n);                                                   \
    }                                                                         \
  }                                                                           \
  while (0)

// 添加元素 q 到 h 队列的尾部，QUEUE_PREV(h) 为原先队列的 tail 节点
#define QUEUE_INSERT_TAIL(h, q)                                               \
  do {                                                                        \
    QUEUE_NEXT(q) = (h);                                                      \
    QUEUE_PREV(q) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(q) = (q);                                                 \
    QUEUE_PREV(h) = (q);                                                      \
  }                                                                           \
  while (0)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上面提到了 QUEUE 是一个循环链表。定义 h 为队列的哨兵节点，则 QUEUE_NEXT(h) 指向队列的 head 节点，QUEUE_PREV(h) 指向队列的 tail 节点。&lt;/p&gt;

&lt;p&gt;结合图例来看看 QUEUE_INSERT_TAIL 的实现。&lt;/p&gt;

&lt;p&gt;原队列，因为只有一个元素（h节点为哨兵节点，不算在内），因此其即是 head 也是 tail：
&lt;img src=&quot;/assets/images/libuv-source-code/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新增一个新元素后如下所示：
&lt;img src=&quot;/assets/images/libuv-source-code/illustration-3.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是 QUEUE_MOVE 的图例。
h 队列 和 n 队列 QUEUE_MOVE 操作前如下图：
&lt;img src=&quot;/assets/images/libuv-source-code/illustration-4.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;QUEUE_MOVE 后，h 队列被清空，n 队列的哨兵节点连接到原 h 队列的 head 和 tail：
&lt;img src=&quot;/assets/images/libuv-source-code/illustration-5.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后是 QUEUE_ADD 的图例，原理就是将 n 队列的 head 和 h 队列的 tail 相连，并把 h 队列的 tail 重置指向 n 队列的 tail：
&lt;img src=&quot;/assets/images/libuv-source-code/illustration-6.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;epoll 事件管理&lt;/h2&gt;

&lt;p&gt;IO 事件都会调用 &lt;code&gt;uv__io_start&lt;/code&gt; 函数，该函数将需要监听的事件保存到 event loop 的 watcher_queue 队列中：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
  ...

  if (QUEUE_EMPTY(&amp;amp;w-&amp;gt;watcher_queue))
    QUEUE_INSERT_TAIL(&amp;amp;loop-&amp;gt;watcher_queue, &amp;amp;w-&amp;gt;watcher_queue);  // 添加到 loop-&amp;gt;watcher_queue 队列

  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后在 event loop 的循环中，会调用 &lt;code&gt;uv__io_poll&lt;/code&gt;。该函数将 loop-&amp;gt;watcher_queue 队列中的事件取出，添加到 epoll 进行监听：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void uv__io_poll(uv_loop_t* loop, int timeout) {
  ...
  uv__io_t* w;

  while (!QUEUE_EMPTY(&amp;amp;loop-&amp;gt;watcher_queue)) {  // 遍历取出 loop-&amp;gt;watcher_queue 队列中待监听的事件，直至队列为空
    q = QUEUE_HEAD(&amp;amp;loop-&amp;gt;watcher_queue);
    QUEUE_REMOVE(q);
    QUEUE_INIT(q);

    w = QUEUE_DATA(q, uv__io_t, watcher_queue);  // 取出 uv__io_t 结构，该结构保存了用户注册的回调函数

    e.events = w-&amp;gt;pevents;
    e.data = w-&amp;gt;fd;

    if (w-&amp;gt;events == 0)
      op = UV__EPOLL_CTL_ADD;
    else
      op = UV__EPOLL_CTL_MOD;

    /* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching
     * events, skip the syscall and squelch the events after epoll_wait().
     */
    if (uv__epoll_ctl(loop-&amp;gt;backend_fd, op, w-&amp;gt;fd, &amp;amp;e)) {  // 添加到 epoll
      if (errno != EEXIST)
        abort();

      assert(op == UV__EPOLL_CTL_ADD);

      /* We&amp;#39;ve reactivated a file descriptor that&amp;#39;s been watched before. */
      if (uv__epoll_ctl(loop-&amp;gt;backend_fd, UV__EPOLL_CTL_MOD, w-&amp;gt;fd, &amp;amp;e))
        abort();
    }

    w-&amp;gt;events = w-&amp;gt;pevents;
  }

  ... 


  // 阻塞等待 epoll 返回直到超时
  for (;;) {
    if (no_epoll_wait != 0 || (sigmask != 0 &amp;amp;&amp;amp; no_epoll_pwait == 0)) {
      nfds = uv__epoll_pwait(loop-&amp;gt;backend_fd,
                             events,
                             ARRAY_SIZE(events),
                             timeout,
                             sigmask);
      if (nfds == -1 &amp;amp;&amp;amp; errno == ENOSYS)
        no_epoll_pwait = 1;
    } else {
      nfds = uv__epoll_wait(loop-&amp;gt;backend_fd,
                            events,
                            ARRAY_SIZE(events),
                            timeout);
      if (nfds == -1 &amp;amp;&amp;amp; errno == ENOSYS)
        no_epoll_wait = 1;
    }
    ...

    loop-&amp;gt;watchers[loop-&amp;gt;nwatchers] = (void*) events;  // 将 events 保存在 loop-&amp;gt;watchers，为了在 uv__io_close 中可以将对应 fd 的 event 删掉
    loop-&amp;gt;watchers[loop-&amp;gt;nwatchers + 1] = (void*) (uintptr_t) nfds;
    for (i = 0; i &amp;lt; nfds; i++) {
      pe = events + i;
      fd = pe-&amp;gt;data;

      /* Skip invalidated events, see uv__platform_invalidate_fd */
      if (fd == -1)
        continue;

      assert(fd &amp;gt;= 0);
      assert((unsigned) fd &amp;lt; loop-&amp;gt;nwatchers);

      w = loop-&amp;gt;watchers[fd];

      if (w == NULL) {
        /* File descriptor that we&amp;#39;ve stopped watching, disarm it.
         *
         * Ignore all errors because we may be racing with another thread
         * when the file descriptor is closed.
         */
        uv__epoll_ctl(loop-&amp;gt;backend_fd, UV__EPOLL_CTL_DEL, fd, pe);
        continue;
      }

      /* Give users only events they&amp;#39;re interested in. Prevents spurious
       * callbacks when previous callback invocation in this loop has stopped
       * the current watcher. Also, filters out events that users has not
       * requested us to watch.
       */
      pe-&amp;gt;events &amp;amp;= w-&amp;gt;pevents | POLLERR | POLLHUP;

      /* Work around an epoll quirk where it sometimes reports just the
       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to
       * move forward, we merge in the read/write events that the watcher
       * is interested in; uv__read() and uv__write() will then deal with
       * the error or hangup in the usual fashion.
       *
       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user
       * reads the available data, calls uv_read_stop(), then sometime later
       * calls uv_read_start() again.  By then, libuv has forgotten about the
       * hangup and the kernel won&amp;#39;t report EPOLLIN again because there&amp;#39;s
       * nothing left to read.  If anything, libuv is to blame here.  The
       * current hack is just a quick bandaid; to properly fix it, libuv
       * needs to remember the error/hangup event.  We should get that for
       * free when we switch over to edge-triggered I/O.
       */
      if (pe-&amp;gt;events == POLLERR || pe-&amp;gt;events == POLLHUP)
        pe-&amp;gt;events |= w-&amp;gt;pevents &amp;amp; (POLLIN | POLLOUT);

      if (pe-&amp;gt;events != 0) {
        /* Run signal watchers last.  This also affects child process watchers
         * because those are implemented in terms of signal watchers.
         */
        if (w == &amp;amp;loop-&amp;gt;signal_io_watcher)
          have_signals = 1;
        else
          w-&amp;gt;cb(loop, w, pe-&amp;gt;events);  // 调用用户注册的回调

        nevents++;
      }
    }

    loop-&amp;gt;watchers[loop-&amp;gt;nwatchers] = NULL;
    loop-&amp;gt;watchers[loop-&amp;gt;nwatchers + 1] = NULL;

    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;线程池实现异步文件 IO&lt;/h2&gt;

&lt;p&gt;libuv 中文件操作的异步 IO 是通过线程池实现的。原理是将文件操作由工作线程来完成，当操作完成后工作线程通过 fd 通知主线程（该 fd 同样由 epoll 管理），主线程监听该 fd，当有 epoll 事件时根据层层回调，最终会调用到用户注册的回调函数。&lt;/p&gt;

&lt;p&gt;下面看看这块逻辑，所有文件操作都调用了 POST 定义的宏。POST 判断是否注册了回调，如果有则表示该操作为异步调用，此时调用 &lt;code&gt;uv__work_submit&lt;/code&gt; 向线程池提交任务。                                            &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;#define POST                                                                  \
  do {                                                                        \
    if (cb != NULL) {                                                         \
      uv__work_submit(loop, &amp;amp;req-&amp;gt;work_req, uv__fs_work, uv__fs_done);        \
      return 0;                                                               \
    }                                                                         \
    else {                                                                    \
      // 回调为 null 是同步调用                                                  \
      uv__fs_work(&amp;amp;req-&amp;gt;work_req);                                            \
      return req-&amp;gt;result;                                                     \
    }                                                                         \
  }                                                                           \
  while (0)

// 操作完成后的回调函数
static void uv__fs_done(struct uv__work* w, int status) {
  uv_fs_t* req;

  req = container_of(w, uv_fs_t, work_req);
  uv__req_unregister(req-&amp;gt;loop, req);

  if (status == -ECANCELED) {
    assert(req-&amp;gt;result == 0);
    req-&amp;gt;result = -ECANCELED;
  }

  req-&amp;gt;cb(req);  // 调用用户注册的回调
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;uv__work_submit&lt;/code&gt; 先调用 &lt;code&gt;init_once&lt;/code&gt; 初始化工作线程池，再调用 &lt;code&gt;post&lt;/code&gt; 提交任务给工作线程：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;void uv__work_submit(uv_loop_t* loop,
                     struct uv__work* w,
                     void (*work)(struct uv__work* w),
                     void (*done)(struct uv__work* w, int status)) {
  uv_once(&amp;amp;once, init_once);
  w-&amp;gt;loop = loop;
  w-&amp;gt;work = work;
  w-&amp;gt;done = done;
  post(&amp;amp;w-&amp;gt;wq);
}


static void init_once(void) {
  unsigned int i;
  const char* val;

  nthreads = ARRAY_SIZE(default_threads);
  val = getenv(&amp;quot;UV_THREADPOOL_SIZE&amp;quot;);
  if (val != NULL)
    nthreads = atoi(val);
  if (nthreads == 0)
    nthreads = 1;
  if (nthreads &amp;gt; MAX_THREADPOOL_SIZE)
    nthreads = MAX_THREADPOOL_SIZE;

  threads = default_threads;
  if (nthreads &amp;gt; ARRAY_SIZE(default_threads)) {
    threads = uv__malloc(nthreads * sizeof(threads[0]));
    if (threads == NULL) {
      nthreads = ARRAY_SIZE(default_threads);
      threads = default_threads;
    }
  }

  if (uv_cond_init(&amp;amp;cond))  // 初始化条件变量
    abort();

  if (uv_mutex_init(&amp;amp;mutex))  // 初始化互斥锁
    abort();

  QUEUE_INIT(&amp;amp;wq);

  for (i = 0; i &amp;lt; nthreads; i++)
    if (uv_thread_create(threads + i, worker, NULL))  // 创建工作线程
      abort();

  initialized = 1;
}

// 工作线程
static void worker(void* arg) {
  struct uv__work* w;
  QUEUE* q;

  (void) arg;

  for (;;) {
    uv_mutex_lock(&amp;amp;mutex);

    while (QUEUE_EMPTY(&amp;amp;wq)) {
      idle_threads += 1;
      uv_cond_wait(&amp;amp;cond, &amp;amp;mutex);   // wq 保存任务队列，当 wq 为空时阻塞等待任务，有新任务提交就会唤醒该 worker
      idle_threads -= 1;
    }

    q = QUEUE_HEAD(&amp;amp;wq);

    if (q == &amp;amp;exit_message)
      uv_cond_signal(&amp;amp;cond);  
    else {
      QUEUE_REMOVE(q);
      QUEUE_INIT(q);  /* Signal uv_cancel() that the work req is
                             executing. */
    }

    uv_mutex_unlock(&amp;amp;mutex);

    if (q == &amp;amp;exit_message)
      break;

    w = QUEUE_DATA(q, struct uv__work, wq);
    w-&amp;gt;work(w);   // work 执行文件操作

    uv_mutex_lock(&amp;amp;w-&amp;gt;loop-&amp;gt;wq_mutex);
    w-&amp;gt;work = NULL;  /* Signal uv_cancel() that the work req is done
                        executing. */
    QUEUE_INSERT_TAIL(&amp;amp;w-&amp;gt;loop-&amp;gt;wq, &amp;amp;w-&amp;gt;wq);  // 将已完成的 uv__work 添加到 loop-&amp;gt;wq 队列
    uv_async_send(&amp;amp;w-&amp;gt;loop-&amp;gt;wq_async);  // 通知主线程该任务已经执行完成
    uv_mutex_unlock(&amp;amp;w-&amp;gt;loop-&amp;gt;wq_mutex);
  }
}

// 提交任务 
static void post(QUEUE* q) {
  uv_mutex_lock(&amp;amp;mutex);
  QUEUE_INSERT_TAIL(&amp;amp;wq, q);  // 将任务提交到 wq 队列
  if (idle_threads &amp;gt; 0)
    uv_cond_signal(&amp;amp;cond);  // 有空闲工作线程时就唤醒 worker
  uv_mutex_unlock(&amp;amp;mutex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最后看看工作线程和主线程的通信，在文件操作完成后，工作线程调用 &lt;code&gt;uv__async_send&lt;/code&gt; ，该函数会往 wa-&amp;gt;wfd 或 wa-&amp;gt;io_watcher.fd 写一个空子节：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int uv_async_send(uv_async_t* handle) {
  /* Do a cheap read first. */
  if (ACCESS_ONCE(int, handle-&amp;gt;pending) != 0)
    return 0;

  if (cmpxchgi(&amp;amp;handle-&amp;gt;pending, 0, 1) == 0)
    uv__async_send(&amp;amp;handle-&amp;gt;loop-&amp;gt;async_watcher);

  return 0;
}

void uv__async_send(struct uv__async* wa) {
  const void* buf;
  ssize_t len;
  int fd;
  int r;

  buf = &amp;quot;&amp;quot;;
  len = 1;
  fd = wa-&amp;gt;wfd;

#if defined(__linux__)
  if (fd == -1) {
    static const uint64_t val = 1;
    buf = &amp;amp;val;
    len = sizeof(val);
    fd = wa-&amp;gt;io_watcher.fd;  /* eventfd */
  }
#endif

  do
    r = write(fd, buf, len);
  while (r == -1 &amp;amp;&amp;amp; errno == EINTR);

  if (r == len)
    return;

  if (r == -1)
    if (errno == EAGAIN || errno == EWOULDBLOCK)
      return;

  abort();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;主线程监听 io_watcher.fd，当有 epoll 事件时回调的顺序如下：&lt;/p&gt;

&lt;p&gt;调用 uv__io_t 的 cb 即 &lt;code&gt;uv__async_io&lt;/code&gt; --&amp;gt; 调用 uv__async 的 cb 即 &lt;code&gt;uv__async_event&lt;/code&gt;  --&amp;gt; 调用 uv_async_t 的 cb 即 &lt;code&gt;uv__work_done&lt;/code&gt; --&amp;gt; 调用 uv__work 的 done 即用户提交的回调函数。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int uv_loop_init(uv_loop_t* loop) {
  ...
  err = uv_async_init(loop, &amp;amp;loop-&amp;gt;wq_async, uv__work_done);  // 初始化 async 
  ...
}

void uv__work_done(uv_async_t* handle) {
  struct uv__work* w;
  uv_loop_t* loop;
  QUEUE* q;
  QUEUE wq;
  int err;

  loop = container_of(handle, uv_loop_t, wq_async);
  uv_mutex_lock(&amp;amp;loop-&amp;gt;wq_mutex);
  QUEUE_MOVE(&amp;amp;loop-&amp;gt;wq, &amp;amp;wq);  // 因为访问 loop-&amp;gt;wq 需要锁，为了避免长时间锁，所以拷贝一份副本出来，下面的遍历直接操作该副本
  uv_mutex_unlock(&amp;amp;loop-&amp;gt;wq_mutex);

  while (!QUEUE_EMPTY(&amp;amp;wq)) {  // 遍历 loop-&amp;gt;wq 的副本
    q = QUEUE_HEAD(&amp;amp;wq);
    QUEUE_REMOVE(q);

    w = container_of(q, struct uv__work, wq);
    err = (w-&amp;gt;work == uv__cancelled) ? UV_ECANCELED : 0;
    w-&amp;gt;done(w, err);  // 调用 done，即 uv__fs_done 函数，最终会调用用户注册的回调
  }
}

//  uv__async_start 函数会调用 uv__io_start，监听 wa-&amp;gt;io_watcher.fd
int uv_async_init(uv_loop_t* loop, uv_async_t* handle, uv_async_cb async_cb) {
  int err;

  err = uv__async_start(loop, &amp;amp;loop-&amp;gt;async_watcher, uv__async_event);
  if (err)
    return err;

  uv__handle_init(loop, (uv_handle_t*)handle, UV_ASYNC);
  handle-&amp;gt;async_cb = async_cb;
  handle-&amp;gt;pending = 0;

  QUEUE_INSERT_TAIL(&amp;amp;loop-&amp;gt;async_handles, &amp;amp;handle-&amp;gt;queue);
  uv__handle_start(handle);

  return 0;
}

// 创建 wa-&amp;gt;io_watcher.fd 
int uv__async_start(uv_loop_t* loop, struct uv__async* wa, uv__async_cb cb) {
  int pipefd[2];
  int err;

  if (wa-&amp;gt;io_watcher.fd != -1)
    return 0;

  // 下面一大段是创建 io_watcher.fd 的逻辑
  err = uv__async_eventfd();
  if (err &amp;gt;= 0) {
    pipefd[0] = err;
    pipefd[1] = -1;
  }
  else if (err == -ENOSYS) {
    err = uv__make_pipe(pipefd, UV__F_NONBLOCK);
#if defined(__linux__)
    /* Save a file descriptor by opening one of the pipe descriptors as
     * read/write through the procfs.  That file descriptor can then
     * function as both ends of the pipe.
     */
    if (err == 0) {
      char buf[32];
      int fd;

      snprintf(buf, sizeof(buf), &amp;quot;/proc/self/fd/%d&amp;quot;, pipefd[0]);
      fd = uv__open_cloexec(buf, O_RDWR);
      if (fd &amp;gt;= 0) {
        uv__close(pipefd[0]);
        uv__close(pipefd[1]);
        pipefd[0] = fd;
        pipefd[1] = fd;
      }
    }
#endif
  }

  if (err &amp;lt; 0)
    return err;

  uv__io_init(&amp;amp;wa-&amp;gt;io_watcher, uv__async_io, pipefd[0]);  // 注册 async io 事件的 callback 为 uv__async_io
  uv__io_start(loop, &amp;amp;wa-&amp;gt;io_watcher, POLLIN);  // 将该 io_watcher 添加到 loop-&amp;gt;watcher_queue，参考上文的 uv__io_start 
  wa-&amp;gt;wfd = pipefd[1];
  wa-&amp;gt;cb = cb;  // 注册 uv__async 的 cb 为 uv__async_event

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Mon, 10 Oct 2016 20:39:11 +0800</pubDate>
        <link>http://masutangu.com/2016/10/libuv-source-code/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/10/libuv-source-code/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>浅读 libco</title>
        <description>&lt;p&gt;今天花了一天时间，学习了下微信的开源协程库 &lt;a href=&quot;https://github.com/tencent-wechat/libco&quot;&gt;libco&lt;/a&gt;的代码，写下来做个纪录，有部分细节代码（包括 coctx_swap.S 那段汇编）我还没读懂，以后再补充进来。&lt;/p&gt;

&lt;h2&gt;协程的原理&lt;/h2&gt;

&lt;p&gt;协程的概念和优点这里不再赘述。我们先介绍下实现协程的原理，再来看看相应的代码。&lt;/p&gt;

&lt;p&gt;协程的切换，其实就是由我们手动来管理指令执行的上下文。一般每一个协程有自己的 context_buff 来保存自己的运行上下文（寄存器和栈）。当需要挂起当前协程时，将当前的上下文保存到该协程的 context_buff，并把当前上下文重置为新的协程的 context_buff 即可。&lt;/p&gt;

&lt;h2&gt;hook 系统调用&lt;/h2&gt;

&lt;p&gt;一般会在有 IO 阻塞操作的时候做协程的切换。如何让协程的使用者无需关心这些切换的细节呢？libco 采用 hooking IO 函数的方法。将 IO 设置为非阻塞，提交给 epoll 来管理，并让出 cpu 资源，等到 epoll 事件返回后再 resume 对应的协程。下面的代码会给出相应的例子。&lt;/p&gt;

&lt;h2&gt;libco 源码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;协程相关数据结构&lt;/p&gt;

&lt;p&gt;stCoRoutineEnv_t 管理协程的结构体，每起一个新的协程就压入 pCallStack 中，每挂起一个协程就将其踢出 pCallStack。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct stCoRoutineEnv_t
{
    stCoRoutine_t *pCallStack[ 128 ];
    int iCallStackSize;
    stCoEpoll_t *pEpoll;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;stCoRoutine_t 封装了协程对象，coctx_t 保存协程的 context。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct stCoRoutine_t
{
    stCoRoutineEnv_t *env;
    pfn_co_routine_t pfn;
    void *arg;
    coctx_t ctx;
    char cStart;
    char cEnd;
    stCoSpec_t aSpec[1024];
    char cIsMain;
    char cEnableSysHook;
    char sRunStack[ 1024 * 128 ];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;epoll 相关数据结构&lt;/p&gt;

&lt;p&gt;管理 epoll 的结构体，pTimeout 管理 Timeout 事件。pstTimeoutList 为超时事件的列表。pstTimeoutList 和 pstActiveList 下面会看到其用法。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct stCoEpoll_t
{
    int iEpollFd;
    static const int _EPOLL_SIZE = 1024 * 10;
    struct stTimeout_t *pTimeout;
    struct stTimeoutItemLink_t *pstTimeoutList;  
    struct stTimeoutItemLink_t *pstActiveList;
    co_epoll_res *result; 

};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;stTimeout_t 封装了 Timeout 结构体。pItems 是一个链表数组，具体用法可以查看 &lt;code&gt;int AddTimeout( stTimeout_t *apTimeout,stTimeoutItem_t *apItem ,unsigned long long allNow )&lt;/code&gt; 函数。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;struct stTimeout_t
{
    stTimeoutItemLink_t *pItems;
    int iItemSize;
    unsigned long long ullStart;
    long long llStartIdx;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hooking IO&lt;/p&gt;

&lt;p&gt;下面以 read 函数为例子，看看 libco 是如何将 io 操作通过 epoll 来管理并与协程结合起来。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;ssize_t read( int fd, void *buf, size_t nbyte )
{
    HOOK_SYS_FUNC( read );
    if( !co_is_enable_sys_hook() )  // 如果没开启hook，则返回系统的 read 函数
    {
        return g_sys_read_func( fd,buf,nbyte );
    }
    rpchook_t *lp = get_by_fd( fd );

    if( !lp || ( O_NONBLOCK &amp;amp; lp-&amp;gt;user_flag ) ) 
    {
        ssize_t ret = g_sys_read_func( fd,buf,nbyte );
        return ret;
    }
    int timeout = ( lp-&amp;gt;read_timeout.tv_sec * 1000 ) 
                + ( lp-&amp;gt;read_timeout.tv_usec / 1000 );

    struct pollfd pf = { 0 };
    pf.fd = fd;
    pf.events = ( POLLIN | POLLERR | POLLHUP );

    int pollret = poll( &amp;amp;pf,1,timeout );  // 这里调用 poll 了，注意 poll 会挂起当前协程让出cpu，下面的指令需要等到该协程 resume 才会继续执行了。

    ssize_t readret = g_sys_read_func( fd,(char*)buf ,nbyte );

    return readret;

}

int poll(struct pollfd fds[], nfds_t nfds, int timeout)
{

    HOOK_SYS_FUNC( poll );

    if( !co_is_enable_sys_hook() )
    {
        return g_sys_poll_func( fds,nfds,timeout );
    }

    return co_poll( co_get_epoll_ct(),fds,nfds,timeout );  // 调用的是 co_poll
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;epoll 逻辑  &lt;/p&gt;

&lt;p&gt;最主要的代码都在 co_poll 函数和 co_eventloop 函数。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;int co_poll( stCoEpoll_t *ctx,struct pollfd fds[], nfds_t nfds, int timeout )
{
    int epfd = ctx-&amp;gt;iEpollFd;

    //1.struct change
    stPoll_t arg;
    memset( &amp;amp;arg,0,sizeof(arg) );

    arg.iEpollFd = epfd;
    arg.fds = fds;
    arg.nfds = nfds;

    stPollItem_t arr[2];
    if( nfds &amp;lt; sizeof(arr) / sizeof(arr[0]) )
    {
        arg.pPollItems = arr;
    }   
    else
    {
        arg.pPollItems = (stPollItem_t*)malloc( nfds * sizeof( stPollItem_t ) );
    }

    memset( arg.pPollItems, 0, nfds * sizeof(stPollItem_t) );

    arg.pfnProcess = OnPollProcessEvent;  // 当 epoll 事件被触发，就会调用该函数来 resume 相应的协程。
    arg.pArg = GetCurrCo( co_get_curr_thread_env() );  // pArg 保存当前的协程，pfnProcess 函数中用该字段来得到需要 resume 的协程对象。

    //2.add timeout

    unsigned long long now = GetTickMS();
    arg.ullExpireTime = now + timeout;
    int ret = AddTimeout( ctx-&amp;gt;pTimeout,&amp;amp;arg,now );  // 调用 AddTimeout，由 stCoEpoll_t 管理超时。

    //3. add epoll

    for(nfds_t i = 0; i &amp;lt; nfds; i++)
    {
        arg.pPollItems[i].pSelf = fds + i;
        arg.pPollItems[i].pPoll = &amp;amp;arg;

        arg.pPollItems[i].pfnPrepare = OnPollPreparePfn;
        struct epoll_event &amp;amp;ev = arg.pPollItems[i].stEvent;

        if( fds[i].fd &amp;gt; -1 )
        {
            ev.data.ptr = arg.pPollItems + i;
            ev.events = PollEvent2Epoll( fds[i].events );

            co_epoll_ctl( epfd,EPOLL_CTL_ADD, fds[i].fd, &amp;amp;ev );  // 添加到 epoll 中监听
        }
        //if fail,the timeout would work

    }

    co_yield_env( co_get_curr_thread_env() );  // 让出 cpu，挂起当前协程了。等到 stCoEpoll_t resume 该协程再继续执行下面的指令了

    // 下面都是清理工作 可以不用细看
    RemoveFromLink&amp;lt;stTimeoutItem_t,stTimeoutItemLink_t&amp;gt;( &amp;amp;arg );
    for(nfds_t i = 0;i &amp;lt; nfds;i++)
    {
        int fd = fds[i].fd;
        if( fd &amp;gt; -1 )
        {
            co_epoll_ctl( epfd,EPOLL_CTL_DEL,fd,&amp;amp;arg.pPollItems[i].stEvent );
        }
    }

    if( arg.pPollItems != arr )
    {
        free( arg.pPollItems );
        arg.pPollItems = NULL;
    }
    return arg.iRaiseCnt;
}

// 事件循环
void co_eventloop( stCoEpoll_t *ctx,pfn_co_eventloop_t pfn,void *arg )
{
    if( !ctx-&amp;gt;result )
    {
        ctx-&amp;gt;result =  co_epoll_res_alloc( stCoEpoll_t::_EPOLL_SIZE );
    }
    co_epoll_res *result = ctx-&amp;gt;result;

    for(;;)
    {
        int ret = co_epoll_wait( ctx-&amp;gt;iEpollFd, result, stCoEpoll_t::_EPOLL_SIZE, 1 );

        stTimeoutItemLink_t *active = (ctx-&amp;gt;pstActiveList);
        stTimeoutItemLink_t *timeout = (ctx-&amp;gt;pstTimeoutList);

        memset( timeout,0,sizeof(stTimeoutItemLink_t) );

        for(int i=0;i&amp;lt;ret;i++)
        {
            stTimeoutItem_t *item = (stTimeoutItem_t*)result-&amp;gt;events[i].data.ptr;
            if( item-&amp;gt;pfnPrepare )
            {
                item-&amp;gt;pfnPrepare( item,result-&amp;gt;events[i],active );
            }
            else
            {
                AddTail( active,item );  // 监听到的事件放到 active 链表里
            }
        }

        unsigned long long now = GetTickMS();
        TakeAllTimeout( ctx-&amp;gt;pTimeout,now,timeout );  // 超时的事件放到 timeout 链表里

        stTimeoutItem_t *lp = timeout-&amp;gt;head;
        while( lp )
        {
            lp-&amp;gt;bTimeout = true;
            lp = lp-&amp;gt;pNext;
        }

        Join&amp;lt;stTimeoutItem_t,stTimeoutItemLink_t&amp;gt;( active,timeout );  // 合并 active 和 timeout 链表

        lp = active-&amp;gt;head;
        while( lp )
        {
            PopHead&amp;lt;stTimeoutItem_t,stTimeoutItemLink_t&amp;gt;( active );
            if( lp-&amp;gt;pfnProcess )
            {
                lp-&amp;gt;pfnProcess( lp );  // 一个个拿出来处理，调用 pfnProcess 函数，即 OnPollProcessEvent 函数
            }
            lp = active-&amp;gt;head;
        }
        if( pfn )
        {
            if( -1 == pfn( arg ) )
            {
                break;
            }
        }
    }
}

void OnPollProcessEvent( stTimeoutItem_t * ap )
{
    stCoRoutine_t *co = (stCoRoutine_t*)ap-&amp;gt;pArg;  // 从上面知道，pArg 保存了该事件对应的协程
    co_resume( co );   // resume 相应的协程
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程的挂起和恢复&lt;/p&gt;

&lt;p&gt;协程的挂起和恢复由 stCoRoutineEnv_t 的 pCallStack 来管理。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;void co_yield_env( stCoRoutineEnv_t *env )  // 挂起当前协程，恢复其父协程
{
    stCoRoutine_t *last = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 2 ];  // last 可以认为是父协程
    stCoRoutine_t *curr = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 1 ];  // curr 为当前执行的协程
    env-&amp;gt;iCallStackSize--;
    coctx_swap( &amp;amp;curr-&amp;gt;ctx, &amp;amp;last-&amp;gt;ctx );  // 保持 curr 协程的上下文， 并恢复 last 协程的上下文
}

void co_resume( stCoRoutine_t *co )   // 恢复 co 协程
{
    stCoRoutineEnv_t *env = co-&amp;gt;env;
    stCoRoutine_t *lpCurrRoutine = env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize - 1 ];
    if( !co-&amp;gt;cStart )
    {
        coctx_make( &amp;amp;co-&amp;gt;ctx,(coctx_pfn_t)CoRoutineFunc,co,0 );
        co-&amp;gt;cStart = 1;
    }
    env-&amp;gt;pCallStack[ env-&amp;gt;iCallStackSize++ ] = co;  // 执行协程的时候压入 pCallStack 栈中
    coctx_swap( &amp;amp;(lpCurrRoutine-&amp;gt;ctx),&amp;amp;(co-&amp;gt;ctx) );  // 恢复 co 协程的上下文
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;流程图&lt;/h2&gt;

&lt;p&gt;简化版的流程如下图所示：
&lt;img src=&quot;/assets/images/learn-libco/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Oct 2016 15:59:32 +0800</pubDate>
        <link>http://masutangu.com/2016/10/learn-libco/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/10/learn-libco/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>Protobuf 编码原理</title>
        <description>&lt;p&gt;最近项目组有在用 protobuf，于是抽空读了些 protobuf 的相关资料。本文总结 protobuf 的编码原理，重点在于其如何实现版本兼容。文中样例及说明都参考了 protobuf 的&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;编码方法的介绍&lt;/h2&gt;

&lt;p&gt;要了解 protobuf 的编码方式，首先介绍下 Varint 和 ZigZag 这两种编码。&lt;/p&gt;

&lt;h3&gt;Varint&lt;/h3&gt;

&lt;p&gt;Varint 编码的优势在于值越小的数字，占用的字节更少。一般 int32 的数字都需要占用 4 个字节。使用 Varint 进行编码则有可能缩减到 1 个字节。反过来，如果是比较大的数字，则可能需要占用 5 个字节。
理解了 Varint 的目的（节省空间），来看看其原理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each byte in a varint, except the last byte, has the &lt;strong&gt;most significant bit (msb)&lt;/strong&gt; set – this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two&amp;#39;s complement representation of the number in groups of 7 bits, &lt;strong&gt;least significant group first&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即是说，Varint 中的每个字节的最高位 bit 有特殊的含义，该位为 1 表示后续的字节也是该数字的一部分，如果该位为 0 则是最后一个字节。其他的 7 个bit都用来表示数字，从最低有效字节开始。&lt;/p&gt;

&lt;p&gt;举个例子，1 的二进制表示为 0000 0001。通过 Varint 编码后的二进制表示为 0000 0001，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再举个例子，300 的二进制表示为 100101100，通过 Varint 编码后的二进制表示为 10101100 00000010，详细过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;ZigZag&lt;/h3&gt;

&lt;p&gt;上节介绍了 Varints，我们知道 Varint 在处理小数值的数字很有效，而在处理值较大的数字则占用了多一个子节。对于负数来说，二进制最高有效位为 1，如果用 varint 来编码，无疑要占用比较多的子节。因此我们可以搭配 zigzag 来编码。&lt;/p&gt;

&lt;p&gt;ZigZag 编码将有符整型转化成无符的整型，其原理是将最高位的符号位放到最低位（－1 除外），这样大大减少了字节占用。&lt;/p&gt;

&lt;p&gt;举个例子，-2 的二进制表示为 1111 1110，用zigzag编码，－2 的绝对值为 2，二进制为 0000 0010，将符号位放到最低位，则变成 0000 0011。&lt;/p&gt;

&lt;p&gt;公式如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;32 位整型：(n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 31)&lt;/li&gt;
&lt;li&gt;64 位整型：(n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 63)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the second shift – the (n &amp;gt;&amp;gt; 31) part – is an arithmetic shift. So, in other words, the result of the shift is either a number that is all zero bits (if n is positive) or all one bits (if n is negative).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意这里的位移操作符。如果在位移运算符左边的变量是有符号数，编译产生的汇编指令是&lt;strong&gt;算术位移指令&lt;/strong&gt;，如果该变量是无符号数，编译产生的汇编指令则是&lt;strong&gt;逻辑位移指令&lt;/strong&gt;。对于左移，它们都一样，整个二进制右移，低位补 0；右移则有所区分，&lt;strong&gt;算数右移左边补最高符号位，逻辑位移左边补 0&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;举个例子，-2 经过 ZigZag 编码后为 3，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-3.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Protobuf 的编码原理&lt;/h2&gt;

&lt;h3&gt;版本兼容&lt;/h3&gt;

&lt;p&gt;Protobuf 支持向前向后兼容。向后兼容即升级的解码程序能够正确解析旧版本协议的数据，向前兼容则指旧版本的解码程序能够正确解析新版本协议的数据。如果新的协议新增了字段，旧版本的解析程序是如何自动跳过新字段的呢？&lt;/p&gt;

&lt;p&gt;协议，即通信双方约定好的规则。收到数据时，可以根据约定好的规则进行解包。假设我们使用简单粗暴的编解码方法，将结构体定义的成员按类型依此打解包。如下图，我们约定好的协议包括三个字段，类型都为 int32，那解码函数将从接收到的字节流中依次取出 4 个字节并按整型解析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-4.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果发送方升级了协议，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-5.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很明显，如果旧的解码程序还是按照依次取出 3 个 int32 去解析的话，毫无疑问是错误的（会把结构体 old_message 的成员 d 的值解析成 0x1a )。如果有办法能跳过新增字段，就可以做到兼容，即旧的解码程序能正确解析出旧协议定义的字段，新增字段一律忽略。&lt;/p&gt;

&lt;p&gt;Protobuf 采用的方法很简单也很实用，把 tag 和其类型一起打进去字节流，解码程序只要解析出不认识的 tag，就能知道该字段是新协议定义的，再通过其类型可以推断出该字段内容的长度，就能正确的跳过这部分 buffer，继续解析下一个字段。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/talk-about-protobuf/illustration-6.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当旧的解码程序解析到 tag 为 3 时，发现在旧协议里找不到该 tag，又从其类型 int 64 知道该 tag 的值占了 8 个字节，于是他跳过这 8 个字节，继续解析剩下的字节流。&lt;/p&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;Protobuf 的实现中，将每个字段的 key 设为 varint 编码后的 &lt;code&gt;(tag number &amp;lt;&amp;lt; 3) | wire_type&lt;/code&gt;。即 key 的最低三位表示字段类型，将 key 右移三位后的值表示 tag number。wire_type 如下表格所示：&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Used For&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Varint&lt;/td&gt;
&lt;td&gt;int32, int64, uint32, uint64, sint32, sint64, bool, enum&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;64-bit&lt;/td&gt;
&lt;td&gt;fixed64, sfixed64, double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Length-delimited&lt;/td&gt;
&lt;td&gt;string, bytes, embedded messages, packed repeated fields&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Start group&lt;/td&gt;
&lt;td&gt;groups (deprecated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;End group&lt;/td&gt;
&lt;td&gt;groups (deprecated)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;32-bit&lt;/td&gt;
&lt;td&gt;fixed32, sfixed32, float&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;如果是 Length-delimited Type，意味着长度不定，这时还需要在 key 后面多写入长度信息（用 varint 编码）。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;message Test2 {
  required string b = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;将 b 的值设为 &amp;quot;testing&amp;quot;，protobuf 编码后的字节流为&lt;code&gt;12 07 74 65 73 74 69 6e 67&lt;/code&gt; key 为 0x12，可以算出 tag 值为 2（0x12 &amp;gt;&amp;gt; 3), type 为 2 ( 0x12 取最低三位)。下个字节为 0x07 ，该字节表示长度，即长度为 7，因此后续的 7 个字节都为该 tag 的值。&lt;/p&gt;

&lt;p&gt;另外 protobuf 还定义了 sint32/sint64 类型。sint32/sin64 类型专门用于编码负数。如果使用 int32/int64 来编码负数， 通过 varint 编码后的 buffer 长达 5/10 个字节。（int32 时占用5个字节，int64时占用10个字节，因为负数的最高位为1，会被当作非常大的整数处理）。&lt;/p&gt;

&lt;p&gt;而 sint32/sint64 类型的值会先经过 zigzag 编码，转换成无符号整数，再采用 varint 编码，可以大大减少编码后占用的字节数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long – it is, effectively, treated like a very large unsigned integer. If you use one of the signed types, the resulting varint uses ZigZag encoding, which is much more efficient.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;使用建议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;常用消息字段(尤其是 repeated 字段)的 tag number 尽量分配在 1 ~ 15 之间。tag number 超过 16，key 的编码将占用多一个字节&lt;/li&gt;
&lt;li&gt;尽可能多的（全部）使用 optional 字段&lt;/li&gt;
&lt;li&gt;不能修改字段的 tag number&lt;/li&gt;
&lt;li&gt;不能增删任何 required 字段&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 03 Sep 2016 00:44:24 +0800</pubDate>
        <link>http://masutangu.com/2016/09/talk-about-protobuf/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/09/talk-about-protobuf/</guid>
        
        
        <category>协议设计</category>
        
      </item>
    
      <item>
        <title>简单异步应用框架的实现</title>
        <description>&lt;p&gt;两年前刚进公司的时候，第一次接触了异步框架，那时还处于懵懵懂懂的状态。最近换了组，接触到另外一种实现的异步框架，这次有了一定的积累后，对异步框架的设计也有了更多的理解。刚好最近自己基于 libuv 造了个简单的轮子 &lt;a href=&quot;https://github.com/Masutangu/SAF&quot;&gt;saf (Simple Async Framework)&lt;/a&gt;，趁此机会和大家聊聊异步框架的设计思想和实现。&lt;/p&gt;

&lt;h1&gt;异步框架设计思想&lt;/h1&gt;

&lt;h2&gt;服务器模型&lt;/h2&gt;

&lt;p&gt;先来看看传统的服务器模型，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般来说，服务器端可以分为三层：&lt;strong&gt;接入层&lt;/strong&gt;，&lt;strong&gt;逻辑层&lt;/strong&gt;，&lt;strong&gt;数据层&lt;/strong&gt;。接入层负责客户端的接入，逻辑层则实现业务逻辑，数据层就是数据的存储。&lt;/p&gt;

&lt;p&gt;简单来说，逻辑层做的事情无非就是解析客户端的请求包，写入数据到数据层或从数据层读取数据，再组装回包发送给客户端。&lt;/p&gt;

&lt;p&gt;我们拿微博做例子，用户登录微博，客户端发起拉取首页的请求，server 首先解析客户端请求，拿到用户 id，再根据用户 id 到数据层查询以下数据并拼装回包发回给客户端：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关注数&lt;/li&gt;
&lt;li&gt;粉丝数&lt;/li&gt;
&lt;li&gt;微博数&lt;/li&gt;
&lt;li&gt;个人简介，包括头像&lt;/li&gt;
&lt;li&gt;微博时间轴，即关注的人最近发的微博&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;同步 vs 异步&lt;/h2&gt;

&lt;p&gt;继续上面微博的例子，我们假设微博时间轴采用拉的方式去获取。
同步的 server，实现的逻辑如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果同步的 server 是单线程，那每次发送请求到数据层查询数据时都会阻塞，在收到数据层的回包前 server 做不了其他事情，CPU 在等待期间空转，非常浪费资源。&lt;/p&gt;

&lt;p&gt;异步 server 则不会有这个烦恼，当 server 向数据层发送请求时会立即返回，此时 server 可以处理其它客户端请求，直到数据层返回所请求的数据，通知到 server，server 再继续之前的业务逻辑。流程图大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-3.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们再仔细看上面的流程图，可以发现除了拉取微博时间轴需要依赖关注人列表之外，其它数据查询都互不依赖。因此可以把流程优化下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-4.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过这样的优化，耗时从 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关注数请求耗时 + 粉丝数请求耗时 + 微博数请求耗时 + 个人简介耗时 + 时间轴耗时&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缩减到 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MAX(关注数请求耗时，粉丝数请求耗时，微博数请求耗时，个人简介耗时) + 时间轴耗时&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;模型抽象化&lt;/h2&gt;

&lt;p&gt;通过上面的例子，来讲讲如何将上述异步处理逻辑抽象化。
我们可以把业务逻辑以&lt;strong&gt;状态（state）&lt;/strong&gt;为单位来划分，如下图。&lt;strong&gt;状态与状态之间是串行的&lt;/strong&gt;，即你必须执行完一个状态，才会跳转到下一个状态。比如我们必须先拉取关注列表，才能根据关注列表去拉取时间轴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-5.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而一个状态内可以有很多&lt;strong&gt;动作（action）&lt;/strong&gt;，&lt;strong&gt;一个状态内的动作是互相不依赖的，即可以并行执行&lt;/strong&gt;，如下图。如我们可以同时发请求拉去关注数，粉丝数，微博数，因为他们之间是互相独立没有依赖的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/simple-async-framework/illustration-6.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;异步框架的实现&lt;/h1&gt;

&lt;p&gt;讲完了概念，开始来实践。linux 下有 epoll 模型，另外还有大名鼎鼎的 libuv 提供了跨平台的异步 IO。那接下来结合我自己造的轮子，谈谈如何基于 epoll 或 libuv 来实现一个异步框架。&lt;/p&gt;

&lt;h2&gt;状态保存&lt;/h2&gt;

&lt;p&gt;无论是函数调用，或者线程切换，都会保存上下文，等到函数调用返回或线程切回来时，才能继续处理之前未完成的逻辑。而我们的异步模型（其实就是状态机），也是类似的道理，我们需要在请求发送时保存好上下文，才能在收到回包时继续之前的逻辑往下走。
saf 是基于 libuv 的，因此我使用 libuv 的 handle 结构体的 data 字段来保存上下文。如果是直接使用 epoll 来实现异步server，则可以用 fd 来绑定上下文（全局的 map，key 为 fd，value 为上下文信息）。&lt;/p&gt;

&lt;h2&gt;消息透传&lt;/h2&gt;

&lt;p&gt;既然各个状态是有依赖关系的，那就得有一个消息（message）实体贯穿整个处理流程。通过这个消息实体来传递各个状态所需要的信息。这也是为什么 saf 中 action 和 state 的接口都有一个 msg 参数的原因（见下节&lt;strong&gt;接口设计&lt;/strong&gt;）。&lt;/p&gt;

&lt;h2&gt;接口设计&lt;/h2&gt;

&lt;p&gt;封装一个异步框架，意味着对于框架使用者来说其无需关心网络收发包的细节，只需关心自身业务逻辑的实现。那我们在设计接口上就需要屏蔽这些细节。&lt;/p&gt;

&lt;p&gt;既然要对使用者屏蔽收发包细节，表明收包和发包的回调都由框架来控制。因此我们只需要暴露打包请求包和解包回包的接口给使用者去实现。框架调用使用者实现的打包接口后，将打好的 buffer 发送出去，在收到回包之后，再调用使用者实现的解包接口来处理回包。&lt;/p&gt;

&lt;p&gt;在 saf 的接口设计中，我尽量保持接口命名的统一，&lt;code&gt;prepareProcess&lt;/code&gt; 表示在执行前的预处理工作，&lt;code&gt;afterProcess&lt;/code&gt; 表示执行完后的后续处理工作。下面可以看到在不同的模块中，&lt;code&gt;prepareProcess&lt;/code&gt; 和 &lt;code&gt;afterProcess&lt;/code&gt; 的功能略有不同。&lt;/p&gt;

&lt;h3&gt;消息类&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;//msg.h

class Msg {
public:
    virtual ~Msg() {}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如上所述，消息用于状态之间传递依赖的信息，由业务自行继承添加所需成员。&lt;/p&gt;

&lt;h3&gt;Handler 类&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    //handler.h

    /*
     * 解析客户端请求包
     * 返回 &amp;gt; 0 表示收包不完整
     * 返回 0 表示解析成功
     * 返回 &amp;lt; 0 表示解包失败, server将会杀掉客户端连接
     */
    virtual int prepareProcess(char* buf, unsigned int len, Msg* msg) = 0;

    /*
     * 打包客户端回包到输入 buf 中,len 为输入 buf 长度
     * 返回 &amp;gt; 0 表示 buf 不够, len 为实际需要的 buf 长度
     * 返回 0 表示打包成功, len 为 buf 的实际长度
     * 返回 &amp;lt; 0 表示打包失败, server将会杀掉客户端连接
     */
    virtual int afterProcess(char* buf, unsigned int&amp;amp; len, Msg* msg) = 0;

    /*
     * 创建该 handler 的 msg
     */
    virtual Msg* createMsg() = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Handler 类对应客户端请求的处理流程。业务继承 Handler 基类，实现请求包和回包的打解包接口以及创建业务消息的接口。&lt;/p&gt;

&lt;p&gt;在 Handler 的构造函数添加该 Handler 包含的 State。在收到客户端请求后，框架调用相应的 Handler 的 &lt;code&gt;prepareProcess&lt;/code&gt; 接口对客户端请求进行解包。然后依次执行各个 State，全部 State 执行完成后，框架调用该 Handler 的 &lt;code&gt;afterProcess&lt;/code&gt; 将回包打包到传入的 buffer 参数，再由框架将该 buffer 发送回客户端。&lt;/p&gt;

&lt;h3&gt;State 类&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    // state.h

    /*
     * 执行 state 包含的 action 前, 框架会调用该函数, 可以做预处理工作
     * 返回 0 表示成功
     * 返回 != 0 表示失败
     */
    virtual int prepareProcess(Msg* msg) { return 0; };
    /*
     * state 包含的 action 都执行完时, 框架会调用该函数,可以做一些后续处理工作
     * 返回 0 表示成功
     * 返回 != 0 表示失败
     */
    virtual int afterProcess(Msg* msg) { return 0; };
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;State 类对应上面&lt;strong&gt;模型抽象化&lt;/strong&gt;小节的&lt;strong&gt;状态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在 State 的构造函数添加该 State 包含的 Action。State 执行前，框架调用该 State 的 &lt;code&gt;prepareProcess&lt;/code&gt; 接口，使用者可以在该接口做些预处理工作。当 State 执行完成后，框架调用该 State 的 &lt;code&gt;afterProcess&lt;/code&gt; 接口。&lt;/p&gt;

&lt;h3&gt;Action 类&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    //action.h 

    /*
     * 设置 action 的目的 ip，端口和通信协议（目前只支持tcp） 
     */
    void setActionInfo(const std::string&amp;amp; ip, int port, int protocol);

    /*
     * 设置 action 的超时时间，单位为毫秒。 &amp;lt;=0 为永不超时
     */
    void setTimeout(unsigned int timeout) { m_timeout = timeout; }  

    /*
     * 打包 Action 请求包到输入 buf 中, len 为输入 buf 的长度
     * 返回 0 表示打包成功, len 为实际需要的 buf 长度
     * 返回 &amp;gt; 表示 buf 不够, len 为实际需要的 buf 长度
     * 返回 &amp;lt; 0 表示失败
     */
    virtual int prepareProcess(char* buf, unsigned int&amp;amp; len, Msg* msg) = 0;

    /*
     * 解析 Action 回包
     * 返回 0 表示解析回包成功
     * 返回 &amp;lt; 0 表示出错
     * 返回 &amp;gt; 0 表示收包未完整
     */
    virtual int afterProcess(char* buf, unsigned int len, Msg* msg) = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Action 类对应上面&lt;strong&gt;模型抽象化&lt;/strong&gt;小节的&lt;strong&gt;动作&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Action 执行前，框架调用该 Action 的 &lt;code&gt;prepareProcess&lt;/code&gt; 接口，将 Action 的请求包打包到传入的 buffer 参数，当收到 Action 的回包后，框架会调用 Action 的 &lt;code&gt;afterProcess&lt;/code&gt; 接口，将回包解包。&lt;/p&gt;

&lt;h3&gt;REGISTER_HEADER_PARSER&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;REGISTER_HEADER_PARSER&lt;/code&gt; 宏用于注册解析请求包头函数。&lt;/p&gt;

&lt;h3&gt;REGISTER_HANDLER&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;REGISTER_HANDLER&lt;/code&gt; 宏用于注册请求对应的 handler 类&lt;/p&gt;

&lt;h2&gt;状态机逻辑&lt;/h2&gt;

&lt;p&gt;接下来看看 saf 如何将 handler／state／action 串联起来（代码有所简化）&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    //handler.cpp
    /* 
     * 主逻辑，ClientContext 保存了客户端会话的上下文
     * 其 m_state_idx 成员表示当前所属的状态 id
     * m_action_idx 成员表示处于当前所属状态的动作id
     * m_msg 即业务定义的消息类，被透传给 state 和 action 中
     */  
    void Handler::process(ClientContext* c_ctx) {
        if (c_ctx-&amp;gt;m_state_idx &amp;lt; m_state_list.size()) {
            State* state = m_state_list[c_ctx-&amp;gt;m_state_idx++];
            // 执行 state 前, 将 action_idx 置 0
            c_ctx-&amp;gt;m_action_idx = 0;
            // 调用 state 的 prepareProcess 接口
            state-&amp;gt;prepareProcess(c_ctx-&amp;gt;m_msg);
            // 开始执行该state
            state-&amp;gt;process(c_ctx);   
        } else {
            static char buf[DEFAULT_BUF_SIZE];
            char* actual_buf = buf;
            unsigned int actual_len = DEFAULT_BUF_SIZE;
            // 调用 handler 的 afterProcess 接口，打包回包到 actual_buf 中
            afterProcess(actual_buf, actual_len, c_ctx-&amp;gt;m_msg);
            // 发送回包给客户端
            c_ctx-&amp;gt;sendResponse(actual_buf, actual_len);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    //state.cpp

    /* 
     * state 处理逻辑
     */
    void State::process(ClientContext* c_ctx) {
        // 如果没有action,直接finish
        if (m_action_list.size() == 0) {
            finish(c_ctx);
            return;
        }

        static char buf[DEFAULT_BUF_SIZE];
        char* actual_buf = NULL;
        unsigned int actual_len = 0; // buf 的实际长度
        int ret = 0;

        // 执行该 state 下所有 action 
        for(unsigned int i = 0; i &amp;lt; m_action_list.size(); i++) {
            Action* action = m_action_list[i];
            actual_len = DEFAULT_BUF_SIZE;
            actual_buf = buf;
            // 调用 action 的 prepareProcess 接口，打包 action 的请求包到 actual_buf 中
            action-&amp;gt;prepareProcess(actual_buf, actual_len, c_ctx-&amp;gt;m_msg);
            // 执行该 action
            c_ctx-&amp;gt;processAction(action, actual_buf, actual_len);
        }
    }

    // action 完成后回调该接口，如果所有action都完成，则调用下面的 finish 接口
    void State::finishAction(ClientContext* c_ctx) {
        printf(&amp;quot;finishAction\n&amp;quot;);
        c_ctx-&amp;gt;m_action_idx++;
        if (c_ctx-&amp;gt;m_action_idx &amp;gt;= m_action_list.size()) {
            finish(c_ctx);
        }
    }

    // 调用 state 所属的 handler 的 process 函数
    void State::finish(ClientContext* c_ctx) {
        afterProcess(c_ctx-&amp;gt;m_msg);
        m_handler-&amp;gt;process(c_ctx);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    //ClientContext.cpp

    /*
     * action 收到回包后的回调
     */
    static void recvActionRsp(uv_stream_t *server, ssize_t nread, const uv_buf_t *buf) {
        // data 字段保存了 action 的上下文
        ActionContext* a_ctx = (ActionContext*) server-&amp;gt;data;
        a_ctx-&amp;gt;recv_buf.append(buf-&amp;gt;base, nread);
        // action 的上下文中保存了客户端请求的上下文
        ClientContext* c_ctx = a_ctx-&amp;gt;c_ctx;
        // 调用 action 的 afterProcess 接口
        int ret = a_ctx-&amp;gt;action-&amp;gt;afterProcess(a_ctx-&amp;gt;recv_buf.data(), a_ctx-&amp;gt;recv_buf.len(), c_ctx-&amp;gt;m_msg);
        // 通知 action 所属的 state 该 action 完成了
        a_ctx-&amp;gt;action-&amp;gt;m_state-&amp;gt;finish(a_ctx-&amp;gt;c_ctx);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;样例&lt;/h2&gt;

&lt;p&gt;以下是 saf 的一个简单的 &lt;a href=&quot;https://github.com/Masutangu/SAF/blob/master/sample.cpp&quot;&gt;demo&lt;/a&gt;。代码仅说明用，所以比较简单粗暴。该 server 的所有请求都由 myHandler 来处理，myHandler 包含一个状态 myState1。myState1 包含一个 Action, 该 Action 将客户端请求包拷贝并通过 tcp 发送给 127.0.0.1:7000 的服务，接收到回包后再把回包原样发回给客户端。  &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;//
// Created by Masutangu on 16/8/9.
//

#include &amp;quot;saf/header.h&amp;quot;

#include &amp;lt;cstring&amp;gt;

using namespace saf;

const int BUF_SIZE = 1024;

class myMsg: public Msg {
public:
    char readbuf[BUF_SIZE];
    char writebuf[BUF_SIZE];
};

class myAction: public Action {
public:
    int prepareProcess(char* buf, unsigned int&amp;amp; len, Msg* msg);
    int afterProcess(char* buf, unsigned int len, Msg* msg);
};

int myAction::prepareProcess(char* buf, unsigned int&amp;amp; len, Msg* msg) {
    myMsg* my_msg = static_cast&amp;lt;myMsg*&amp;gt; (msg);
    printf(&amp;quot;myAction prepareProcess, data: %s\n&amp;quot;, my_msg-&amp;gt;readbuf);
    if (len &amp;gt;= BUF_SIZE) {
        memcpy(buf, my_msg-&amp;gt;readbuf, BUF_SIZE);
        return 0;
    } else {
        len = BUF_SIZE;
        return BUF_SIZE;
    }

}

int myAction::afterProcess(char* buf, unsigned int len, Msg* msg) {
    printf(&amp;quot;myAction afterProcess: %s\n&amp;quot;, buf);
    myMsg* my_msg = static_cast&amp;lt;myMsg*&amp;gt; (msg);
    memcpy(my_msg-&amp;gt;writebuf, buf, len &amp;lt; BUF_SIZE ? len:BUF_SIZE);
    return 0;
}

class myState1: public State {
public:
    myState1();
};

myState1::myState1() {
    myAction* action = new myAction;
    action-&amp;gt;setActionInfo(&amp;quot;127.0.0.1&amp;quot;, 7000, 0); //设置action的ip和端口
    addAction(action);
}

class myHandler: public Handler {
public:
    myHandler();
    Msg* createMsg();
    int prepareProcess(char* buf, unsigned int len, Msg* msg);
    int afterProcess(char* buf, unsigned int&amp;amp; len, Msg* msg);

};

Msg* myHandler::createMsg() {
    return new myMsg();
}

myHandler::myHandler() {
    myState1* state1 = new myState1();
    addState(state1);

}

int myHandler::prepareProcess(char* buf, unsigned int len, Msg* msg) {
    printf(&amp;quot;handler: prepareProcess len=%d\n&amp;quot;, len);
    myMsg* my_msg = static_cast&amp;lt;myMsg*&amp;gt; (msg);
    memcpy(my_msg-&amp;gt;readbuf, buf, len);
    return 0;
}

int myHandler::afterProcess(char* buf, unsigned int&amp;amp; len, Msg* msg) {
    myMsg* my_msg = static_cast&amp;lt;myMsg*&amp;gt; (msg);
    if (len &amp;gt;= 1024) {
        memcpy(buf, my_msg-&amp;gt;writebuf, 1024);
        return 0;
    } else {
        len = 1024;
        return 1;
    }
}

int parseReq(char* buf, unsigned int len) {
    return 1; // 该请求的类型为 1，由 myHandler 处理
}

int main() {
    REGISTER_HANDLER(1, myHandler);  // 请求类型为 1 的由 myHandler 类处理
    REGISTER_HEADER_PARSER(parseReq); // 请求包头由 parseReq 函数解析

    AsyncServer server = AsyncServer();
    server.setBindAddress(&amp;quot;0.0.0.0&amp;quot;, 8000); // 监听 8000 端口
    server.run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;由于时间和能力有限，saf 目前来说非常简陋，也没有经过严格的测试。对于一个框架来说，要做的事情还有很多，比如日志模块的完善、性能分析和优化。不过，&lt;strong&gt;done is better than perfect&lt;/strong&gt;. 最后，如有问题或意见，欢迎留言或者 email 我，也欢迎转载分享～&lt;/p&gt;
</description>
        <pubDate>Tue, 30 Aug 2016 08:14:24 +0800</pubDate>
        <link>http://masutangu.com/2016/08/simple-async-framework/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/08/simple-async-framework/</guid>
        
        
        <category>个人项目</category>
        
      </item>
    
      <item>
        <title>工作两年记</title>
        <description>&lt;p&gt;转眼间，我也已经工作了快两年了。两年，在互联网行业，是一个尴尬的时间点。一方面，你不再是一个新人，意味着你的潜力已经渐渐被挖掘得差不多了。另一方面，你又还没完全成长，你会承担一些责任，但也许还没办法掌控全局，做到游刃有余。&lt;/p&gt;

&lt;p&gt;回想起刚入职，由于自己完全没有工程经验，心里相当忐忑。机缘巧合，leader 给我分配的第一个任务是爬虫。Python 对于新手来说相当的友好，我很快就上手并能够做出一些简单的成果。之后又熟悉了 Django，了解 MVC。之后再尝试空闲时间读一些库的源码，并最终自己用 Python 写了一个开源项目 &lt;a href=&quot;https://github.com/Masutangu/Elric&quot;&gt;Elric&lt;/a&gt;（基于 Apscheduler ）。这些经历极大得提升了我的自信心，也锻炼了我的代码能力和少部分的架构能力。&lt;/p&gt;

&lt;p&gt;第二年的时候，我给自己的计划是多学习新的知识点，重在求广。因此我学了 Golang，写了个小项目 &lt;a href=&quot;https://github.com/Masutangu/SuperScripter&quot;&gt;SuperScripter&lt;/a&gt; 练手（最终这个项目的进化版用在了工作中）；学习了 iOS，写了一个简单的 &lt;a href=&quot;https://github.com/Masutangu/ToDo&quot;&gt;ToDoList&lt;/a&gt;, 对客户端有了些了解；读了 NSQ 的源码，大致了解消息队列的实现；还读了一段时间的非技术类的文章（读书笔记：&lt;a href=&quot;http://masutangu.com/2015/12/dewdrop-note-1/&quot;&gt;水滴石穿&lt;/a&gt;），希望自己的思维可以更宽广，可惜后来没坚持下去。&lt;/p&gt;

&lt;p&gt;到了今年的年初，我感觉自己在技术上到了一个瓶颈，对于职业发展也有些迷茫。总会觉得自己在原地踏步，会的更熟练，不会的还是不会，让我有些急躁，心情也不是特别好。有一阵子我每天一闲下来就会想：“到底怎么做才能更进一步？”，始终绕不出这个困扰。后来我发现想要驱除内心的恐慌，取得让自己满意的进步，唯一的方法就是花时间做一些更深入的研究，而不是浮在表面。浮在表面让我非常没有安全感，如果你很快就能学会的，别人也可以。所以我不再把重心放在新知识上，打算打牢基础，并在自己感兴趣的领域做些探索。&lt;/p&gt;

&lt;p&gt;想清楚后，我规划了接下来这一年的学习路线：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;回归语言的本质&lt;/p&gt;

&lt;p&gt;学再多语言，不深入思考的话，也只是学到皮毛。不应该止步于会用，而是要深入到编程语言的设计哲学。我希望之后在这方面有一些理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络框架读源码，造轮子&lt;/p&gt;

&lt;p&gt;在公司工作，都有了现成的框架。就算自己做项目，也有很多开源框架可以使用。和编程语言类似，我希望自己能够再深入些，比如读读协程／异步／同步框架的代码，比较他们的适用场景，最好是能够自己造一些轻量级的轮子加深理解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;巩固操作系统/编译原理/网络基础&lt;/p&gt;

&lt;p&gt;看书学习理论，造轮子加深理解。也许工作中 90% 的情况下不需要这些知识，但总会有 10% 的概率会出各种奇奇怪怪的问题，这时就是考验基本功的时候了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我觉得第两年到第三年，是一个关键点。这一年，我希望兑现全部潜力，大幅度提升自己的能力，不仅是代码能力、架构能力，还有工程素养。我希望三年级的我，可以扛起重任。就像 NBA 的球员一样，经历了两年的磨砺，三年级，也该去争取进入全明星，争取一阵，争取属于自己的总冠军了！&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jul 2016 21:24:34 +0800</pubDate>
        <link>http://masutangu.com/2016/07/conclusion-of-two-years/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/conclusion-of-two-years/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>Elric 使用手册</title>
        <description>&lt;p&gt;这篇文章正式介绍下我之前用 Python 实现的分布式任务框架 &lt;a href=&quot;https://github.com/Masutangu/Elric&quot;&gt;Elric&lt;/a&gt;，包括其API，架构，周边能力以及实现细节。&lt;/p&gt;

&lt;p&gt;读者可以先阅读之前的这篇文章《&lt;a href=&quot;http://masutangu.com/2015/08/elric-distributed-job-scheduler-by-python/&quot;&gt;Python实现的分布式任务调度系统&lt;/a&gt;》来了解Elric的起源和早期设计的思想。&lt;/p&gt;

&lt;h1&gt;一. 简介&lt;/h1&gt;

&lt;p&gt;Elric 是一个 Python 实现的简单的分布式任务框架。Master-Worker 架构，Worker 向 Master 提交任务和执行 Master 下发的任务。支持多种任务类型：即时任务，周期任务，crontab 任务和定时任务。
其实现参考了 &lt;a href=&quot;https://apscheduler.readthedocs.io/en/latest/&quot;&gt;Apscheduler&lt;/a&gt;，Elric 的部分逻辑参考了 Apscheduler， 部分代码（trigger）取自 Apscheduler。&lt;/p&gt;

&lt;h1&gt;二. API&lt;/h1&gt;

&lt;h2&gt;Master&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化和启动 Master&lt;/p&gt;

&lt;p&gt;启动 Master 很简单，样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import os
os.environ.setdefault(&amp;#39;ELRIC_SETTINGS_MODULE&amp;#39;, &amp;#39;settings&amp;#39;)  # 设置 settings.py

from elric.master.rqextend import RQMasterExtend

rq_Master = RQMasterExtend()
rq_Master.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Worker&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化和启动 Worker&lt;/p&gt;

&lt;p&gt;Worker 的构造函数稍微复杂一些：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def __init__(self, name, listen_keys=None, Worker_num=2, timezone=None, logger_name=&amp;#39;elric.Worker&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;name：Worker 的名字，不同用途的 Worker 应该取不同的名字。&lt;/li&gt;
&lt;li&gt;listen_keys：Worker 监听的任务队列名，类型为 list。&lt;/li&gt;
&lt;li&gt;Worker_num：Worker 的进程池数。&lt;/li&gt;
&lt;li&gt;timezone：时区，默认为 local。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动 Worker 将会开始从监听的任务队列里取任务来执行，初始化和启动 Worker 的样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import os
os.environ.setdefault(&amp;#39;ELRIC_SETTINGS_MODULE&amp;#39;, &amp;#39;settings&amp;#39;)  # 设置 settings.py

from elric.worker.rqueue import RQWorker

rq_Worker = RQWorker(name=&amp;#39;test&amp;#39;, listen_keys=[&amp;#39;job1&amp;#39;, &amp;#39;job2&amp;#39;])
rq_Worker.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上述代码初始化一个名字为 test 的 Worker，它将从 job1，job2 这两个任务队列中取下任务来执行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提交任务&lt;/p&gt;

&lt;p&gt;提交任务的接口如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def submit_job(self, func, job_key, args=None, kwargs=None, trigger=None, job_id=None,
               replace_exist=False, need_filter=False, **trigger_args)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;func：提交该任务需要执行的函数。&lt;/li&gt;
&lt;li&gt;job_key：该任务将提交的任务队列名。&lt;/li&gt;
&lt;li&gt;args：提交的函数执行所需要的位置参数。&lt;/li&gt;
&lt;li&gt;kwargs：提交的函数执行所需要的命名参数。&lt;/li&gt;
&lt;li&gt;trigger：提交任务的执行时间信息，date 为定时任务，cron 为 crontab 任务、interval 为周期任务，为空则为即时任务。&lt;/li&gt;
&lt;li&gt;job_id：提交任务的id，用于调试和去重。如果没有提供将自动生成一个随机id。&lt;/li&gt;
&lt;li&gt;need_filter：是否去重。Master 使用 (job_key，job_id) 唯一标记一个任务。如果 need_filter 为 True，submit_job 时会 Master 会检查去重模块 dupefilter 是否有（job_key，job_id）任务成功执行的记录，如果已存在则被过滤。该特性主要用于爬虫。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;去重&lt;/h2&gt;

&lt;p&gt;Elric 支持任务去重，通常这个特性用于爬虫，比如爬取过的页面无需再次爬取时，可以通过设置 need_filter 为 True 来实现：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;blog_url = &amp;#39;http://masutangu.com/&amp;#39;
rq_worker = RQWorker(name=&amp;#39;crawler&amp;#39;, listen_keys=[&amp;#39;crawl_blog&amp;#39;, ])
rq_worker.submit_job(crawl_blog, &amp;#39;crawl_blog&amp;#39;, args=[blog_url], job_id=blog_url)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;任务执行完成后，Master 的 dupefilter 模块会标记（&amp;#39;crawl_blog&amp;#39;，&amp;#39;&lt;a href=&quot;http://masutangu.com/&quot;&gt;http://masutangu.com/&lt;/a&gt;&amp;#39; ）任务已经执行成功。之后如果 Master 再次接收到任务，会到 dupefilter 模块查询是否有相应的记录，如果存在则直接过滤该任务，不再下发。&lt;/p&gt;

&lt;h2&gt;配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Masutangu/Elric/blob/master/settings.py&quot;&gt;settings.py&lt;/a&gt; 文件的配置信息如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DISTRIBUTED_LOCK_CONFIG：Master分布式锁的相关配置。&lt;/li&gt;
&lt;li&gt;JOB_QUEUE_CONFIG：任务队列的相关配置。&lt;/li&gt;
&lt;li&gt;FILTER_CONFIG：去重的相关配置。&lt;/li&gt;
&lt;li&gt;JOB_STORE_CONFIG：任务存储的相关配置。&lt;/li&gt;
&lt;li&gt;LOGGINGF_CONFIG：日志的相关配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置由环境变量设置，可以在代码中使用&lt;code&gt;os.environ.setdefault(&amp;#39;ELRIC_SETTINGS_MODULE&amp;#39;, &amp;#39;settings&amp;#39;)&lt;/code&gt;，或通过命令行设置环境变量&lt;code&gt;export ELRIC_SETTINGS_MODULE=settings&lt;/code&gt;来指定使用的settings.py，方便管理。&lt;/p&gt;

&lt;h2&gt;样例代码&lt;/h2&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import os
os.environ.setdefault(&amp;#39;ELRIC_SETTINGS_MODULE&amp;#39;, &amp;#39;settings&amp;#39;)  # 设置 settings.py

from elric.worker.rqueue import RQWorker

def wapper_job():
    print &amp;#39;run first job&amp;#39;
    rq_Worker.submit_job(nest_job, &amp;#39;job1&amp;#39;, args=[&amp;#39;hi i am nested job&amp;#39;])

def nest_job(welcome):
    print welcome

def test_job(language=None):
    print &amp;#39;my favorite language is {language}&amp;#39;.format(language=language)

def test_date_job():
    print &amp;#39;hello i am date job&amp;#39;

def test_cron_job():
    print &amp;#39;hello i am crontab job&amp;#39;

if __name__ == &amp;#39;__main__&amp;#39;:
    # 初始化名字为 test 的 Worker ，监听 &amp;#39;job1&amp;#39; 和 &amp;#39;job2&amp;#39; 这两个任务队列
    rq_worker = RQWorker(name=&amp;#39;test&amp;#39;, listen_keys=[&amp;#39;job1&amp;#39;, &amp;#39;job2&amp;#39;])

    # 向 Master 提交任务，该任务将由 Master 在 2015-07-17 21:13:30 这个时间点通过 &amp;#39;job1&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_date_job 函数
    rq_worker.submit_job(test_date_job, &amp;#39;job1&amp;#39;, trigger=&amp;#39;date&amp;#39;, run_date=&amp;#39;2015-07-17 21:13:30&amp;#39;)

    # 向 Master 提交任务，该任务将每隔30秒由 Master 通过 &amp;#39;job1&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 wapper_job 函数
    rq_worker.submit_job(wapper_job, &amp;#39;job1&amp;#39;, trigger=&amp;#39;interval&amp;#39;, seconds=30)

    # 向 Master 提交任务，该任务为即时任务（没有提供trigger），将马上由Master 通过任务队列 &amp;#39;job2&amp;#39; 下发给 Worker ，Worker 拿到后将执行 test_job 函数
    rq_worker.submit_job(test_job, &amp;#39;job2&amp;#39;, kwargs={&amp;#39;language&amp;#39;: &amp;#39;python&amp;#39;})

    # 向 Master 提交任务，该任务将在每分钟的第7秒由 Master 通过 &amp;#39;job2&amp;#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_cron_job 函数
    rq_worker.submit_job(test_cron_job, &amp;#39;job2&amp;#39;, trigger=&amp;#39;cron&amp;#39;, second=7)

    # 启动 Worker，如果 &amp;#39;job1&amp;#39; 或 &amp;#39;job2&amp;#39; 有任务则拉取下来执行
    rq_worker.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;完整的demo可见&lt;a href=&quot;https://github.com/Masutangu/Elric/tree/master/example&quot;&gt;https://github.com/Masutangu/Elric/tree/master/example&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;三. 架构&lt;/h1&gt;

&lt;p&gt;Elric 架构图如下：
&lt;img src=&quot;/assets/images/elric-documentation/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运转流程如下（包含部分实现细节）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Worker 调用 submit_job 提交任务，该任务将存放在任务队列的 &amp;#39;&lt;strong&gt;elric_submit_channel&lt;/strong&gt;&amp;#39; 队列中，等待 Master 处理。同时启动 Worker，Worker 将监听其感兴趣的任务队列，比如 &amp;#39;job1&amp;#39; 队列。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Master 从任务队列 &amp;#39;&lt;strong&gt;elric_submit_channel&lt;/strong&gt;&amp;#39; 中拉取 Worker 提交的任务，然后做如下处理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;去重处理：&lt;/p&gt;

&lt;p&gt;首先判断任务的 need_filter 是否为 True，如果为 True，则由 dupefilter 模块去重，已经执行过的将被过滤掉。为 False 则跳过该步骤。  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非即时处理：&lt;/p&gt;

&lt;p&gt;如果任务不是即时任务（ trigger 不为空），则将该任务存储到任务存储 jobstore 中，Master 有另一线程定时扫描 jobstore 取出到期任务来下发。如果为即时任务，则跳过该步骤。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;任务下发：&lt;/p&gt;

&lt;p&gt;将即时任务或到期任务下发到相应的任务队列，例如放到名为 &amp;#39;job1&amp;#39; 的任务队列。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Worker 监听到 &amp;#39;job1&amp;#39; 任务队列有新任务，取出后交给 executor 来执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;四. 周边能力&lt;/h1&gt;

&lt;p&gt;任务的执行结果存放在 mongodb ，为了方便使用者查询和定位问题，我提供了一个简单粗糙的 web 服务：&lt;a href=&quot;https://github.com/Masutangu/ElricStats&quot;&gt;ElricStats&lt;/a&gt;，通过他可以方便的查询每个任务执行的时间和结果。&lt;/p&gt;

&lt;h1&gt;五. 实现细节&lt;/h1&gt;

&lt;h2&gt;Master的分布式锁&lt;/h2&gt;

&lt;p&gt;为了支持多机器部署Master，在某些操作需要有锁的机制来保证原子性，比如在查询 jobstore 并取出到期任务下发时，简化代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
    # 将任务下发到任务队列
    self._enqueue_job(job_key, serialized_job)

    # 获取任务的下次执行时间，并更新到 jobstore 
    job = Job.deserialize(serialized_job)
    last_run_time = Job.get_serial_run_times(job, now)
    job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
    self.update_job(job)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果在这个操作没有加锁保证原子性，将有可能下发重复的任务。这里我采用了redis实现的分布式锁来解决这个问题。其原理利用了 redis 的 setnx 命令，详细可以查看这篇文章《&lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;Distributed locks with Redis&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;我把分布式锁封装成 Context Managers 的形式：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class distributed_lock(object):
    def __init__(self, **config):
        self.config = config
        self.dlm = redlock.Redlock([config[&amp;#39;server&amp;#39;], ],
                                retry_count=config[&amp;#39;retry_count&amp;#39;],
                                retry_delay=config[&amp;#39;retry_delay&amp;#39;])
        self.dlm_lock = None

    def __enter__(self):
        while not self.dlm_lock:
            self.dlm_lock = self.dlm.lock(self.config[&amp;#39;resource&amp;#39;], 1000)
            if self.dlm_lock:
                break
            else:
                time.sleep(self.config[&amp;#39;retry_delay&amp;#39;])

    def __exit__(self, type, value, traceback):
        self.dlm.unlock(self.dlm_lock)
        self.dlm_lock = None
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这样就可以使用 with statement 来管理：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;with distributed_lock(**DISTRIBUTED_LOCK_CONFIG):
    for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
        # 将任务下发到任务队列
        self._enqueue_job(job_key, serialized_job)

        # 获取任务的下次执行时间，并更新到 jobstore 
        job = Job.deserialize(serialized_job)
        last_run_time = Job.get_serial_run_times(job, now)
        job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
        self.update_job(job)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1&gt;六. 后续优化&lt;/h1&gt;

&lt;p&gt;Elric 目前来说还比较粗糙，后续有时间我希望对下面这几个方面做些优化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置规范化：目前我的配置文件 settings.py （包括logging模块）的实现并不规范，后续希望参考 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt; 的做法来实现配置管理。 &lt;/li&gt;
&lt;li&gt;防雪崩机制优化：目前防雪崩机制比较简单，在任务队列满的时候 Master 会缓存一部分任务。后期改造成在下发的任务里带上任务的下发时间，Worker 取到任务后如果发现任务已经过期一段时间则直接抛弃。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Jul 2016 15:02:11 +0800</pubDate>
        <link>http://masutangu.com/2016/07/elric-documentation/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/elric-documentation/</guid>
        
        
        <category>个人项目</category>
        
      </item>
    
      <item>
        <title>Python笔记</title>
        <description>&lt;p&gt;这篇文章整理了python相关的资料，包括性能优化、常见错误和高级用法。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：本文内容整理自网上博客，《Python Cookbook》等，非原创。&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;性能优化&lt;/h2&gt;

&lt;h3&gt;1. 字典和列表&lt;/h3&gt;

&lt;p&gt;Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from time import time
t = time()
list = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;is&amp;#39;,&amp;#39;python&amp;#39;,&amp;#39;jason&amp;#39;,&amp;#39;hello&amp;#39;,&amp;#39;hill&amp;#39;,&amp;#39;with&amp;#39;,&amp;#39;phone&amp;#39;,&amp;#39;test&amp;#39;,
&amp;#39;dfdf&amp;#39;,&amp;#39;apple&amp;#39;,&amp;#39;pddf&amp;#39;,&amp;#39;ind&amp;#39;,&amp;#39;basic&amp;#39;,&amp;#39;none&amp;#39;,&amp;#39;baecr&amp;#39;,&amp;#39;var&amp;#39;,&amp;#39;bana&amp;#39;,&amp;#39;dd&amp;#39;,&amp;#39;wrd&amp;#39;]
#list = dict.fromkeys(list,True)
print list
filter = []
for i in range (1000000):
    for find in [&amp;#39;is&amp;#39;,&amp;#39;hat&amp;#39;,&amp;#39;new&amp;#39;,&amp;#39;list&amp;#39;,&amp;#39;old&amp;#39;,&amp;#39;.&amp;#39;]:
        if find not in list:
            filter.append(find)
print &amp;quot;total run time:&amp;quot;
print time()-t
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;将list转化为dict后速度提升了将近一半。&lt;/p&gt;

&lt;h3&gt;2. 集合和列表&lt;/h3&gt;

&lt;p&gt;set 的 union， intersection，difference 操作要比 list 的迭代要快。因此如果涉及到求 list 交集，并集或者差的问题可以转换为 set 来操作。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# 使用list：
from time import time
t = time()
lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]
listb=[2,4,6,9,23]
intersection=[]
for i in range (1000000):
for a in lista:
    for b in listb:
        if a == b:
            intersection.append(a)

print &amp;quot;total run time:&amp;quot;
print time()-t

# 使用set：
from time import time
t = time()
lista=[1,2,3,4,5,6,7,8,9,13,34,53,42,44]
listb=[2,4,6,9,23]
intersection=[]
for i in range (1000000):
    list(set(lista)&amp;amp;set(listb))
print &amp;quot;total run time:&amp;quot;
print time()-t
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;3. 字符串的优化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在字符串连接的使用尽量使用 join() 而不是 +。&lt;/li&gt;
&lt;li&gt;当对字符串可以使用正则表达式或者内置函数来处理的时候，选择内置函数。如 str.isalpha()，str.isdigit()，str.startswith((‘x’, ‘yz’))，str.endswith((‘x’, ‘yz’))&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对字符进行格式化比直接串联读取要快，因此要&lt;/p&gt;

&lt;p&gt;使用：&lt;code&gt;out = &amp;quot;&amp;lt;html&amp;gt;%s%s%s%s&amp;lt;/html&amp;gt;&amp;quot; % (head, prologue, query, tail)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;避免：&lt;code&gt;out = &amp;quot;&amp;lt;html&amp;gt;&amp;quot; + head + prologue + query + tail + &amp;quot;&amp;lt;/html&amp;gt;&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;4. 使用列表解析和生成器表达式&lt;/h3&gt;

&lt;p&gt;列表解析要比在循环中重新构建一个新的 list 更为高效，因此我们可以利用这一特性来提高运行的效率。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from time import time
t = time()
list = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;is&amp;#39;,&amp;#39;python&amp;#39;,&amp;#39;jason&amp;#39;,&amp;#39;hello&amp;#39;,&amp;#39;hill&amp;#39;,&amp;#39;with&amp;#39;,&amp;#39;phone&amp;#39;,&amp;#39;test&amp;#39;,
&amp;#39;dfdf&amp;#39;,&amp;#39;apple&amp;#39;,&amp;#39;pddf&amp;#39;,&amp;#39;ind&amp;#39;,&amp;#39;basic&amp;#39;,&amp;#39;none&amp;#39;,&amp;#39;baecr&amp;#39;,&amp;#39;var&amp;#39;,&amp;#39;bana&amp;#39;,&amp;#39;dd&amp;#39;,&amp;#39;wrd&amp;#39;]
total=[]
for i in range (1000000):
for w in list:
    total.append(w)
print &amp;quot;total run time:&amp;quot;
print time()-t

# 使用列表解析：
for i in range (1000000):
    a = [w for w in list]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在上述例子上中代码 &lt;code&gt;a = [w for w in list]&lt;/code&gt; 修改为 &lt;code&gt;a = (w for w in list)&lt;/code&gt;，运行时间将进一步减少。&lt;/p&gt;

&lt;h3&gt;5. 其他优化技巧&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果需要交换两个变量的值使用 a,b=b,a 而不是借助中间变量 t=a;a=b;b=t；&lt;/li&gt;
&lt;li&gt;在循环的时候使用 xrange 而不是 range；使用 xrange 可以节省大量的系统内存，因为 xrange() 在序列中每次调用只产生一个整数元素。而 range() 將直接返回完整的元素列表，用于循环时会有不必要的开销。在 python3 中 xrange 不再存在，里面 range 提供一个可以遍历任意长度的范围的 iterator。&lt;/li&gt;
&lt;li&gt;使用局部变量，避免”global” 关键字。python 访问局部变量会比全局变量要快得多，因 此可以利用这一特性提升性能。&lt;/li&gt;
&lt;li&gt;if done is not None 比语句 if done != None 更快，读者可以自行验证；&lt;/li&gt;
&lt;li&gt;在耗时较多的循环中，可以把函数的调用改为内联的方式；&lt;/li&gt;
&lt;li&gt;使用级联比较 “x &amp;lt; y &amp;lt; z” 而不是 “x &amp;lt; y and y &amp;lt; z”；&lt;/li&gt;
&lt;li&gt;while 1 要比 while True 更快（当然后者的可读性更好）；&lt;/li&gt;
&lt;li&gt;build in 函数通常较快，add(a,b) 要优于 a+b。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;常见错误&lt;/h2&gt;

&lt;h3&gt;1. range的使用&lt;/h3&gt;

&lt;p&gt;不恰当的使用range，容易出bug：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for i range(len(alist)):
    print alist[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for item in alist:
    print item
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;不恰当使用range的理由：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要在循环中使用索引：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for index, value in enumerate(alist):
    print index, value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要同时迭代两个循环：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for word, number in zip(words, numbers):
    print word, number
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要迭代序列的一部分：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for word in words[1:]: # 不包括第一个元素
    print word
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;range的正确用法是生成一个数字序列，而不是生成索引：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# Print foo(x) for 0&amp;lt;=x&amp;lt;5
for x in range(5):
    print foo(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;2. 变量泄漏&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for idx, value in enumerate(y):
    if value &amp;gt; max_value:
        break

processList(y, idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当y为空，processList将会抛出异常，原因是idx没有定义。&lt;/p&gt;

&lt;p&gt;正确的处理方式：&lt;strong&gt;哨兵模式&lt;/strong&gt;，在循环前为idx设置一些特殊的值。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;idx ＝ None
for idx, value in enumerate(y):
    if value &amp;gt; max_value:
        break

if idex:
    processList(y, idx)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外作用域&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import sys

# See the bug in the function declaration?
def print_file(filenam):
    &amp;quot;&amp;quot;&amp;quot;Print every line of a file.&amp;quot;&amp;quot;&amp;quot;
    with open(filename) as input_file:
        for line in input_file:
            print line.strip()

if __name__ == &amp;quot;__main__&amp;quot;:
    filename = sys.argv[1]
    print_file(filename)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;此时函数定义中的参数被错误的写为filenam，但是程序依然可以运行。因为print_file的外部作用域存在一个filename的变量。&lt;/p&gt;

&lt;p&gt;正确的做法：&lt;strong&gt;外部作用域的全局变量命名要明显&lt;/strong&gt;，例如IN_ALL_CAPS。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;3. 循环的数据结构导致循环&lt;/h3&gt;

&lt;p&gt;如果在一个对象中发现一个循环，python会输出一个[...]。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;mylist ＝ ［&amp;#39;test&amp;#39;]
mylist.append(mylist)
#此时会打印[&amp;#39;test&amp;#39;,[...]]
print mylist
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;4. 赋值创建引用&lt;/h3&gt;

&lt;p&gt;python中赋值语句不会创建对象副本,只会创建引用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;arr = [1, 2, 3, 4]
arr_cp = arr
arr_cp[0] = 100
#print打印出[100, 2, 3, 4]
print arr
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;5. 静态识别局部变量&lt;/h3&gt;

&lt;p&gt;python默认将一个在函数中赋值的变量名视为局部变量，存在于该函数的作用域并当函数运行时才存在。python是在编译def代码时去静态识别局部变量的。&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;a ＝ 100

＃你可能想先打印a的值，再对a的值进行修改
def myfunc():
    print a
    a = 200
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为在预编译的时候python发现函数中对a有赋值，因此把a当作局部变量。而运行到‘print a’语句的时候，局部变量a尚未赋值，因此会报错。&lt;/p&gt;

&lt;p&gt;正确的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;a ＝ 100

def myfunc():
    global a
    print a
    a = 200
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;更隐晦的错误代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;myVar = 1

def myfunc():
    myVar += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;myVar += 1&lt;/code&gt;其实相当于&lt;code&gt;myVar = myVar + 1&lt;/code&gt;，python检测到myVar变量有赋值操作，因此将myVar添加到局部命名空间中。当执行到&lt;code&gt;myVar += 1&lt;/code&gt;时会读取myVar的值，此时该变量尚未有值关联，因此会报错。&lt;/p&gt;

&lt;h3&gt;6. 默认参数&lt;/h3&gt;

&lt;p&gt;在执行def语句时，默认参数的值只被解析并保存一次。因此在修改可变的默认变量时可能会出现意想不到的效果。&lt;/p&gt;

&lt;p&gt;错误的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def saver(x=[]):
    x.append(1)
    print x

saver() # 打印[1]
saver() # 打印[1,1]
saver() # 打印[1,1,1]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为默认参数只被解析并保存一次。因此可变的默认参数在每次函数调用都会保存状态。&lt;/p&gt;

&lt;p&gt;正确的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def saver(x=None):
    if x is None: x = []
    x.append(1)
    print x
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;def是python中的可执行语句。默认参数在def的语句环境里被计算。如果你执行了def语句多次，每次它都将会创建一个新的函数对象。&lt;/p&gt;

&lt;p&gt;看看stackoverflow的一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;flist = []

for i in xrange(3):
    def func(x): return x * i
    flist.append(func)

for f in flist:
    print f(2) ＃expect 0 2 4 but print 4 4 4
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们可以借助默认参数的机制，在执行def时解析默认参数的值：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;flist=[]
for i in xrange(3):
    def func(x,i=i): return x*i
    flist.append(func)

for f in flist:
    print f(2)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;默认参数还可以用来做缓存：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def calculate(a, b, c, memo={}):
    try:
        value = memo[a, b, c] # return already calculated value
    except KeyError:
        value = heavy_calculation(a, b, c)
    memo[a, b, c] = value # update the memo dictionary
    return value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;牢记：当Python执行一条def语句时， 它会使用已经准备好的东西（包括函数的代码对象和函数的上下文属性），创建了一个新的函数对象。同时，计算了函数的默认参数值。&lt;/p&gt;

&lt;h3&gt;7. 谨慎使用super()&lt;/h3&gt;

&lt;p&gt;原文&lt;a href=&quot;https://fuhm.net/super-harmful/&quot;&gt;Python&amp;#39;s Super is nifty, but you can&amp;#39;t use it&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者提出两个观点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;People omit calls to super(...).&lt;strong&gt;init&lt;/strong&gt; if the only superclass is &amp;#39;object&amp;#39;, as, after all, object.&lt;strong&gt;init&lt;/strong&gt; doesn&amp;#39;t do anything! However, this is very incorrect. Doing so will cause other classes&amp;#39; &lt;strong&gt;init&lt;/strong&gt; methods to not be called.&lt;/li&gt;
&lt;li&gt;People think they know what arguments their method will get, and what arguments they should pass along to super. This is also incorrect.
先看第二点，比较好理解，代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class A(object):
    def __init__(self):
        print &amp;quot;A&amp;quot;
        super(A, self).__init__()

class B(object):
    def __init__(self):
        print &amp;quot;B&amp;quot;
        super(B, self).__init__()

class C(A):
    def __init__(self, arg):
        print &amp;quot;C&amp;quot;,&amp;quot;arg=&amp;quot;,arg
        super(C, self).__init__()

class D(B):
    def __init__(self, arg):
        print &amp;quot;D&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(D, self).__init__()

class E(C,D):
    def __init__(self, arg):
        print &amp;quot;E&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(E, self).__init__(arg)

print &amp;quot;MRO:&amp;quot;, [x.__name__ for x in E.__mro__]
E(10)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;看着很正确，执行下报错：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]
E arg= 10
C arg= 10
A

Traceback (most recent call last):
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 27, in &amp;lt;module&amp;gt;
    E(10)
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 24, in __init__
    super(E, self).__init__(arg)
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 14, in __init__
    super(C, self).__init__()
File &amp;quot;C:\Users\mustangmo\Desktop\test1.py&amp;quot;, line 4, in __init__
    super(A, self).__init__()
TypeError: __init__() takes exactly 2 arguments (1 given)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;原因是：MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]，A的下一个是D，因此super(A, self)方法调用的是D的&lt;strong&gt;init&lt;/strong&gt;方法，D的&lt;strong&gt;init&lt;/strong&gt;方法需要一个参数，因此报错了。&lt;/p&gt;

&lt;p&gt;再看第一点，如果父类是object的话，不调用super().&lt;strong&gt;init&lt;/strong&gt;可能会导致问题，例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class A(object):
    def __init__(self, *args, **kwargs):
        print &amp;quot;A&amp;quot;
        #super(A, self).__init__(*args, **kwargs) 注释掉

class B(object):
    def __init__(self, *args, **kwargs):
        print &amp;quot;B&amp;quot;
        #super(B, self).__init__(*args, **kwargs) 注释掉

class C(A):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;C&amp;quot;,&amp;quot;arg=&amp;quot;,arg
        super(C, self).__init__(arg, *args, **kwargs)

class D(B):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;D&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(D, self).__init__(arg, *args, **kwargs)

class E(C,D):
    def __init__(self, arg, *args, **kwargs):
        print &amp;quot;E&amp;quot;, &amp;quot;arg=&amp;quot;,arg
        super(E, self).__init__(arg, *args, **kwargs)

print &amp;quot;MRO:&amp;quot;, [x.__name__ for x in E.__mro__]
E(10)
```python
输出结果：

&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;MRO: [&amp;#39;E&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;object&amp;#39;]
E arg= 10
C arg= 10
A
```
可以发现D和B都没有输出，也就是说如果没有调用父类为object类的super.&lt;strong&gt;init&lt;/strong&gt;()，会导致其他类（在本例中为D和B）的&lt;strong&gt;init&lt;/strong&gt;()不执行。按理来说，调用了类E的super.&lt;strong&gt;init&lt;/strong&gt;()函数，应该会同时调用E的父类C和D的&lt;strong&gt;init&lt;/strong&gt;()函数。但是由于MRO是以super()调用来驱动的，上诉例子中，执行到A时，由于没有调用super的init()函数了，因此整个链路就停了。
总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一定要调用父类为object的类的super.&lt;strong&gt;init&lt;/strong&gt;()函数&lt;/li&gt;
&lt;li&gt;调用的super()返回不一定是父类，因此super调用最好保持参数一致&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另附一篇也是关于super的文章&lt;a href=&quot;http://rhettinger.wordpress.com/2011/05/26/super-considered-super/&quot;&gt;Python’s super() considered super!&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;8. string转换为dict&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;str = ‘{ &amp;quot;key&amp;quot; : null}&amp;#39;
mydict = eval(str)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;eval 可能会报错，因为 json 的语义跟 Python 的 dict 不完全一样, 如果 json 串里面出现一个 null 就报错了.
因此合适的方法是采用如下写法：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;json.loads()
mydict = json.loads(str)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h2&gt;高级特性&lt;/h2&gt;

&lt;h3&gt;1. 闭包&lt;/h3&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def return_func_that_prints_list(z):
    def f():
        print z
    return f

z = [1, 2]
g = return_func_that_prints_list(z)
g()  # print [1, 2]

z.append(3)
g()  # print [1, 2, 3]
z = [1]
g()  # print [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;【译者】：z.append(3)时，g()内部的引用和z仍然指向一个变量，而z=[1]之后，两者就不再指向一个变量了。&lt;/p&gt;

&lt;p&gt;关于闭包，stack overflow &lt;a href=&quot;http://stackoverflow.com/questions/4020419/closures-in-python&quot;&gt;http://stackoverflow.com/questions/4020419/closures-in-python&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2. wraps&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;给decorator加上wraps以保留原有函数的名称和docstring：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from functools import wraps
def my_decorator(f):
    @wraps(f)
    def wrapper(*args, **kwds):
        print &amp;#39;Calling decorated function&amp;#39;
        return f(*args, **kwds)
    return wrapper


@my_decorator
def example():
    &amp;quot;&amp;quot;&amp;quot;Docstring&amp;quot;&amp;quot;&amp;quot;
    print &amp;#39;Called example function&amp;#39;

example()  # print &amp;#39;Calling decorated function&amp;#39; &amp;#39;Called example function&amp;#39;
example.__name__  # print &amp;#39;example&amp;#39;
example.__doc__  # print &amp;#39;Docstring&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Without the use of this decorator factory, the name of the example function would have been &amp;#39;wrapper&amp;#39;, and the docstring of the original example() would have been lost.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3. class decorator&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;给类的所有函数添加decorator：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def logged(time_format, name_prefix=&amp;quot;&amp;quot;):
    def decorator(func):
        if hasattr(func, &amp;#39;_logged_decorator&amp;#39;) and func._logged_decorator:
            return func

        @wraps(func)
        def decorated_func(*args, **kwargs):
            start_time = time.time()
            print &amp;quot;- Running &amp;#39;%s&amp;#39; on %s &amp;quot; % (
                                            name_prefix + func.__name__,
                                            time.strftime(time_format)
                                )
            result = func(*args, **kwargs)
            end_time = time.time()
            print &amp;quot;- Finished &amp;#39;%s&amp;#39;, execution time = %0.3fs &amp;quot; % (
                                            name_prefix + func.__name__,
                                            end_time - start_time
                                )

            return result
        decorated_func._logged_decorator = True
        return decorated_func
    return decorator

def log_method_calls(time_format):
    def decorator(cls):
        for attr in dir(cls):
            if attr.startswith(&amp;#39;__’): #过滤掉以双下划线开头的attributes
                continue
            a = getattr(cls, attr)
            if hasattr(a, &amp;#39;__call__’): #如果包含__call__属性，说明是函数
                decorated_a = logged(time_format, cls.__name__ + &amp;quot;.&amp;quot;)(a)
                setattr(cls, attr, decorated_a)
        return cls
    return decorator

@log_method_calls(&amp;quot;%b %d %Y - %H:%M:%S&amp;quot;)
class A(object):
    def test1(self):
        print &amp;quot;test1&amp;quot;

@log_method_calls(&amp;quot;%b %d %Y - %H:%M:%S&amp;quot;)
class B(A):
    def test1(self):
        super(B, self).test1()
        print &amp;quot;child test1&amp;quot;

    def test2(self):
        print &amp;quot;test2&amp;quot;

b = B()
b.test1()
b.test2()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;- Running &amp;#39;B.test1&amp;#39; on Jul 24 2013 - 14:15:03
- Running &amp;#39;A.test1&amp;#39; on Jul 24 2013 - 14:15:03
test1
- Finished &amp;#39;A.test1&amp;#39;, execution time = 0.000s
child test1
- Finished &amp;#39;B.test1&amp;#39;, execution time = 1.001s
- Running &amp;#39;B.test2&amp;#39; on Jul 24 2013 - 14:15:04
test2
- Finished &amp;#39;B.test2&amp;#39;, execution time = 2.001s
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;4. descriptor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用法1：Type Checking&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;# Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&amp;#39;Expected &amp;#39; + str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]


# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Finally, it should be stressed that you would probably not write a descriptor if you simply want to customize the access of a single attribute of a specific class. Descriptors are more useful in situations where there will be a lot of code reuse (i.e., you want to use the functionality provided by the descriptor in hundreds of places in your code or provide it as a library feature).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用法2：Lazily Computed Properties&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class lazyproperty:
    def __init__(self, func):
        self.func = func
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;If a descriptor only defines a &lt;strong&gt;get&lt;/strong&gt;() method, it has a much weaker binding than usual. In particular, the &lt;strong&gt;get&lt;/strong&gt;() method only fires if the attribute being accessed is not in the underlying instance dictionary.&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Jul 2016 18:56:31 +0800</pubDate>
        <link>http://masutangu.com/2016/07/python-note-1/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/python-note-1/</guid>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>Matplotlib 笔记</title>
        <description>&lt;p&gt;最近工作需要在邮件内容中展示一些图表，例如折线图、柱状图、圆饼图等。采用的方案为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用&lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;生成图表并保存成文件&lt;/li&gt;
&lt;li&gt;将图片添加为邮件的附件&lt;/li&gt;
&lt;li&gt;最后通过&lt;code&gt;src=&amp;quot;cid:0&amp;quot;&lt;/code&gt;的方式将图片嵌入到邮件正文中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇文章主要对 Matplotlib 的使用做些总结，包括 Matplotlib 如何配置显示中文字体，折线图／柱状图／圆饼图相关介绍，matplot子图的概念。&lt;/p&gt;

&lt;h1&gt;配置中文字体支持&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;确定系统已有哪些支持中文字体&lt;/p&gt;

&lt;p&gt;linux下运行 &lt;code&gt;fc-list :lang=zh&lt;/code&gt; 命令会输出所有支持中文的字体。
如果为空，可以按如下步骤添加：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  拷贝一份window &lt;code&gt;C:\windows\fonts\&lt;/code&gt; 目录下的任一中文字体文件，例如 &lt;code&gt;MSYH.ttc&lt;/code&gt; （微软雅黑）&lt;/li&gt;
&lt;li&gt;  重命名为MSYH.ttf，并放到linux的 &lt;code&gt;/usr/share/fonts/chinese/&lt;/code&gt;目录下 &lt;/li&gt;
&lt;li&gt;  linux下执行 &lt;code&gt;fc-cache /usr/share/fonts/chinese&lt;/code&gt; 清空字体缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改matplotlibrc配置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  打开python安装目录下的 &lt;code&gt;lib/site-packages/matplotlib/mpl-data/matplotlibrc&lt;/code&gt; 文件，将 &lt;code&gt;font.family&lt;/code&gt; 和 &lt;code&gt;font.sans-serif&lt;/code&gt; 这两行开头的注释删掉，并在 &lt;code&gt;font.sans-serif&lt;/code&gt; 这行添加 &lt;code&gt;Microsoft YaHei&lt;/code&gt; (或系统支持的其他中文字体）&lt;/li&gt;
&lt;li&gt;  删除 &lt;code&gt;~/.cache/matplotlib&lt;/code&gt; 缓存目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改python代码，指定使用中文字体&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    from matplotlib import rcParams
    rcParams[&amp;#39;font.sans-serif&amp;#39;] = [&amp;#39;Microsoft YaHei&amp;#39;]  
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;曲线图／柱状图／圆饼图介绍&lt;/h1&gt;

&lt;h2&gt;柱状图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Demo&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://matplotlib.org/examples/api/barchart_demo.html&quot;&gt;官方 Demo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;API 封装&lt;/p&gt;

&lt;p&gt;下面是我对柱状图的一个封装，方便使用者直接调用：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def save_bar_fig(data, legends, x_labels, y_label, title, filename):
    &amp;quot;&amp;quot;&amp;quot;
        data: 柱状图输入数据，对应demo为：[(20, 35, 30, 35, 27), (25, 32, 34, 20, 25)]
        legends: 图例，显示在柱状图的右上角，标记柱状图的数据信息，对应demo为：[&amp;#39;Men&amp;#39;, &amp;#39;Women&amp;#39;]
        x_labels: x坐标的标签，对应demo为：[&amp;#39;G1&amp;#39;, &amp;#39;G2&amp;#39;, &amp;#39;G3&amp;#39;, &amp;#39;G4&amp;#39;, &amp;#39;G5&amp;#39;]
        y_label: y坐标标签，对应demo为：&amp;#39;Scores&amp;#39;
        title: 图表名称，对应demo为：&amp;#39;Scores by group and gender&amp;#39;
        filename: 保存的图片文件名
    &amp;quot;&amp;quot;&amp;quot;
    width = 1.0  # 柱状图每个bar的展示宽度，为了方便这里hard code
    num_of_labels = len(x_labels)
    num_of_legends = len(legends)
    ind = np.arange(0, num_of_labels * width * (num_of_legends + 1), width * (num_of_legends + 1))  # the x locations for the groups

    # 彩虹配色，以此实现每个bar显示不同的颜色
    colors = plt.cm.rainbow(np.linspace(0.9, 0, num_of_labels))

    # figsize：图片的大小，越大图片展示越清晰
    fig, ax = plt.subplots(figsize=(12, 8))
    rects = []
    pos = 0

    for r, color in zip(data, colors):
        rect = ax.bar(ind + pos, r, width, color=color)
        pos += width
        rects.append(rect)

    # add some text for labels, title and axes ticks
    ax.set_ylabel(y_label)
    ax.set_title(title)

    # set_xticks：设置x坐标标签的位置
    ax.set_xticks(ind + (num_of_legends * width)/2)
    ax.set_xticklabels(x_labels)

    # 设置legend
    ax.legend(rects, legends)

    plt.savefig(filename)

    # 注意每画完一个图，要清空plt的状态
    plt.clf()
    plt.cla()
    plt.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;折线图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Demo&lt;/p&gt;

&lt;p&gt;没找到合适的官方 Demo。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;API 封装&lt;/p&gt;

&lt;p&gt;折线图的 api 和上面的柱状图差不多：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def save_line_fig(data, legends, x_labels, y_label, title, filename):
    &amp;quot;&amp;quot;&amp;quot;
        data: 折线图输入数据，例如：[(20, 35, 30, 35, 27), (25, 32, 34, 20, 25)]
        legends: 图例，显示在折线图的右上角，标记折线图的数据信息，对应demo为：[&amp;#39;Men&amp;#39;, &amp;#39;Women&amp;#39;]
        x_labels: x坐标的标签，例如：[&amp;#39;G1&amp;#39;, &amp;#39;G2&amp;#39;, &amp;#39;G3&amp;#39;, &amp;#39;G4&amp;#39;, &amp;#39;G5&amp;#39;]
        y_label: y坐标标签，例如：&amp;#39;Scores&amp;#39;
        title: 图表名称，例如：&amp;#39;Scores by group and gender&amp;#39;
        filename: 保存的图片文件名
    &amp;quot;&amp;quot;&amp;quot;
    plt.figure(figsize=(12, 8))
    data_len = len(data[0]) + 1
    xAxis = range(1, data_len)  # Make x, y arrays for each graph
    colors = plt.cm.rainbow(np.linspace(0.9, 0, len(legends)))
    lines = []

    for l, color in zip(data, colors):
        line, = pl.plot(xAxis, l, c=color)
        lines.append(line)

    pl.legend(lines, legends)
    pl.title(title)
    pl.ylabel(y_label)
    pl.xticks(xAxis, x_labels)
    plt.savefig(filename)
    plt.clf()
    plt.cla()
    plt.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;饼状图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Demo&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://matplotlib.org/examples/pie_and_polar_charts/pie_demo_features.html&quot;&gt;官方 Demo&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;API 封装&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def save_pie_fig(data, labels, title, filename):
    &amp;quot;&amp;quot;&amp;quot;
        data: 饼状图输入数据，对应demo为：[15, 30, 45, 10]
        labels: 饼状图的图例，对于demo为：[&amp;#39;Frogs&amp;#39;, &amp;#39;Hogs&amp;#39;, &amp;#39;Dogs&amp;#39;, &amp;#39;Logs&amp;#39;]
        x_labels: x坐标的标签，例如：[&amp;#39;G1&amp;#39;, &amp;#39;G2&amp;#39;, &amp;#39;G3&amp;#39;, &amp;#39;G4&amp;#39;, &amp;#39;G5&amp;#39;]
        y_label: y坐标标签，例如：&amp;#39;Scores&amp;#39;
        title: 图表名称，例如：&amp;#39;Scores by group and gender&amp;#39;
        filename: 保存的图片文件名
    &amp;quot;&amp;quot;&amp;quot;
    # make a square figure and axes
    pl.figure(1, figsize=(12, 12))
    num_of_labels = len(labels)
    # 是否需要突出，例如 demo 中的 Hogs 
    explode = [0 for _ in labels]
    colors = plt.cm.rainbow(np.linspace(0.9, 0, num_of_labels))

    pl.pie(data, explode=explode, labels=labels, colors=colors,
                    autopct=&amp;#39;%1.1f%%&amp;#39;, shadow=True, startangle=90)

    # x轴和y轴相等，绘制出来的饼状图是圆形
    plt.axis(&amp;#39;equal&amp;#39;)
    pl.title(title)
    plt.savefig(filename)
    plt.clf()
    plt.cla()
    plt.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;子图&lt;/h1&gt;

&lt;p&gt;matplot 支持绘制子图，相当于把一张图分隔成几个区块，每个区块是一个绘图区域。该特性通过 subplot 函数来实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Demo&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://matplotlib.org/examples/subplots_axes_and_figures/subplot_demo.html&quot;&gt;官方 Demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;subplot 函数的签名为 subplot(m, n, k)。参数 m 表示划分的行数，n表示划分的列数，k表示使用第k个子图（从左到右、从上到下的顺序）。&lt;/p&gt;

&lt;p&gt;demo 中第一次调用 &lt;code&gt;plt.subplot(2, 1, 1)&lt;/code&gt;，表示划分成两行（m = 2），使用第1个子图来绘制（k = 1）。之后再次调用&lt;code&gt;plt.subplot(2, 1, 2)&lt;/code&gt;，表示划分成两行（m = 2），使用第2个子图来绘制（k = 2）。因此最终效果是上下两个子图。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他效果&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一下二:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.subplot(2, 1, 1)  # 按照两行一列划分，使用第一个子图，即为第一行
plt.subplot(2, 2, 3)  # 按照两行两列划分，使用第三个子图，即为四个网格的第三个（左下）
plt.subplot(2, 2, 4)  # 按照两行两列划分，使用第四个子图，即为四个网格的第四个（右下）
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图例&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/matplot-note/illustration-1.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上二下一:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;plt.subplot(2, 2, 1)  # 按照两行两列划分，使用第一个子图，即为四个网格的第一个（左上）
plt.subplot(2, 2, 2)  # 按照两行两列划分，使用第三个子图，即为四个网格的第二个（右上）
plt.subplot(2, 1, 2)  # 按照两行一列划分，使用第二个子图，即为第二行
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图例&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/matplot-note/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 04 Jul 2016 08:06:35 +0800</pubDate>
        <link>http://masutangu.com/2016/07/matplot-note/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/07/matplot-note/</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>Tcpcopy源码阅读</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/session-replay-tools/tcpcopy&quot;&gt;tcpcopy&lt;/a&gt;是网易开源的一款压测工具，可以实时复制线上流量到测试环境，从而利用线上真实的用户流量来对测试环境进行仿真压测。
由于网上关于tcpcopy的介绍并不多，我对tcpcopy的原理也很感兴趣。因此在学习其源码后写下这篇文章和大家分享。这里非常感谢tcpcopy的作者王斌老师的热心指导。&lt;/p&gt;

&lt;h1&gt;架构&lt;/h1&gt;

&lt;p&gt;第一种架构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现原理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从数据链路层捕获客户端的请求包，修改目的IP地址为压测机器，再从IP层发送出去。&lt;/li&gt;
&lt;li&gt;从数据链路层捕获压测机器的响应包，保持tcp会话的状态（seq number，ack number等），以此来欺骗压测机器的TCP协议栈。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图解： 
&lt;img src=&quot;/assets/images/read-tcpcopy-source-code/illustration-1.png&quot; width=&quot;800&quot; /&gt;
&lt;img src=&quot;/assets/images/read-tcpcopy-source-code/illustration-2.png&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;局限：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只支持同一网段：tcpcopy通过网卡的混杂模式来抓包，因此除非在路由设备上设置强制路由，否则响应包无法回到tcpcopy的机器。&lt;/li&gt;
&lt;li&gt;难以支持多台现网机器流量复制：把在线请求包导到压测机器进行压测的关键在于欺骗压测机器的TCP协议栈，因此我们需要在tcpcopy的进程捕获压测机器的响应包，保存相关字段来维持和压测机器之间会话的状态。如果有多个tcpcopy机器，那压测机器需要维护多个tcpcopy机器的请求包关系，才能把响应包回给响相应的tcpcopy机器，只有当tcpcopy机器能正常收到压测机器的响应包，才能维护正确的TCP会话状态。而目前的架构压测机器无法得知请求包来自哪个tcpcopy机器，自然也没办法将响应包回给正确的tcpcopy机器。
为什么不把请求包的源IP替换成tcpcopy机器的IP呢？这样压测机器就能把响应包准确回复给相应的tcpcopy的机器。但如果这样的话，由于tcpcopy机器并没有监听该端口，会发送reset包给压测机器，连接将被断开，压测也无法进行下去。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;流程&lt;/h1&gt;

&lt;p&gt;截获客户端请求包的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 如果是SYN/RST包，转发一份到压测机器。&lt;/li&gt;
&lt;li&gt; 如果是FIN包，判断下之前的数据包压测机器是否已经确认，如果都确认了，就转发FIN包给压测机器，如果还有没确认的，则先把FIN包保存下来。&lt;/li&gt;
&lt;li&gt; 如果是普通数据包，如果当前是SYN_SENT状态，则先保存到unsend列表里，否则转发到压测机器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;截获压测机器响应包的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 如果是reset包，设置reset_flag为true。&lt;/li&gt;
&lt;li&gt; 如果不是ack包，不需要处理。&lt;/li&gt;
&lt;li&gt; 保存响应包的ack_seq到virtual_ack字段。&lt;/li&gt;
&lt;li&gt; 如果是SYN包，更新virtual_next_sequence字段的值为响应包的seq number加1，更新virtual_status为SYN_CONFIRM，三次握手完成，将unsend的数据包（如果有）转发给压测机器。&lt;/li&gt;
&lt;li&gt; 如果是FIN包，更新virtual_status为SERVER FIN，更新virtual_next_sequence字段的值为响应包的seq number加1。如果有fin_ack_packge，则将该fin_ack_package发送给压测机器。&lt;/li&gt;
&lt;li&gt; 如果是数据包，根据头部的信息更新virtual_next_sequence。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;源码细节&lt;/h1&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C++&quot; data-lang=&quot;C++&quot;&gt;struct session_st {
    uint32_t virtual_next_sequence; //下个要发送的segment的ack sequence number
    uint32_t virtual_ack; //收到segment的ack sequence number
    uint16_t virtual_status; //当前状态：Client Fin, Server Fin, SYN_CONFIRM, SYN_SENT
    uint32_t client_next_sequence; //下个要发送的segment的sequence number
    uint16_t client_window; // 窗口大小
    uint16_t client_ip_id ;  //包的序列号
    unsigned char *fin_ack_package; //fin ack包
    bool     reset_flag; //是否重置
    dataContainer unsend; //segment缓存队列
｝


int main(int argc ,char **argv)
{
    ...
    //创建收发二层（链路层）报文的raw socket，链路层抓包
    int sock = socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));

    //创建收发三层（IP层）报文的raw socket，IP层转发包
    send_init();
    while(1)
    {
        //在链路层捕获到客户端请求包或压测机器的回包时，由process函数处理
        int recv_len = recvfrom(sock,recvbuf,2000,0,NULL,NULL);
        process(recvbuf,recv_len);
    }
    return 0;
}

void process(char *packet,int len)
{
    struct etharp_frame *ether = (struct etharp_frame *)packet;
    ...
    //判断以太网报文的类型是不是IP
    if(ntohs(ether-&amp;gt;type) != 0x800){
        return;
    }
    ip_header = (struct iphdr*)(packet+sizeof(struct etharp_frame ) );
    //判断是不是TCP
    if(ip_header-&amp;gt;protocol != IPPROTO_TCP)
    {
        return ;
    }

    size_ip = ip_header-&amp;gt;ihl*4; //获取ip头部的大小
    tcp_header = (struct tcphdr*)((char *)ip_header+size_ip); 
    size_tcp = tcp_header-&amp;gt;doff*4; //获取tcp头部的大小


    if( (ip_header-&amp;gt;saddr==remote_ip) &amp;amp;&amp;amp; (tcp_header-&amp;gt;source==remote_port) )
    {
        //如果是压测机器的回包，由update_virtual_status函数处理
        seIterator iter = sessions.find(get_ip_port_value(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest));
        if(iter != sessions.end())
        {
            iter-&amp;gt;second.update_virtual_status(ip_header,tcp_header);
            if( iter-&amp;gt;second.is_over())
            {
                sessions.erase(iter);
            }
        }
    }
    else if( (ip_header-&amp;gt;daddr==local_ip) &amp;amp;&amp;amp; (tcp_header-&amp;gt;dest==local_port))
    {
        //如果是客户端请求包，由process_recv函数处理
        if(tcp_header-&amp;gt;syn)
        {
            sessions[get_ip_port_value(ip_header-&amp;gt;saddr,tcp_header-&amp;gt;source)].process_recv(ip_header,tcp_header);
        }
        else
        {
            seIterator iter = sessions.find(get_ip_port_value(ip_header-&amp;gt;saddr,tcp_header-&amp;gt;source));
            if(iter != sessions.end())
            {
                iter-&amp;gt;second.process_recv(ip_header,tcp_header);
                if ((iter-&amp;gt;second.is_over()))
                {
                    sessions.erase(iter);
                }
            }
        }
    }
}

void session_st::update_virtual_status(struct iphdr *ip_header,struct tcphdr* tcp_header)
{
    if( !(tcp_header-&amp;gt;ack))
    {
        return; //不是ack不处理
    }
    //记录压测机器回包的ack seq number
    virtual_ack = tcp_header-&amp;gt;ack_seq;
    //处理syn包
    if( tcp_header-&amp;gt;syn)
    {
        //virtual_next_sequence加1
        virtual_next_sequence = plus_1(tcp_header-&amp;gt;seq);
        virtual_status |= SYN_CONFIRM;
        //如果缓存队列有未发送的包，则转发到压测机器
        while(! unsend.empty())
        {
            unsigned char *data = unsend.front();
            send_ip_package(data, virtual_next_sequence);
            free(data);
            unsend.pop_front();
        }
        return;
    }
    //处理fin包
    else if(tcp_header-&amp;gt;fin)
    {
        virtual_status  |= SERVER_FIN;
        //virtual_next_sequence加1
        virtual_next_sequence = plus_1(tcp_header-&amp;gt;seq);
        //如果有保存fin_ack_package，则发送出去。
        if(fin_ack_package)
        {
            send_ip_package(fin_ack_package,virtual_next_sequence);
        }
        return;
    }
    uint32_t tot_len = ntohs(ip_header-&amp;gt;tot_len);
    uint32_t next_seq = htonl(ntohl(tcp_header-&amp;gt;seq)+tot_len-ip_header-&amp;gt;ihl*4-tcp_header-&amp;gt;doff*4);

    if(ntohl(next_seq) &amp;lt; ntohl(virtual_next_sequence))
    {
        //如果next_seq小于virtual_next_sequence，意味着之前给压测机器的ack包丢了，重新发送ack包
        send_fake_ack(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest);
    }
    else if(ntohl(next_seq)==ntohl(virtual_next_sequence))
    {
        //has data
        if(tot_len != ip_header-&amp;gt;ihl*4+tcp_header-&amp;gt;doff*4)
        {
            //同上，ack包丢了，重发
            send_fake_ack(ip_header-&amp;gt;daddr,tcp_header-&amp;gt;dest);
        }
    }
    else
    {
        virtual_next_sequence = next_seq;
    }

    /* 如果收到客户端的fin包，但压测机器还有回包没有ack，就会把客户端的fin包保存在fin_ack_package。当virtual_ack等于client_next_sequence，意味着服务器已经确认了所有数据，如果fin_ack_package不为空，意味着客户端没有数据要发送了，因此将之前保存的fin包发送给压测机器。
    */
    if(virtual_ack == client_next_sequence)
    {
        if(fin_ack_package)
        {
            send_ip_package(fin_ack_package,virtual_next_sequence);
            virtual_status |= CLIENT_FIN;
            confirmed = true;
        }
    }
}

void session_st::process_recv(struct iphdr *ip_header,struct tcphdr *tcp_header)
{
    //syn包
    if(tcp_header-&amp;gt;syn)
    {
        send_ip_package((unsigned char *)ip_header,virtual_next_sequence);
        return;
    }
    //fin包
    if(tcp_header-&amp;gt;fin)
    {
        //virtual_ack等于tcp_header-&amp;gt;seq表示压测机器已经ack了所有请求数据
        if(virtual_ack == tcp_header-&amp;gt;seq)
        {
            send_ip_package((unsigned char *)ip_header,virtual_next_sequence);
            virtual_status |= CLIENT_FIN;
            return;
        }
        else
        { 
            //如果压测机器还有未确认的请求包，则先保存客户端的fin包
            fin_ack_package = copy_ip_package(ip_header);
        }
        return;
    }
    //更新client_next_sequence    
    save_header_info(ip_header,tcp_header);
    //如果三次握手还没完成，先将数据包压入缓存队列
    if(virtual_status == SYN_SEND)
    {
        unsend.push_back(copy_ip_package(ip_header));
    }
    else
    {
        //否则直接转发给压测机器
        send_ip_package((unsigned char *)ip_header,virtual_next_sequence); 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</description>
        <pubDate>Thu, 05 May 2016 10:00:25 +0800</pubDate>
        <link>http://masutangu.com/2016/05/read-tcpcopy-source-code/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/05/read-tcpcopy-source-code/</guid>
        
        
        <category>源码阅读</category>
        
      </item>
    
      <item>
        <title>iOS初体验</title>
        <description>&lt;p&gt;客户端对做后端的我来说，一直是黑盒子般。自从换了Mac，就寻思着什么时候学习学习iOS开发。这几个月断断续续花了时间，先是看了Stanford的cs193p课程，后来又读了&amp;lt;iOS Programming The Big Nerd Ranch Guide&amp;gt;,最后写了个非常简单的App：&lt;a href=&quot;https://github.com/Masutangu/ToDo&quot;&gt;ToDo&lt;/a&gt;。今天这里分享下iOS一些学习笔记，素材取自cs193p的ppt，apple的开发者文档。鉴于我现在iOS水平有限，写得比较浅，大家请见谅。&lt;/p&gt;

&lt;h1&gt;What’s in iOS?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-1.png&quot; alt=&quot;iOS架构图&quot; title=&quot;iOS架构图&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS处于底层硬件和app的中间。iOS的整体架构可以划分为四层：Core OS, Core Services, Media, Cocoa Touch&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Core OS: Contains the low-level features that most other technologies are built upon. Include：OSX Kernel, Mach 3.0, BSD, Sockets, Security, Power Management, Keychain Access, Certificates, File System, Bonjour&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core Services: Contains fundamental system services for apps. This layer also contains individual technologies to support features such as location, iCloud, social media, and networking. Include：Collections, Address Book, Networking, File Access, SQLite, Core Location, Net Services, Threading, Preferences, URL Utilities. 我理解是在Core OS基础上封装了一层接口。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Media: Contains the graphics, audio, and video technologies you use to implement multimedia experiences in your apps. Include：Core Audio，OpenAL, Audio Mixing, Audio Recording, Video Playback, OpenGL ES, Core Animation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cocoa Touch: Contains key frameworks for building iOS apps. These frameworks define the appearance of your app. They also provide the basic app infrastructure and support for key technologies such as multitasking, touch-based input, push notifications, and many high-level system services. Include: Multi-Touch, Core Motion, View Hierarchy, Localization, Controls, Alerts, Web View, Map Kit, Image Picker, Camera.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;MVC&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-2.png&quot; alt=&quot;MVC&quot; title=&quot;MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;: What your application is (but not how it is displayed)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;: How your Model is presented to the user (UI logic)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;:  Your Controller’s minions&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用程序的逻辑应该放在Model而不是Controller，因为&lt;strong&gt;Model = What your application is&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;MVC之间的关系&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-3.png&quot; alt=&quot;MVC关系&quot; title=&quot;MVC关系&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Controller可以直接访问Model和View（outlet）&lt;/li&gt;
&lt;li&gt;Model和View是完全隔离开的&lt;/li&gt;
&lt;li&gt;View通过protocol的方式（blind and structured）访问Controller，包括：&lt;strong&gt;target-action&lt;/strong&gt;方式，&lt;strong&gt;delegate&lt;/strong&gt;方式和&lt;strong&gt;data source&lt;/strong&gt;方式。&lt;/li&gt;
&lt;li&gt;Model通过&lt;strong&gt;notification&amp;amp;KVO（Key Value Observing）&lt;/strong&gt;将变化通知给Controller&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;多个MVC的组织&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ios-introduction/illustration-4.png&quot; alt=&quot;错误方式组织多个MVC&quot; title=&quot;错误方式组织多个MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;错误的做法：不同模块的communication非常杂乱，难以维护。&lt;/em&gt;
&lt;img src=&quot;/assets/images/ios-introduction/illustration-5.png&quot; alt=&quot;正确方式组织多个MVC&quot; title=&quot;正确方式组织多个MVC&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;正确的做法：Using MVC as part of the view of another MVC。划分好模块，不同模块间的communication非常少。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;Objective-C&lt;/h1&gt;

&lt;p&gt;面向对象编程的三个原则是：&lt;strong&gt;基于消息传递机制&lt;/strong&gt;，&lt;strong&gt;对象分离&lt;/strong&gt;和&lt;strong&gt;多态&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Category&lt;/strong&gt;
给已存在的类新增新的方法。
&lt;pre&gt;&lt;code&gt;
//NSObject+HelloWorld.h
@interface NSObject (HelloWorld)&lt;br&gt;
-(void)HelloWorld;&lt;br&gt;
@end&lt;br&gt;
//NSObject+HelloWorld.m
#import &amp;quot;NSObject+HelloWorld.h&amp;quot;&lt;br&gt;
@implementation NSObject (HelloWorld)&lt;br&gt;
-(void)HelloWorld{&lt;br&gt;
    NSLog(@&amp;quot;Hello World!&amp;quot;);&lt;br&gt;
}&lt;br&gt;
@end&lt;br&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Category vs Inheritance&lt;/strong&gt;:
Category用于给一个类新增一个功能，Inheritance用于修改父类的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Category vs Extension&lt;/strong&gt;:
Extension一般用来隐藏类的私有信息，需要有类的源码才能添加Extension。另外Extension可以添加成员变量，而Category不允许。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Introspection&lt;/strong&gt;: Asking at runtime what class an object is or what messages can be sent to it. 
&lt;pre&gt;&lt;code&gt;
&lt;strong&gt;isKindOfClass&lt;/strong&gt;: returns whether an object is that kind of class (inheritance included) 
&lt;strong&gt;isMemberOfClass&lt;/strong&gt;: returns whether an object is that kind of class (no inheritance) 
&lt;strong&gt;respondsToSelector&lt;/strong&gt;: returns whether an object responds to a given method
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Protocols&lt;/strong&gt;: A syntax that is “in between” id and static typing. Does not specify the class of an object pointed to, but does specify what methods it implements.
&lt;pre&gt;&lt;code&gt;
//definition file
@protocol Foo
-(void)someMethod;
-(void)methodWithArgument:(BOOL)argument;
@property (readonly) int readonlyProperty; // getter (only) is part of this protocol
@property NSString &lt;em&gt;readwriteProperty; // getter and setter are both in the protocol 
-(int)methodThatReturnsSomething;
@end
//example file
id &lt;Foo&gt; obj = [[MyClass alloc] init];
&lt;/code&gt;&lt;/pre&gt;
Protocols在iOS中的应用包括&lt;/em&gt;&lt;em&gt;delegates&lt;/em&gt;* 和 &lt;strong&gt;dataSources&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;设计模式&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Target-Action&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Cocoa uses the &lt;strong&gt;target-action&lt;/strong&gt; mechanism for communication between a &lt;strong&gt;control&lt;/strong&gt; and another object.  The receiving object—typically an instance of a custom class—is called the &lt;strong&gt;target&lt;/strong&gt;. The &lt;strong&gt;action&lt;/strong&gt; is the message that the control sends to the target.   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Delegation&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Delegation&lt;/strong&gt; is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. The delegating object keeps a reference to the other object—the delegate—and at the appropriate time sends a message to it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Date Source&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;A data source&lt;/strong&gt; is almost identical to a &lt;strong&gt;delegate&lt;/strong&gt;. The difference is in the relationship with the delegating object. Instead of being delegated control of the user interface, a data source is &lt;strong&gt;delegated control of data&lt;/strong&gt;. The delegating object, typically a view object such as a table view, holds a reference to its data source and occasionally asks it for the data it should display.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;KVO&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Key-value observing&lt;/strong&gt; is a mechanism that enables an object to be notified directly when a property of another object changes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;内存管理&lt;/h1&gt;

&lt;p&gt;iOS使用&lt;strong&gt;Automatic Reference Counting&lt;/strong&gt;来做内存管理。ARC在编译期会分析代码，确定对象的生命周期，在相应的位置自动加上retain和release。&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Apr 2016 23:10:00 +0800</pubDate>
        <link>http://masutangu.com/2016/04/ios-introduction/</link>
        <guid isPermaLink="true">http://masutangu.com/2016/04/ios-introduction/</guid>
        
        
        <category>iOS</category>
        
      </item>
    
  </channel>
</rss>
