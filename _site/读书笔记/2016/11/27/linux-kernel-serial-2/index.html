<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家  这里是 Masutangu 的个人博客。">
    <meta name="keywords"  content="Masutangu, Masutangu 的博客, Masutangu Blog, 博客, 个人网站, 互联网, 后端, Python, Go, C++">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Linux 内核系列－进程通信和同步 - Masutangu 的博客 | Masutangu Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。

">
    
    <meta property="article:published_time" content="2016-11-27T13:49:16Z">
    
    
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar.jpg">
    <meta property="og:url" content="http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/11/27/linux-kernel-serial-2/">
    <meta property="og:site_name" content="Masutangu 的博客 | Masutangu Blog">
    
    <title>Linux 内核系列－进程通信和同步 - Masutangu 的博客 | Masutangu Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/11/27/linux-kernel-serial-2/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Masutangu</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">关于</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">归档</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>Linux 内核系列－进程通信和同步</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by Masutangu on November 27, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。</p>

<h1 id="概念">概念</h1>

<h2 id="竞争条件">竞争条件</h2>
<p>多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时许，称为竞争条件。</p>

<h2 id="忙等待的互斥">忙等待的互斥</h2>
<p>几种实现互斥的方案：</p>

<ul>
  <li>
    <p>屏蔽中断</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，包括时钟中断。CPU 只有在发生中断的时候才会进行进程切换，这样在中断被屏蔽后 CPU 将不会被切换到其他进程。
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>锁变量</p>
  </li>
  <li>
    <p>严格轮换法</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>  <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
      <span class="n">critical_region</span><span class="p">();</span> 
      <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">noncritical_region</span><span class="p">();</span>
  <span class="p">}</span>


  <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> 
      <span class="n">critical_region</span><span class="p">();</span> 
      <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">noncritical_region</span><span class="p">();</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
    <p>忙等待检查变量。使用忙等待的锁称为自旋锁。</p>
  </li>
  <li>
    <p>Peterson 解法</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>  <span class="cp">#define FALSE 0 
</span>  <span class="cp">#define TRUE  1
</span>  <span class="cp">#define N 	  2 				   </span><span class="cm">/* number of processes */</span><span class="cp">
</span>	
  <span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>						   <span class="cm">/* whose turn is it? */</span>
  <span class="kt">int</span> <span class="n">interested</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>				   <span class="cm">/* all values initially 0 (FALSE) */</span>

  <span class="kt">void</span> <span class="n">enter_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">);</span>    <span class="cm">/* process is 0 or 1 */</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">other</span><span class="p">;</span>

      <span class="n">other</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">process</span><span class="p">;</span>
      <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
      <span class="n">turn</span> <span class="o">=</span> <span class="n">process</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">process</span> <span class="o">&amp;&amp;</span> <span class="n">interested</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">);</span> 
  <span class="p">}</span>


  <span class="kt">void</span> <span class="n">leave_region</span><span class="p">(</span><span class="kt">int</span> <span class="n">process</span><span class="p">)</span> 	   <span class="cm">/* process: who is leaving */</span> 
  <span class="p">{</span>
      <span class="n">interested</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>   <span class="cm">/* indicate departure from critical region */</span> 
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>TSL 指令</p>

    <p>TSL（测试并加锁）指令将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即在该指令结束前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以防止其他 CPU 在本指令结束前访问内存。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>  enter region:
      TSL REGISTER, LOCK 		| copy lock to register and set lock to 1
      CMP REGISTER, #0 		| was lock zero?
      JNE enter_region 		| if it was not zero, lock was set, so loop
      RET 					| return to caller; critical region entered

  leave region:
      MOVE LOCK, #0 			| store a 0 in lock
      RET 					| return to caller 	
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>一个可替代 TSL 的指令是 XCHG，它原子性的交换了两个位置的内容，例如寄存器和内存字。代码如下：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  enter region:
      MOVE REGISTER, #1  		| put a 1 in the register
      XCHG REGISTER, LOCK 	| swap the contents of the register and lock variable
      CMP REGISTER, #0 		| was lock zero?
      JNE enter_region 		| if it was non zero, lock was set, so loop
      RET 					| return to caller; critical region entered

  leave region:
      MOVE LOCK, #0 			| store a 0 in lock
      RET 					| return to caller
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>忙等待存在优先级反转的问题。假设存在 H 和 L 两个进程，L 优先级较低，调度规则规定只要 H 处于就绪状态就可以允许。在某一时刻，L 处于临界区中，此时 H 变到就绪态，然后开始忙等待。但由于 H 就绪时 L 不会被调度，也就无法离开临界区，所以 H 将永远忙等待下去。</p>

<h2 id="信号量">信号量</h2>
<p>信号量使用整型变量来累计唤醒次数。信号量的取值可以为 0 或者为正值。信号量有 up 和 down 这两种操作。</p>

<p>使用信号量解决生产者－消费者问题：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="cp">#define N 100 					</span><span class="cm">/* number of slots in the buffer */</span><span class="cp">
</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>  		<span class="cm">/* semaphores are a special kind of int */</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  			<span class="cm">/* controls access to critical region */</span>
<span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>  			<span class="cm">/* counts empty buffer slots */</span>
<span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 			<span class="cm">/* counts full buffer slots */</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span> 				<span class="cm">/* TRUE is the constant 1 */</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>      <span class="cm">/* generate something to put in buffer */</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>  				<span class="cm">/* decrement empty count */</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>				<span class="cm">/* enter critical region */</span>
    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>  		<span class="cm">/* put new item in buffer */</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 				<span class="cm">/* leavecriticalregion */</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> 					<span class="cm">/* increment count of full slots */</span>
  <span class="p">}</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>   				<span class="cm">/* infinite loop */</span>
	<span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span> 				<span class="cm">/* decrement full count */</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 				<span class="cm">/* enter critical region */</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span> 		<span class="cm">/* take item from buffer */</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>  				<span class="cm">/* leavecriticalregion */</span>
	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span> 				<span class="cm">/* increment count of empty slots */</span>
	<span class="n">consume</span> <span class="n">item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>			<span class="cm">/* do something with the item */</span>
  <span class="p">}</span> 
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>中断可以用信号量来实现，最自然的方法是为每个 I/O 设备设置一个信号量，初始值为 0。在启动 I/O 设备后，管理进程就立即对相关信号量执行一个 down 操作，于是进程被阻塞。当中断到来时，中断处理程序随后对相关信号量执行一个 up 操作，从而使进程变成就绪态。</p>

<p>信号量可以用以实现互斥，也可以用于事件同步。</p>

<h2 id="互斥量">互斥量</h2>
<p>互斥量是信号量的简化版本，称为互斥量。常用于用户线程包。互斥量只有两个状态：解锁和加锁。</p>

<p>TSL 或 XCHG 指令可以方便的在用户空间中实现互斥量：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>mutex_lock:
	TSL REGISTER, MUTEX 				| copy mutex to register and set mutex to 1
	CMP REGISTER, #0 					| was mutex zero?
	JZE ok 								| if it was zero, mutex was unlocked, so return
	CALL thread_yield					| mutex is busy; schedule another thread
	JMP mutex_lock						| try again	
ok: RET									| return to caller; critical region entered
										

mutex_unlock:
	MOVE MUTEX, #0 						| store a 0 in mutex
 	RET 								| return to caller
</pre></td></tr></tbody></table></code></pre></div></div>

<p>mutex_lock 和 enter_region 很类似，但有个关键的区别。当 enter_region 进入临界区失败时，进程始终在重复测试锁（忙等待），直到时钟超时，重新调度其他进程运行。</p>

<p>在用户线程中，由于没有时钟来停止运行过长的线程，因此需要调用 thread_yield 来让出 CPU。</p>

<p>Pthread 提供多种同步机制，包括互斥量和条件变量。<strong>条件变量总是结合互斥量一起使用。</strong>另外条件变量不会存在内存中，需要避免丢失信号。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#define MAX 1000000000  								</span><span class="cm">/* how many numbers to produce */</span><span class="cp">
</span><span class="n">pthread_mutex_t</span> <span class="n">the</span> <span class="n">mutex</span><span class="p">;</span> 
<span class="n">pthread_cond_t</span> <span class="n">condc</span><span class="p">,</span> <span class="n">condp</span><span class="p">;</span> 							<span class="cm">/* used for signaling */</span>
<span class="kt">int</span> <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/* buffer used between producer and consumer */</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>  							<span class="cm">/* produce data */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>					<span class="cm">/* get exclusive access to buffer */</span>			
		<span class="k">while</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
			<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>										<span class="cm">/* put item in buffer */</span>	
		<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">);</span>					<span class="cm">/* wakeupconsumer */</span>
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span> 				<span class="cm">/* release access to buffer */</span>
  	<span class="p">}</span>
	<span class="n">pthread</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> 							<span class="cm">/* consume data */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span> 				<span class="cm">/* get exclusive access to buffer */</span> 
		<span class="k">while</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span><span class="mi">0</span> <span class="p">)</span> 
			<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>		<span class="cm">/* wakeupproducer */</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">);</span>  
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span> 				<span class="cm">/* release access to buffer */</span>
	<span class="p">}</span>
	<span class="n">pthread</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">pro</span><span class="p">,</span> <span class="n">con</span><span class="p">;</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">consumer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pro</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
	<span class="n">pthread_join</span><span class="p">(</span><span class="n">pro</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pthread_join</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">);</span> 
	<span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">);</span> 
	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="系统调用及库函数">系统调用及库函数</h1>

<h2 id="线程同步">线程同步</h2>

<h3 id="互斥量-1">互斥量</h3>

<p>可以使用 pthread 的互斥接口来保护数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="读写锁">读写锁</h3>

<p>读写锁可以有三个状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span> <span class="o">*</span><span class="n">rwlock</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="条件变量">条件变量</h3>

<p>条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。<strong>条件本身是由互斥量保护的，线程在改变条件状态前必须先锁住互斥量</strong>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>
<span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">cond</span><span class="p">,</span>
					 <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">mutex</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>传递给 pthread_cond_wait 的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数自动把调用线程放到等待条件的线程列表上，再对互斥量解锁。这就<strong>关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，因此线程不会错过条件的任何变化</strong>。pthread_cond_wait 返回时，互斥量再次被锁住。</p>

<h3 id="自旋锁">自旋锁</h3>

<p>自旋锁与互斥量类似，但其不是通过休眠使进程阻塞，而是获得锁之前一直处于忙等待。自锁锁可以用于以下情况：锁被持有时间短，而且线程不希望在重新调度上花费太多成本。</p>

<p>自旋锁通常用于底层原语用于实现其它类型的锁。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">pthread_spin_lock</span><span class="p">(</span><span class="n">pthread_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_spin_trylock</span><span class="p">(</span><span class="n">pthread_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_spin_unlock</span><span class="p">(</span><span class="n">pthread_spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="屏障">屏障</h3>

<p>屏障是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一个点，然后从该点继续执行。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="n">pthread_barrier_init</span><span class="p">(</span><span class="n">pthread_barrier_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">barrier</span><span class="p">,</span>
						<span class="k">const</span> <span class="n">pthread_barrierattr_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">attr</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="n">pthread_barrier_t</span> <span class="o">*</span><span class="n">barrier</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="进程同步与通信">进程同步与通信</h2>

<h3 id="管道">管道</h3>

<p>管道是 UNIX 系统 IPC 的最古老方式。管道是半双工的，只能在具有公共祖先的两个进程之间使用。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="n">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>常量 PIPE_BUF 规定了内核的管道缓冲区大小，如果写管道的字节数小于等于 PIPE_BUF，则此操作不会与其它进程对同一管道的写操作交叉进行。</p>

<h3 id="fifo">FIFO</h3>

<p>通过 FIFO 不相关的进程也能交换数据。创建 FIFO 类似创建文件：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;sys/stat.h&gt;
</span>
<span class="kt">int</span> <span class="n">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="xsi-ipc">XSI IPC</h3>

<p>消息队列，信号量以及共享存储器称为 XSI IPC。</p>

<h4 id="标识符和键">标识符和键</h4>

<p>每个内核中的 IPC 结构都用一个非负整数的标识符加以引用。标识符是 IPC 对象的内部名，每个 IPC 对象都与一个键关联，将这个键作为该对象的外部名。</p>

<h4 id="权限结构">权限结构</h4>

<p>每个 IPC 结构关联了一个 ipc_perm 结构，该结构规定了权限和所有者，其至少包括了以下成员：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">ipc_perm</span> <span class="p">{</span>
	<span class="n">uid_t</span> 	<span class="n">uid</span><span class="p">;</span>   <span class="cm">/* owner's effective user id */</span>
	<span class="n">gid_t</span> 	<span class="n">gid</span><span class="p">;</span>   <span class="cm">/* owner's effective group id */</span>
	<span class="n">uid_t</span>   <span class="n">cuid</span><span class="p">;</span>  <span class="cm">/* creator's effective user id */</span>
	<span class="n">gid_t</span> 	<span class="n">cgid</span><span class="p">;</span>  <span class="cm">/* creator's effective group id */</span>
	<span class="n">mode_t</span>  <span class="n">mode</span><span class="p">;</span>  <span class="cm">/* access modes */</span>
	<span class="p">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="优缺点">优缺点</h4>

<p>XSI IPC 是在系统范围内起作用的，没有引用计数。例如，消息队列在引用进程终止后其内容不会被删除。与管道相比，当最后一个引用管道的进程终止时，管道就被完全的删除了。另一个问题是，XSI IPC 结构在文件系统中没有名字，无法使用文件系统的函数来访问或修改它们的属性，因此内核增加了十几个全新的系统调用（msgget、semop、shmat等）来支持这些 IPC 对象。</p>

<p>消息队列的优点是：可靠、流控制的。</p>

<h4 id="信号量记录锁和互斥量的比较">信号量、记录锁和互斥量的比较</h4>

<p>如果在多个进程间共享一个资源，则可使用信号量、记录锁或互斥量来协调访问。</p>

<p>若使用信号量，则先创建包含一个成员的信号量集合，分配资源调用 sem_op 为 -1 的 semop。释放资源调用 sem_op 为 +1 的 semop。对每个操作都指定 SEM_UNDO，以处理未释放资源条件下进程终止的情况。</p>

<p>若使用记录锁，则先创建一个空文件，并使用该文件的第一个字节（无需存在）为锁字节。记录锁的性质确保当锁的持有者终止时，内核会自动释放锁。</p>

<p>若使用互斥量，需要所有进程将相同文件映射到各自的地址空间，并使用 PTHREAD_PROCESS_SHARED 互斥量属性在文件的相同偏移处初始化互斥量。如果一个进程没有释放互斥量而终止，要恢复将是非常困难的。</p>

<p>下图显示在 Linux 上，使用这三种不同技术进行锁操作所需要的时间。在每一种情况下，资源都被分配、释放 1 000 000 次：</p>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>用户时间</th>
      <th>系统时间</th>
      <th>时钟</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>带undo的信号量</td>
      <td>0.50</td>
      <td>6.08</td>
      <td>7.55</td>
    </tr>
    <tr>
      <td>建议性记录锁</td>
      <td>0.51</td>
      <td>9.06</td>
      <td>4.38</td>
    </tr>
    <tr>
      <td>共享存储中的互斥量</td>
      <td>0.21</td>
      <td>0.40</td>
      <td>0.25</td>
    </tr>
  </tbody>
</table>

<p>如果我们仅需要对单一资源加锁，不需要 XSI 信号量的所有花哨功能，记录锁将比信号量更好，使用起来更简单、速度更快，当进程终止时系统会管理遗留下来的锁。除非特别考虑性能，否则不会使用共享存储中的互斥量。首先，在多个进程间共享内存中使用互斥量来恢复一个终止的进程更困难，其次，进程共享的互斥量属性还没得到普遍的支持。</p>

<h3 id="posix-信号量">POSIX 信号量</h3>

<p>POSIX 信号量接口意在解决 XSI 信号量接口的几个缺陷：</p>

<ul>
  <li>更高性能的实现</li>
  <li>接口使用更简单，没有信号量集</li>
  <li>删除时表现更完美</li>
</ul>

<p><strong>尽可能避免使用消息队列和信号量，应当考虑全双工管道和记录锁，它们使用起来更简单。</strong></p>

<h1 id="linux-中的实现">Linux 中的实现</h1>

<p>内核提供了一系列实现同步的方法，包括原子操作、自旋锁、信号量、序列锁等。</p>

<h2 id="自旋锁-1">自旋锁</h2>

<p>自旋锁可以在中断上下文中使用，而信号量不能，因为信号量可能会休眠。在中断处理中使用了锁的话，需要禁止本地中断，否则可能会因为重复申请锁而导致死锁。</p>

<p>内核提供了一个方便的方法以禁止中断并申请锁：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="cm">/* critical region ... */</span> 
<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mr_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>spin_lock_irqsave 保存当前的中断状态，禁止本地中断并获取自旋锁。</p>

<p>在单处理器系统，自旋锁的实现仅仅是禁止本地中断，并禁止抢占。</p>

<h2 id="完成变量completion-variables">完成变量（Completion Variables）</h2>

<p>Completion Variables 类似信号量，可以认为是信号量的简化版本。在内核中 Completion Variables 用于 vfork 系统调用：当子进程终止时通过 Completion Variables 通知父进程。</p>

<h2 id="顺序锁sequential-locks">顺序锁（Sequential Locks）</h2>

<p>顺序锁提供了一个简单的机制用以读写共享的数据，其基于一个顺序计数器。当数据被写入的时候，就会获得一把锁，并且序列值会增加。在读取数据之前和之后，读取序列值。如果序列值相同的话，那么在读数据的时候，并没有写操作发生。更进一步将，如果序列值是偶数的话，说明当前没有写操作正在进行（由于初始值为0，写操作获得和释放锁时均会让序列值加1）。</p>

<p>顺序锁非常轻量级，适用于以下场景：</p>

<ul>
  <li>数据拥有非常多的读取者。</li>
  <li>数据有很少的写入者。</li>
  <li>数据更倾向于写，并且不允许读造成写饥饿。</li>
  <li>数据非常的简单，但是因为某些原因，不能使用atomic变量。</li>
</ul>

<p>内核中存储 uptime 的变量 jiffies 的读写就使用了顺序锁。在某些不能原子读取 64 位 jiffies_64 变量的系统上，使用顺序锁来读取：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="n">u64</span> <span class="nf">get_jiffies_64</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span> 
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jiffies_64</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span> 
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>更新 jiffies_64 的代码如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">write_seqlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span> 
<span class="n">jiffies_64</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> 
<span class="n">write_sequnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtime_lock</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/11/27/linux-kernel-serial-1/" data-toggle="tooltip" data-placement="top" title="Linux 内核系列－进程">
                        Previous<br>
                        <span>Linux 内核系列－进程</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/12/01/linux-kernel-serial-3/" data-toggle="tooltip" data-placement="top" title="Linux 内核系列－进程调度">
                        Next<br>
                        <span>Linux 内核系列－进程调度</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://blog.zhiheng.io">onlyice</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/masutangu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://www.instagram.com/masutanguu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Masutangu 2018
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-77236140-1';
    var _gaDomain = 'masutangu.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
