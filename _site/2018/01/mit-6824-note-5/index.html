<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>MIT 6.824 学习笔记（五）</title>
  <meta name="description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="MIT 6.824 学习笔记（五）">
  <meta name="twitter:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="MIT 6.824 学习笔记（五）">
  <meta property="og:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2018/01/mit-6824-note-5/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://500px.me/community/user-details/5cc3fb7c1480fb4fc2140a09627457614" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-01-11 22:14:04 +0800" itemprop="datePublished" class="post-meta__date date">2018-01-11</time> &#8226; <span class="post-meta__tags tags">读书笔记</span>
    </div>
    <h1 class="post-title">MIT 6.824 学习笔记（五）</h1>
  </header>

  <section class="post">
    <p>本系列文章是对 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824</a> 课程的学习笔记。</p>

<h1>FaRM Note</h1>

<p>FaRM writes go to RAM, not disk -- eliminates a huge bottleneck. Can write RAM in 200 ns, but takes 10 ms to write hard drive, 100 us for SSD, but RAM loses content in power failure! Not persistent by itself.  </p>

<p>Just write to RAM of f+1 machines, to tolerate f failures? Might be enough if failures were always independent, but power failure is not independent -- may strike 100% of machines!</p>

<p>So batteries in every rack, can run machines for a few minutes: <strong>&quot;non-volatile RAM&quot;</strong>. What if crash prevents s/w from writing SSD, e.g bug in FaRM or kernel, or cpu/memory/hardware error. FaRM copes with single-machine crashes by copying data from RAM of machines&#39; replicas to other machines to ensure always f+1 copies. Crashes (other than power failure) must be independent!</p>

<p>why is the network often a performance bottleneck?</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">    the usual setup:
    app                       app
    ---                       ---
    socket buffers            buffers
    TCP                       TCP
    NIC driver                driver
    NIC  -------------------- NIC
</code></pre></figure>
<p>lots of expensive CPU operations:</p>

<ul>
<li>system calls</li>
<li>copy messages</li>
<li>interrupts</li>
</ul>

<p>and all twice if RPC! It&#39;s hard to build RPC than can deliver more than a few 100,000 / second wire b/w (e.g. 10 gigabits/second) is rarely the limit for short RPC. These per-packet CPU costs are the limiting factor for small messages.</p>

<p>Two classes of concurrency control for transactions:</p>

<ul>
<li><p>pessimistic:
wait for lock on first use of object; hold until commit/abort, called two-phase locking. Conflicts cause delays</p></li>
<li><p>optimistic:
access object without locking; commit &quot;validates&quot; to see if OK. </p>

<ul>
<li>Valid: do the writes</li>
<li>Invalid: abort
called <strong>Optimistic Concurrency Control (OCC)</strong></li>
</ul></li>
</ul>

<p>FaRM uses OCC. The reason: OCC lets FaRM read using one-sided RDMA reads, server storing the object does not need to set a lock, due to OCC.</p>

<p>FaRM transaction API (simplified):</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">  txCreate()
  o = txRead(oid)  -- RDMA
  o.f += 1
  txWrite(oid, o)  -- purely local
  ok = txCommit()  -- Figure 4
</code></pre></figure>
<p>What&#39;s in an oid: <region #, address>. <code>region #</code> indexes a mapping to [ primary, backup1, ... ]. Target NIC can use address directly to read or write RAM so target CPU doesn&#39;t have to be involved.</p>

<p>Server memory layout: regions, each an array of objects
Object layout: header with version # and lock</p>

<p>Every region replicated on one primary, f backups -- f+1 replicas. Only the primary serves reads; all f+1 see commits+writes replication yields availability if &lt;= f failures, i.e. available as long as one replica stays alive; better than Raft!</p>

<ul>
<li><p>txRead
one-sided RDMA to fetch object direct from primary&#39;s memory -- fast!
also fetches object&#39;s version number, to detect concurrent writes</p></li>
<li><p>txWrite
must be preceded by txRead
just writes local copy; no communication</p></li>
<li><p>transaction execution / commit protocol without failure -- Figure 4</p>

<ul>
<li><p>LOCK (first message in commit protocol)</p>

<p>TC sends to primary of each written object
TC uses RDMA to append to its log at each primary
LOCK record contains oid, version # xaction read, new value
primary s/w polls log, sees LOCK, validates, sends &quot;yes&quot; or &quot;no&quot; reply message
note LOCK is both logged in primary&#39;s NVRAM <em>and</em> an RPC exchange</p></li>
</ul></li>
<li><p>what does primary CPU do on receipt of LOCK?</p>

<p>(for each object)
if object locked, or version != what xaction read, reply &quot;no&quot;
otherwise set the lock flag and return &quot;yes&quot;
note: does <em>not</em> block if object is already locked</p></li>
<li><p>TC waits for all LOCK reply messages</p>

<p>if any &quot;no&quot;, abort
send ABORT to primaries so they can release locks
returns &quot;no&quot; from txCommit()</p></li>
<li><p>TC sends COMMIT-PRIMARY to primary of each written object</p>

<p>uses RDMA to append to primary&#39;s log
TC only waits for hardware ack -- does not wait for primary to process log entry
TC returns &quot;yes&quot; from txCommit()</p></li>
<li><p>what does primary do when it processes the COMMIT-PRIMARY in its log?</p>

<p>copy new value over object&#39;s memory
increment object&#39;s version #
clear object&#39;s lock flag</p></li>
</ul>

<h1>Paxos Made Simple</h1>

<h2>The Consensus Algorithm</h2>

<p>Assume a collection of processes that can propose values. </p>

<p>The safety
requirements for consensus are:
• Only a value that has been proposed may be chosen,
• Only a single value is chosen, and
• A process never learns that a value has been chosen unless it actually has been</p>

<p>We let the three roles in the consensus algorithm be performed by three classes of agents: proposers, acceptors, and learners.</p>

<p>A proposer sends a proposed value to a
set of acceptors. An acceptor may accept the proposed value. The value is
chosen when a large enough set of acceptors have accepted it. Because any two majorities
have at least one acceptor in common, this works if an acceptor can accept
at most one value. </p>

<p>In the absence of failure or message loss, we want a value to be chosen
even if only one value is proposed by a single proposer. This suggests the
requirement:
P1. An acceptor must accept the first proposal that it receives.</p>

<p>P1 and the requirement that a value is chosen only when it is accepted
by a majority of acceptors imply that an acceptor must be allowed to accept
more than one proposal. We keep track of the different proposals that an
acceptor may accept by assigning a (natural) number to each proposal, so a
proposal consists of a proposal number and a value. To prevent confusion,
we require that different proposals have different numbers.  A
value is chosen when a single proposal with that value has been accepted by
a majority of the acceptors. In that case, we say that the proposal (as well
as its value) has been chosen.</p>

<p>We can allow multiple proposals to be chosen, but we must guarantee
that all chosen proposals have the same value. By induction on the proposal
number, it suffices to guarantee:
P2. If a proposal with value v is chosen, then every higher-numbered proposal
that is chosen has value v.</p>

<p>To be chosen, a proposal must be accepted by at least one acceptor. So,
we can satisfy P2 by satisfying:
P2a
. If a proposal with value v is chosen, then every higher-numbered proposal
accepted by any acceptor has value v.</p>

<p>Because communication
is asynchronous, a proposal could be chosen with some particular
acceptor c never having received any proposal. Suppose a new proposer
“wakes up” and issues a higher-numbered proposal with a different value.
P1 requires c to accept this proposal, violating P2a
. Maintaining both P1
and P2a
requires strengthening P2a
to:
P2b
. If a proposal with value v is chosen, then every higher-numbered proposal
issued by any proposer has value v.</p>

<p>Since any set S consisting of a majority of acceptors contains at least one
member of C , we can conclude that a proposal numbered n has value v by
ensuring that the following invariant is maintained:
P2c
. For any v and n, if a proposal with value v and number n is issued,
then there is a set S consisting of a majority of acceptors such that
either (a) no acceptor in S has accepted any proposal numbered less
than n, or (b) v is the value of the highest-numbered proposal among
all proposals numbered less than n accepted by the acceptors in S.</p>

<p>We can therefore satisfy P2b by maintaining the invariance of P2c
.</p>

<p>To maintain the invariance of P2c
, a proposer that wants to issue a proposal
numbered n must learn the highest-numbered proposal with number
less than n, if any, that has been or will be accepted by each acceptor in
some majority of acceptors.</p>

<ol>
<li><p>A proposer chooses a new proposal number n and sends a request to
each member of some set of acceptors, asking it to respond with:
(a) A promise never again to accept a proposal numbered less than
n, and
(b) The proposal with the highest number less than n that it has
accepted, if any.
I will call such a request a prepare request with number n.</p></li>
<li><p>If the proposer receives the requested responses from a majority of
the acceptors, then it can issue a proposal with number n and value
v, where v is the value of the highest-numbered proposal among the
responses, or is any value selected by the proposer if the responders
reported no proposals.</p></li>
</ol>

<p>A proposer issues a proposal by sending, to some set of acceptors, a request
that the proposal be accepted. (This need not be the same set of acceptors
that responded to the initial requests.) Let’s call this an accept request</p>

<p>P1a
. An acceptor can accept a proposal numbered n iff it has not responded
to a prepare request having a number greater than n.</p>

<p>The final
algorithm is obtained by making one small optimization.
Suppose an acceptor receives a prepare request numbered n, but it has
already responded to a prepare request numbered greater than n, thereby
promising not to accept any new proposal numbered n. There is then no
reason for the acceptor to respond to the new prepare request, since it will
not accept the proposal numbered n that the proposer wants to issue. We also have it ignore
a prepare request for a proposal it has already accepted.</p>

<p>Phase 1. (a) A proposer selects a proposal number n and sends a prepare
request with number n to a majority of acceptors.
(b) If an acceptor receives a prepare request with number n greater
than that of any prepare request to which it has already responded,
then it responds to the request with a promise not to accept any more
proposals numbered less than n and with the highest-numbered proposal
(if any) that it has accepted.</p>

<p>Phase 2. (a) If the proposer receives a response to its prepare requests
(numbered n) from a majority of acceptors, then it sends an accept
request to each of those acceptors for a proposal numbered n with a
value v, where v is the value of the highest-numbered proposal among
the responses, or is any value if the responses reported no proposals.
(b) If an acceptor receives an accept request for a proposal numbered
n, it accepts the proposal unless it has already responded to a prepare
request having a number greater than n.</p>

<p>It’s easy to construct a scenario in which two proposers each keep issuing
a sequence of proposals with increasing numbers, none of which are ever
chosen. Proposer p completes phase 1 for a proposal number n1. Another
proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer
p’s phase 2 accept requests for a proposal numbered n1 are ignored because
the acceptors have all promised not to accept any new proposal numbered
less than n2.</p>

<p>To guarantee progress, a distinguished proposer must be selected as the
only one to try issuing proposals.</p>

<p>The Paxos algorithm [5] assumes a network of processes. In its consensus
algorithm, each process plays the role of proposer, acceptor, and learner.
The algorithm chooses a leader, which plays the roles of the distinguished proposer and the distinguished learner. </p>

<p>All that remains is to describe the mechanism for guaranteeing that no
two proposals are ever issued with the same number. Different proposers
choose their numbers from disjoint sets of numbers, so two different proposers
never issue a proposal with the same number. Each proposer remembers
(in stable storage) the highest-numbered proposal it has tried to issue,
and begins phase 1 with a higher proposal number than any it has already
used.</p>

<h1>Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing</h1>

<h2>RDD Abstraction</h2>

<p>Formally, an RDD is a read-only, partitioned collection
of records. RDDs can only be created through deterministic
operations on either (1) data in stable storage or (2)
other RDDs. We call these operations transformations to differentiate them from other operations on RDDs.</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/01/game-recover-based-on-replicated-state-machine/" title="link to 基于 Replicated State Machine 实现游戏进程恢复">基于 Replicated State Machine 实现游戏进程恢复</a></h2>
       <p class="excerpt">Introduction游戏服务器实现的业务逻辑普遍比较复杂，且大部分是带有状态的。如果进程重启或意外崩溃，会导致该服务器上的玩家断线，丢失进行中的游戏数据，带来极差的游戏体验。为了避免这种情况出现，一般游戏服务器都会持久化玩家数据以实现进程恢复，当重启或进程意外崩溃时，重新拉起进程后可以恢复到之前的状态。常用的做法是将玩家的状态信息保存在共享内存中，重启时加载共享内存进行恢复。共享内存虽然方便，但会有许多限制。比如 C++ 涉及到多态（虚函数表）、STL容器（heap分配），都不能直接映...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-01-13 11:30:24 +0800" class="post-list__meta--date date">2018-01-13</time> &#8226; <span class="post-list__meta--tags tags">工作</span><a class="btn-border-small" href=/2018/01/game-recover-based-on-replicated-state-machine/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/01/mit-6824-note-4/" title="link to MIT 6.824 学习笔记（四）">MIT 6.824 学习笔记（四）</a></h2>
       <p class="excerpt">本系列文章是对 MIT 6.824 课程的学习笔记。ZooKeeperAbstractZooKeeper 旨在提供简单高效的内核以供客户端实现更复杂的 coordination primitives。In addition to the wait-freeproperty, ZooKeeper provides a per client guarantee of FIFO execution of requests and linearizability for all requests ...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-01-10 19:53:45 +0800" class="post-list__meta--date date">2018-01-10</time> &#8226; <span class="post-list__meta--tags tags">读书笔记</span><a class="btn-border-small" href=/2018/01/mit-6824-note-4/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://masutangu.com/2018/01/mit-6824-note-5/";
        this.page.identifier = "/2018/01/mit-6824-note-5/";
    };

    var disqus_shortname = 'masutangu';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://masutangu.com/">@masutangu</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/Masutangu/Masutangu.github.io">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
