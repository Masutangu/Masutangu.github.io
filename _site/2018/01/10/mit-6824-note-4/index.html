<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家  这里是 Masutangu 的个人博客。">
    <meta name="keywords"  content="Masutangu, Masutangu 的博客, Masutangu Blog, 博客, 个人网站, 互联网, 后端, Python, Go, C++">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="MIT 6.824 学习笔记（四） - Masutangu 的博客 | Masutangu Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。

">
    
    <meta property="article:published_time" content="2018-01-10T19:53:45Z">
    
    
    
    <meta property="article:tag" content="读书笔记">
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar.jpg">
    <meta property="og:url" content="http://localhost:4000/2018/01/10/mit-6824-note-4/">
    <meta property="og:site_name" content="Masutangu 的博客 | Masutangu Blog">
    
    <title>MIT 6.824 学习笔记（四） - Masutangu 的博客 | Masutangu Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2018/01/10/mit-6824-note-4/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Masutangu</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">关于</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">归档</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" title="读书笔记">读书笔记</a>
                        
                    </div>
                    <h1>MIT 6.824 学习笔记（四）</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by Masutangu on January 10, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>本系列文章是对 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824</a> 课程的学习笔记。</p>

<h1 id="zookeeper">ZooKeeper</h1>

<h2 id="abstract">Abstract</h2>

<p>ZooKeeper 旨在提供简单高效的内核以供客户端实现更复杂的 coordination primitives。In addition to the wait-free
property, ZooKeeper provides a <strong>per client guarantee of FIFO execution of requests</strong> and <strong>linearizability for all requests that change the ZooKeeper state</strong>.</p>

<h2 id="introduction">Introduction</h2>

<p>为了保证状态更新操作（写请求）的 linearizability，ZooKeeper 实现了 <strong>Zab，一个基于 leader 的原子广播协议</strong>。In ZooKeeper, <strong>servers process read operations locally, and we do not use Zab to totally order them</strong>.</p>

<p>在客户端缓存数据是提高读性能的重要技术，<strong>ZooKeeper 提供了 watch 机制</strong>，不直接管理客户端缓存。</p>

<h2 id="service-overview">Service overview</h2>

<p>ZooKeeper 提供给客户端 znode 的抽象，znode 有下列两种类型：</p>

<ul>
  <li><strong>Regular</strong> : 由客户端显式创建和删除</li>
  <li><strong>Ephemeral</strong>: 由客户端创建，可以由客户端显式删除，当会话终止时系统也会自动删除</li>
</ul>

<p>ZooKeeper 实现了 watch 机制，当数据发生改变时通知客户端，而不必通过让客户端轮询服务器的方式。</p>

<p>客户端连接到 ZooKeeper 时会初始化一个 session。Session 有超时机制，当 ZooKeeper 在超时时间内没有收到来自客户端 session的任何信息时，会判定该客户端已经挂掉。</p>

<h2 id="zookeeper-guarantees">ZooKeeper guarantees</h2>

<p>ZooKeeper 具备以下两个基础保证：</p>

<ul>
  <li>
    <p><strong>Linearizable writes</strong>: all requests that update the state of ZooKeeper are serializable and respect precedence;</p>
  </li>
  <li>
    <p><strong>FIFO client order</strong>: all requests from a given client are executed in the order that they were sent by the client.</p>
  </li>
</ul>

<h2 id="examples-of-primitives">Examples of primitives</h2>

<h3 id="simple-locks-without-herd-effect">Simple Locks without Herd Effect</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>Lock
1 n = create(l + “/lock-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for watch event
6 goto 2

Unlock
1 delete(n)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>Write Lock
1 n = create(l + “/write-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 2

Read Lock
1 n = create(l + “/read-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if no write znodes lower than n in C, exit
4 p = write znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 3
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="zookeeper-implementation">ZooKeeper Implementation</h2>

<p><img src="/assets/images/mit-6824-note-4/illustration-1.png" width="800" /></p>

<p>收到请求时，由 request processor 处理。如果是写请求，则使用 zab 协议，最终提交到 ZooKeeper 数据库的修改将会被复制到该系统上所有的服务器。</p>

<p>复制数据库是一个内存数据库，<strong>在变更被应到到内存数据库之前，我们强制将更新记录刷到磁盘上以实现 recoverability</strong>。</p>

<p><strong>每个 ZooKeeper 服务器都接收处理来自客户端的请求。 读操作由每个服务器的本地数据库来处理，写请求则由 zab 协议处理。</strong></p>

<h3 id="request-processor">Request Processor</h3>

<p>与客户端发送的请求不同，<strong>事务是幂等的</strong>。When the leader receives a write request, it calculates what the state of the system will be when the write is applied and transforms it into a transaction that captures this new state. The future state must be calculated because there may be outstanding transactions that have not yet been applied to the database. （尽管 transaction 可能执行多次，但通过计算 state 的方式，且保证多次执行的 transaction 也按照原先的顺序，就能保证幂等性）</p>

<h3 id="atomic-broadcast">Atomic Broadcast</h3>

<p>所有更新 ZooKeeper 状态的请求都被转发到 leader。 Leader 执行请求并通过 Zab，一个原子广播协议广播该变更。Zab 采用majority quorums 来决定一个建议，因此 ZooKeeper 在 2F + 1 服务器的场景下最多可以容忍 F 台服务器故障。</p>

<p><strong>Because state changes depend on the application of previous state changes, Zab provides stronger order guarantees than regular atomic broadcast.</strong> More specifically, Zab guarantees that <strong>changes broadcast by a leader are delivered in the order they were sent</strong> and <strong>all changes from previous leaders are delivered to an established leader before it broadcasts its own changes</strong>.</p>

<h3 id="replicated-database">Replicated Database</h3>

<p>重放消息以恢复状态非常耗时，因此 ZooKeeper 定期进行快照，恢复时只需要重放快照后的消息。 为了不锁住状态，ZooKeeper 采用<strong>模糊快照</strong>的方式。对树进行深度优先扫描，原子读取每个 znode 的数据和元数据并写入磁盘。Since the resulting fuzzy snapshot may have applied some subset of the state changes delivered during the generation of the snapshot, the result may not correspond to the state of ZooKeeper at any point in time. However, since state changes are idempotent, we can apply them twice as long as we apply the state changes in order.</p>

<h3 id="client-server-interactions">Client-Server Interactions</h3>

<p>读请求由服务器本地处理。每个读请求都被一个 zxid 标记，表示服务器看到的最后一个事务。本地读取的方式提高了性能，但可能返回旧数据。客户端可以在读操作后调用 sync 来保证返回的是最新的值。In our implementation, we do not need to atomically broadcast sync as we use a leader-based algorithm, and we simply place the sync operation at the end of the queue of requests between the leader and the server executing the call to sync. In order for this to work, the follower must be sure that the leader is still the leader. If there are pending transactions that commit, then the server does not suspect the leader. If the pending queue is empty, the leader needs to issue a null transaction to commit and orders the sync after that transaction.</p>

<p>ZooKeeper 服务器以 FIFO 的顺序来处理客户端的请求。Response 包含了 zxid。Even heartbeat messages during intervals of no activity include the last zxid seen by the server that the client is connected to. If the client connects to a new server, that new server ensures that its view of the ZooKeeper data is at least as recent as the view of the client by checking the last zxid of the client against its last zxid. If the client has a more recent view than the server, the server does not reestablish the session with the client until the server has caught up.</p>

<h1 id="linearizability-versus-serializability">Linearizability versus Serializability</h1>

<p>注：摘自 <a href="http://www.bailis.org/blog/linearizability-versus-serializability/">Linearizability versus Serializability</a></p>

<h2 id="linearizability-single-operation-single-object-real-time-order">Linearizability: single-operation, single-object, real-time order</h2>

<p>Linearizability is a guarantee about single operations on single objects. It provides a real-time  guarantee on the behavior of a set of single operations.</p>

<p>In plain English, under linearizability, writes should appear to be instantaneous. Imprecisely, once a write completes, all later reads (where “later” is defined by wall-clock start time) should return the value of that write or the value of a later write. Once a read returns a particular value, all later reads should return that value or the value of a later write.</p>

<p>Linearizability for read and write operations is synonymous with the term “atomic consistency” and is the “C,” or “consistency,” in Gilbert and Lynch’s proof of the CAP Theorem. We say linearizability is composable (or “local”) because, if operations on each object in a system are linearizable, then all operations in the system are linearizable.</p>

<h2 id="serializability-multi-operation-multi-object-arbitrary-total-order">Serializability: multi-operation, multi-object, arbitrary total order</h2>

<p>Serializability is a guarantee about transactions, or groups of one or more operations over one or more objects. It guarantees that the execution of a set of transactions (usually containing read and write operations) over multiple items is equivalent to some serial execution (total ordering) of the transactions.</p>

<p>Serializability is the traditional “I,” or isolation, in ACID. If users’ transactions each preserve application correctness (“C,” or consistency, in ACID), a serializable execution also preserves correctness. Therefore, serializability is a mechanism for guaranteeing database correctness.</p>

<p>Serializability is not composable. Serializability does not imply any kind of deterministic order—it simply requires that some equivalent serial execution exists.</p>

<p>关于 Serializability 和 Linearizability，可以读读<a href="https://36kr.com/p/5037166.html">分布式系统一致性的发展历史</a></p>

<h1 id="transaction-management-in-the-r-distributed-database-management-system">Transaction Management in the R* Distributed Database Management System</h1>

<p>这篇论文的主题是关于分布式数据库系统的事务管理，着重描述了 R* 提交协议：Presumed Abort（PA）和 Presumed Commit（PC）。PA 和 PC 是著名的 two-phase（2P）提交协议的扩展。</p>

<h2 id="introduction-1">Introduction</h2>

<p>R* is an experimental, distributed database management system (DDBMS). In a distributed database
system, the actions of a transaction (an atomic unit of consistency and recovery) may occur at more than one site. <strong>A commit protocol is needed to guarantee the uniform commitment of distributed transaction executions.</strong></p>

<p>Some of the desirable characteristics in a commit protocol are</p>

<ul>
  <li><strong>guaranteed transaction atomicity always</strong></li>
  <li><strong>ability to “forget” outcome of commit processing after a short amount of time（不需要一直记录结果）</strong></li>
  <li><strong>minimal overhead in terms of log writes and message traffic</strong></li>
  <li><strong>optimized performance in the no-failure case</strong></li>
  <li><strong>exploitation of completely or partially read-only transactions</strong></li>
  <li><strong>maximizing the ability to perform unilateral aborts</strong></li>
</ul>

<p><strong>Multilevel hierarchical commit protocols are suggested to be more natural than the conventional two-level (one coordinator and a set of subordinates) protocols.</strong> With these goals in mind, we extended the conventional 2P commit protocol to support a tree of processes and defined the <strong>Presumed Abort (PA)</strong> and the <strong>Presumed Commit (PC)</strong> protocols to improve the performance of distributed transaction commit.</p>

<h2 id="the-two-phase-commit-protocol">The Two-Phase Commit Protocol</h2>

<p>在 2P 提交协议中，分布式事务执行模型包括了一个 coordinator 进程，它连接了客户端应用程序和其他称为 subordinates 的进程。Subordinates 进程彼此之间不交互，只和 coordinator 交互。每个事务分配一个全局唯一的名字。</p>

<h3 id="2p-under-normal-operation">2P Under Normal Operation</h3>

<p>当 coordinator 接收到来自用户的事务提交请求时，并行的发送 PREPARE 消息给 subordinates，此时进入提交协议的第一阶段。如果该事务可以提交，subordinate 先 force-write 一条 prepare log record，之后发送 YES VOTE 给 coordinator，再等待 coordinator 返回最后的决策（commit 还是 abort），之后 subordinate 进入 <strong>prepare</strong> 状态，无法单方面终止或提交事务。如果 subordinate 决定终止事务，先 force-write 一条 abort record，之后发送 NO VOTE 给 coordinator。因为 NO VOTE 表示否决，subordinate 不需要等待 coordinator，直接终止该事务，释放锁并“忘记”该事务（不需要记录任何信息了）。</p>

<p>当 coordinator 接收到所有 subordinates 的投票时，进入提交协议的第二阶段。如果所有投票都是 YES，则 coordinator 进入 <strong>committing</strong> 状态：首先 force-write 一条 commit record，发送 COMMIT 消息给所有 subordinates. 在 force-write 成功执行后，事务即可提交，且通知客户端事务已经成功提交。如果 coordinator 有收到 NO VOTE，则进入 <strong>aborting</strong> 状态：force-write 一条 abort record，发送 ABORT 消息给处于准备状态的或者没有回 PREPARE 消息的 subordinates。</p>

<p>如果 subordinate 收到 COMMIT 消息，则进入 <strong>committing</strong> 状态：先 force-write 一条 commit record，发送 ACK 消息给 coordinator，然后提交事务并且“忘记”该事务。如果收到的是 ABORT 消息，进入 <strong>aborting</strong> 状态：force-write 一条 abort record，发送 ACK 消息给 coordinator，然后终止事务并且“忘记”该事务。当 coordinator 收到所有 subordinates 的 ACK 消息（不包括 NO VOTE 的 subordinates），写一条 end record 然后“忘记”该事务。</p>

<p>The general principle on which the protocols described in this paper are based is that if a subordinate acknowledges the receipt of any particular message, then it should make sure (by forcing a log record with the information in that message before sending the ACK) that it will never ask the coordinator about that piece of information.</p>

<p>log 包含了如下内容：</p>

<ul>
  <li><strong>the type (prepare, end, etc.) of the record</strong></li>
  <li><strong>the identity of the process that writes the record</strong></li>
  <li><strong>the name of the transaction</strong></li>
  <li><strong>the identity of the coordinator</strong></li>
  <li><strong>the names of the exclusive locks held by the writer in the case of prepare records</strong></li>
  <li><strong>the identities of the subordinates in the case of the commit/abort records written by the coordinator</strong></li>
</ul>

<p>总结下，提交事务总共需要：</p>

<ul>
  <li>subordinate 写两条记录：prepare record 和 commit record，且发送两条消息：YES VOTE 和 ACK</li>
  <li>coordinator 发送两条消息：PREPARE 和 COMMIT，以及写两条记录：commit record（force-write）和 end record（非 force-write）</li>
</ul>

<h3 id="2p-and-failures">2P and Failures</h3>

<p>每个站点都存在一个 recovery 进程，处理来自其他站点的 recovery 进程的信息。当从 crash 中恢复时，recovery 进程读取 stable storage 的 log，并且在 virtual storage 中重建。在 virtual storage 的这部分信息有下列用途：</p>

<ul>
  <li>应答其他站点发来的事务查询请求，这些事务的 coordinators 是运行在该挂掉的站点上（answer queries from other sites about transactions that had their coordinators at this site）</li>
  <li>发送事务的查询信息给其他站点的 subordinates，这些事务的 coordinators 是运行在该挂掉的站点上（send unsolicited information to other sites that had subordinates for transactions that had their coordinators at this site）</li>
</ul>

<p>在 virtual storage 构建的好处在于可以快速回应其他站点的查询，而不需要从 stable storage 查询日志。</p>

<p>当 recovery 进程发现有事务处于 <strong>prepare</strong> 状态，则会定期向 coordinator 询问该事务应该如何处理（commit 还是 abort）。如果 recovery 进程发现有事务在执行过程中崩溃，没有留下任何日志，则直接回滚操作，写一条 abort record，然后“忘记”。</p>

<p>如果 recovery 进程发现事务处于 <strong>committing/aborting</strong> 状态，它将尝试定期发送 COMMIT/ABORT 给所有还没 ACK 过的 subordinates。一旦收到所有 ACK，则写一条 end record 并且“忘记”该事务。</p>

<p>如果 recovery 进程收到一条事务查询，但 virtual storage 中没有该事务的信息，则直接返回 ABORT。</p>

<h2 id="the-presumed-abort-protocol">The Presumed Abort Protocol</h2>

<p>上一节提到，在找不到关于事务的信息时，recovery 进程将返回 ABORT。这意味着当 coordinator 决定要 abort 事务时，可以直接“忘记”该事务，coordinator 和 subordinates 不再需要 force-write 一条 abort record，subordinates 也不需要 ACK 来自 coordinator 的 ABORT 消息。coordinator 也不在需要记录 end record 了。</p>

<p>只读事务的情况下，leaf 进程直接返回 READ VOTE，释放锁，且“忘记”该事务。 A nonroot, nonleaf sends a READ VOTE only if its own vote and those of its subordinates’ are also READ VOTES. Otherwise, as long as none of the latter is a NO VOTE, it sends a YES VOTE.（存在部分只读事务）</p>

<p>There will not be a second phase of the protocol if the root process is readonly and it gets only READ VOTES. In this case the root process, just like the other processes, writes no log records for the transaction.</p>

<p>总结下，完全只读事务，所有进程都不需要写任何 log record。每个 nonleaf 进程发送一条 PREPARE 消息，每个 nonroot 进程发送一条信息 READ VOTE 消息。</p>

<h2 id="zookeeper-note">ZooKeeper Note</h2>

<p>Zookeeper: <strong>a generic “master” service</strong></p>

<p>Design challenges:</p>

<ul>
  <li>What API?</li>
  <li>How to make master fault tolerant?</li>
  <li>How to get good performance?</li>
</ul>

<p>Challenges interact: good performance may influence API e.g., asynchronous interface to allow pipelining</p>

<p>Sessions: clients sign into zookeeper</p>

<ul>
  <li>
    <p>Session allows a client to fail-over to another zookeeper service
  Client know the term and index of last completed operationsend it on each request. <strong>Service performs operation only if caught up with what client has seen.</strong></p>
  </li>
  <li>
    <p>Sessions can timeout
  Client must refresh a session continuously send a heartbeat to the server (like a lease). <strong>Zookeeper considers client “dead” if doesn’t hear from a client.</strong> Client may keep doing its thing (e.g., network partition) but cannot perform other zookeeper ops in that session</p>
  </li>
</ul>

<p>Challenge: Duplicates client requests</p>

<ul>
  <li>
    <p>Scenario
  Primary receives client request, fails
  Client resends client request to new primary</p>
  </li>
  <li>
    <p>Lab 3: 
  <strong>Table to detect duplicates</strong>
  <strong>Limitation: one outstanding op per client</strong>（缓存回包，所以需要等上一个请求处理完，才能处理下一个请求，对比是否重复，重复的话返回已经缓存好的回包）
  Problem problem: cannot pipeline client requests</p>
  </li>
  <li>
    <p>Zookeeper:
  Some ops are idempotent period
  Some ops are easy to make idempotent: <strong>test-version-and-then-do-op</strong>
  Some ops <strong>the client is responsible for detecting dups</strong>
   Consider the lock example.
     Create a file name that includes its session ID
       “app/lock/request-sessionID-seqno”
       zookeeper informs client when switch to new primary
   client runs getChildren()
     if new requests is there, all set
     if not, re-issue create</p>
  </li>
</ul>

<p>Problem: read may return stale data if only master performs it</p>

<p>Zookeeper solution: don’t promise non-stale data (by default)</p>

<ul>
  <li>Reads are allowed to return stale data</li>
  <li>Reads can be executed by any replica</li>
  <li>Read throughput increases as number of servers increases</li>
  <li>Read returns the last zxid it has seen
   So that new primary can catch up to zxid before serving the read
   Avoids reading from past</li>
  <li>Only sync-read() guarantees data is not stale</li>
</ul>

<p>Sync optimization: <strong>avoid ZAB layer for sync-read</strong></p>

<p>Must ensure that read observes last committed txn. <strong>Leader puts sync in queue between it and replica.</strong> If ops ahead of in the queue commit, then leader must be leader, otherwise, issue null transaction.(<strong>In same spirit read optimization in Raft paper</strong>, see last par section 8 of raft paper)</p>

<h2 id="2p-note">2P Note</h2>

<p>What about concurrent transactions?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>x and y are bank balances
x and y start out as $10

T1 is doing a transfer of $1 from x to y
T1:
  add(x, 1)  -- server A
  add(y, -1) -- server B
T2:
  tmp1 = get(x)
  tmp2 = get(y)
  print tmp1, tmp2
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Problem: <strong>What if T2 runs between the two add() RPCs?</strong> Then T2 will print 11, 10 money will have been created!  T2 should print 10,10 or 9,11.</p>

<p><strong>The traditional correctness definition is “serializability”.</strong>  Results should be as if transactions ran one at a time in some order as if T1, then T2; or T2, then T1. The results for the two differ, either is OK.</p>

<p><strong>“Two-phase locking” is one way to implement serializability</strong>. Each database record has a lock. The lock is stored at the server that stores the record. Transaction must wait for and acquire a record’s lock before using it. Thus add() handler implicitly acquires lock when it uses record. x or y transaction holds its locks until <em>after</em> commit or abort.</p>

<p>What are locks really doing?</p>

<ul>
  <li>When transactions conflict, locks delay one to force serial execution.</li>
  <li>When transactions don’t conflict, locks allow fast parallel execution.</li>
</ul>

<p>Raft and two-phase commit solve different problems!</p>

<ul>
  <li>
    <p><strong>Use Raft to get high availability by replicating</strong>, i.e. to be able to operate when some servers are crashed. The servers all do the <em>same</em> thing</p>
  </li>
  <li>
    <p><strong>Use 2PC when each subordinate does something different</strong> and <strong>all of them must do their part</strong>. <strong>2PC does not help availability</strong> since all servers must be up to get anything done. <strong>Raft does not ensure that all servers do something</strong> since only a majority have to be alive.</p>
  </li>
</ul>

<p>What if you want <strong>high availability and distributed commit</strong>?</p>

<ul>
  <li>Each “server” should be a Raft-replicated service</li>
  <li>And the Transaction Coordinator(TC) should be Raft-replicated</li>
  <li>Run two-phase commit among the replicated services</li>
</ul>

<p>Then you can tolerate failures and still make progress.</p>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/12/31/2017-review/" data-toggle="tooltip" data-placement="top" title="再见，2017">
                        Previous<br>
                        <span>再见，2017</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/01/13/game-recover-based-on-replicated-state-machine/" data-toggle="tooltip" data-placement="top" title="基于 Replicated State Machine 实现游戏进程恢复">
                        Next<br>
                        <span>基于 Replicated State Machine 实现游戏进程恢复</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        </a>
        
        
                <a data-sort="0058" 
                    href="/archive/?tag=%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE"
                    title="个人项目"
                    rel="4">个人项目</a>
        
                <a data-sort="0040" 
                    href="/archive/?tag=%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"
                    title="读书笔记"
                    rel="22">读书笔记</a>
        
                <a data-sort="0047" 
                    href="/archive/?tag=%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"
                    title="源码阅读"
                    rel="15">源码阅读</a>
        
                <a data-sort="0055" 
                    href="/archive/?tag=%E5%B7%A5%E4%BD%9C"
                    title="工作"
                    rel="7">工作</a>
        
                <a data-sort="0059" 
                    href="/archive/?tag=%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"
                    title="编程语言"
                    rel="3">编程语言</a>
        
                <a data-sort="0059" 
                    href="/archive/?tag=%E9%9A%8F%E7%AC%94"
                    title="随笔"
                    rel="3">随笔</a>
        
                <a data-sort="0060" 
                    href="/archive/?tag=%E4%BC%98%E5%8C%96%26%E9%87%8D%E6%9E%84"
                    title="优化&重构"
                    rel="2">优化&重构</a>
        
                <a data-sort="0060" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E5%BA%93"
                    title="数据库"
                    rel="2">数据库
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://blog.zhiheng.io">onlyice</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/masutangu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://www.instagram.com/masutanguu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Masutangu 2018
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-77236140-1';
    var _gaDomain = 'masutangu.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
