<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>MIT 6.824 学习笔记（四）</title>
  <meta name="description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="MIT 6.824 学习笔记（四）">
  <meta name="twitter:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="MIT 6.824 学习笔记（四）">
  <meta property="og:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2018/01/mit-6824-note-4/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://500px.me/community/user-details/5cc3fb7c1480fb4fc2140a09627457614" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-01-10 19:53:45 +0800" itemprop="datePublished" class="post-meta__date date">2018-01-10</time> &#8226; <span class="post-meta__tags tags">读书笔记</span>
    </div>
    <h1 class="post-title">MIT 6.824 学习笔记（四）</h1>
  </header>

  <section class="post">
    <p>本系列文章是对 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824</a> 课程的学习笔记。</p>

<h1>ZooKeeper</h1>

<h2>Abstract</h2>

<p>ZooKeeper 旨在提供简单高效的内核以供客户端实现更复杂的 coordination primitives。In addition to the wait-free
property, ZooKeeper provides a <strong>per client guarantee of FIFO execution of requests</strong> and <strong>linearizability for all requests that change the ZooKeeper state</strong>.</p>

<h2>Introduction</h2>

<p>为了保证状态更新操作（写请求）的 linearizability，ZooKeeper 实现了 <strong>Zab，一个基于 leader 的原子广播协议</strong>。In ZooKeeper, <strong>servers process read operations locally, and we do not use Zab to totally order them</strong>.</p>

<p>在客户端缓存数据是提高读性能的重要技术，<strong>ZooKeeper 提供了 watch 机制</strong>，不直接管理客户端缓存。</p>

<h2>Service overview</h2>

<p>ZooKeeper 提供给客户端 znode 的抽象，znode 有下列两种类型：</p>

<ul>
<li><strong>Regular</strong> : 由客户端显式创建和删除</li>
<li><strong>Ephemeral</strong>: 由客户端创建，可以由客户端显式删除，当会话终止时系统也会自动删除</li>
</ul>

<p>ZooKeeper 实现了 watch 机制，当数据发生改变时通知客户端，而不必通过让客户端轮询服务器的方式。</p>

<p>客户端连接到 ZooKeeper 时会初始化一个 session。Session 有超时机制，当 ZooKeeper 在超时时间内没有收到来自客户端 session的任何信息时，会判定该客户端已经挂掉。</p>

<h2>ZooKeeper guarantees</h2>

<p>ZooKeeper 具备以下两个基础保证：</p>

<ul>
<li><p><strong>Linearizable writes</strong>: all requests that update the state of ZooKeeper are serializable and respect precedence;</p></li>
<li><p><strong>FIFO client order</strong>: all requests from a given client are executed in the order that they were sent by the client.</p></li>
</ul>

<h2>Examples of primitives</h2>

<h3>Simple Locks without Herd Effect</h3>
<figure class="highlight"><pre><code class="language-text" data-lang="text">Lock
1 n = create(l + “/lock-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for watch event
6 goto 2

Unlock
1 delete(n)
</code></pre></figure><figure class="highlight"><pre><code class="language-text" data-lang="text">Write Lock
1 n = create(l + “/write-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if n is lowest znode in C, exit
4 p = znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 2

Read Lock
1 n = create(l + “/read-”, EPHEMERAL|SEQUENTIAL)
2 C = getChildren(l, false)
3 if no write znodes lower than n in C, exit
4 p = write znode in C ordered just before n
5 if exists(p, true) wait for event
6 goto 3
</code></pre></figure>
<h2>ZooKeeper Implementation</h2>

<p><img src="/assets/images/mit-6824-note-4/illustration-1.png" width="800" /></p>

<p>收到请求时，由 request processor 处理。如果是写请求，则使用 zab 协议，最终提交到 ZooKeeper 数据库的修改将会被复制到该系统上所有的服务器。</p>

<p>复制数据库是一个内存数据库，<strong>在变更被应到到内存数据库之前，我们强制将更新记录刷到磁盘上以实现 recoverability</strong>。</p>

<p><strong>每个 ZooKeeper 服务器都接收处理来自客户端的请求。 读操作由每个服务器的本地数据库来处理，写请求则由 zab 协议处理。</strong></p>

<h3>Request Processor</h3>

<p>与客户端发送的请求不同，<strong>事务是幂等的</strong>。When the leader receives a write request, it calculates what the state of the system will be when the write is applied and transforms it into a transaction that captures this new state. The future state must be calculated because there may be outstanding transactions that have not yet been applied to the database. （尽管 transaction 可能执行多次，但通过计算 state 的方式，且保证多次执行的 transaction 也按照原先的顺序，就能保证幂等性）</p>

<h3>Atomic Broadcast</h3>

<p>所有更新 ZooKeeper 状态的请求都被转发到 leader。 Leader 执行请求并通过 Zab，一个原子广播协议广播该变更。Zab 采用majority quorums 来决定一个建议，因此 ZooKeeper 在 2F + 1 服务器的场景下最多可以容忍 F 台服务器故障。</p>

<p><strong>Because state changes depend on the application of previous state changes, Zab provides stronger order guarantees than regular atomic broadcast.</strong> More specifically, Zab guarantees that <strong>changes broadcast by a leader are delivered in the order they were sent</strong> and <strong>all changes from previous leaders are delivered to an established leader before it broadcasts its own changes</strong>.</p>

<h3>Replicated Database</h3>

<p>重放消息以恢复状态非常耗时，因此 ZooKeeper 定期进行快照，恢复时只需要重放快照后的消息。 为了不锁住状态，ZooKeeper 采用<strong>模糊快照</strong>的方式。对树进行深度优先扫描，原子读取每个 znode 的数据和元数据并写入磁盘。Since the resulting fuzzy snapshot may have applied some subset of the state changes delivered during the generation of the snapshot, the result may not correspond to the state of ZooKeeper at any point in time. However, since state changes are idempotent, we can apply them twice as long as we apply the state changes in order.</p>

<h3>Client-Server Interactions</h3>

<p>读请求由服务器本地处理。每个读请求都被一个 zxid 标记，表示服务器看到的最后一个事务。本地读取的方式提高了性能，但可能返回旧数据。客户端可以在读操作后调用 sync 来保证返回的是最新的值。In our implementation, we do not need to atomically broadcast sync as we use a leader-based algorithm, and we simply place the sync operation at the end of the queue of requests between the leader and the server executing the call to sync. In order for this to work, the follower must be sure that the leader is still the leader. If there are pending transactions that commit, then the server does not suspect the leader. If the pending queue is empty, the leader needs to issue a null transaction to commit and orders the sync after that transaction.</p>

<p>ZooKeeper 服务器以 FIFO 的顺序来处理客户端的请求。Response 包含了 zxid。Even heartbeat messages during intervals of no activity include the last zxid seen by the server that the client is connected to. If the client connects to a new server, that new server ensures that its view of the ZooKeeper data is at least as recent as the view of the client by checking the last zxid of the client against its last zxid. If the client has a more recent view than the server, the server does not reestablish the session with the client until the server has caught up.</p>

<h1>Linearizability versus Serializability</h1>

<p>注：摘自 <a href="http://www.bailis.org/blog/linearizability-versus-serializability/">Linearizability versus Serializability</a></p>

<h2>Linearizability: single-operation, single-object, real-time order</h2>

<p>Linearizability is a guarantee about single operations on single objects. It provides a real-time  guarantee on the behavior of a set of single operations.</p>

<p>In plain English, under linearizability, writes should appear to be instantaneous. Imprecisely, once a write completes, all later reads (where “later” is defined by wall-clock start time) should return the value of that write or the value of a later write. Once a read returns a particular value, all later reads should return that value or the value of a later write.</p>

<p>Linearizability for read and write operations is synonymous with the term “atomic consistency” and is the “C,” or “consistency,” in Gilbert and Lynch’s proof of the CAP Theorem. We say linearizability is composable (or “local”) because, if operations on each object in a system are linearizable, then all operations in the system are linearizable.</p>

<h2>Serializability: multi-operation, multi-object, arbitrary total order</h2>

<p>Serializability is a guarantee about transactions, or groups of one or more operations over one or more objects. It guarantees that the execution of a set of transactions (usually containing read and write operations) over multiple items is equivalent to some serial execution (total ordering) of the transactions.</p>

<p>Serializability is the traditional “I,” or isolation, in ACID. If users’ transactions each preserve application correctness (“C,” or consistency, in ACID), a serializable execution also preserves correctness. Therefore, serializability is a mechanism for guaranteeing database correctness.</p>

<p>Serializability is not composable. Serializability does not imply any kind of deterministic order—it simply requires that some equivalent serial execution exists.</p>

<p>关于 Serializability 和 Linearizability，可以读读<a href="https://36kr.com/p/5037166.html">分布式系统一致性的发展历史</a></p>

<h1>Transaction Management in the R* Distributed Database Management System</h1>

<p>这篇论文的主题是关于分布式数据库系统的事务管理，着重描述了 R* 提交协议：Presumed Abort（PA）和 Presumed Commit（PC）。PA 和 PC 是著名的 two-phase（2P）提交协议的扩展。</p>

<h2>Introduction</h2>

<p>R* is an experimental, distributed database management system (DDBMS). In a distributed database
system, the actions of a transaction (an atomic unit of consistency and recovery) may occur at more than one site. <strong>A commit protocol is needed to guarantee the uniform commitment of distributed transaction executions.</strong> </p>

<p>Some of the desirable characteristics in a commit protocol are</p>

<ul>
<li><strong>guaranteed transaction atomicity always</strong></li>
<li><strong>ability to “forget” outcome of commit processing after a short amount of time（不需要一直记录结果）</strong></li>
<li><strong>minimal overhead in terms of log writes and message traffic</strong></li>
<li><strong>optimized performance in the no-failure case</strong></li>
<li><strong>exploitation of completely or partially read-only transactions</strong></li>
<li><strong>maximizing the ability to perform unilateral aborts</strong></li>
</ul>

<p><strong>Multilevel hierarchical commit protocols are suggested to be more natural than the conventional two-level (one coordinator and a set of subordinates) protocols.</strong> With these goals in mind, we extended the conventional 2P commit protocol to support a tree of processes and defined the <strong>Presumed Abort (PA)</strong> and the <strong>Presumed Commit (PC)</strong> protocols to improve the performance of distributed transaction commit. </p>

<h2>The Two-Phase Commit Protocol</h2>

<p>在 2P 提交协议中，分布式事务执行模型包括了一个 coordinator 进程，它连接了客户端应用程序和其他称为 subordinates 的进程。Subordinates 进程彼此之间不交互，只和 coordinator 交互。每个事务分配一个全局唯一的名字。</p>

<h3>2P Under Normal Operation</h3>

<p>当 coordinator 接收到来自用户的事务提交请求时，并行的发送 PREPARE 消息给 subordinates，此时进入提交协议的第一阶段。如果该事务可以提交，subordinate 先 force-write 一条 prepare log record，之后发送 YES VOTE 给 coordinator，再等待 coordinator 返回最后的决策（commit 还是 abort），之后 subordinate 进入 <strong>prepare</strong> 状态，无法单方面终止或提交事务。如果 subordinate 决定终止事务，先 force-write 一条 abort record，之后发送 NO VOTE 给 coordinator。因为 NO VOTE 表示否决，subordinate 不需要等待 coordinator，直接终止该事务，释放锁并“忘记”该事务（不需要记录任何信息了）。</p>

<p>当 coordinator 接收到所有 subordinates 的投票时，进入提交协议的第二阶段。如果所有投票都是 YES，则 coordinator 进入 <strong>committing</strong> 状态：首先 force-write 一条 commit record，发送 COMMIT 消息给所有 subordinates. 在 force-write 成功执行后，事务即可提交，且通知客户端事务已经成功提交。如果 coordinator 有收到 NO VOTE，则进入 <strong>aborting</strong> 状态：force-write 一条 abort record，发送 ABORT 消息给处于准备状态的或者没有回 PREPARE 消息的 subordinates。</p>

<p>如果 subordinate 收到 COMMIT 消息，则进入 <strong>committing</strong> 状态：先 force-write 一条 commit record，发送 ACK 消息给 coordinator，然后提交事务并且“忘记”该事务。如果收到的是 ABORT 消息，进入 <strong>aborting</strong> 状态：force-write 一条 abort record，发送 ACK 消息给 coordinator，然后终止事务并且“忘记”该事务。当 coordinator 收到所有 subordinates 的 ACK 消息（不包括 NO VOTE 的 subordinates），写一条 end record 然后“忘记”该事务。</p>

<p>The general principle on which the protocols described in this paper are based is that if a subordinate acknowledges the receipt of any particular message, then it should make sure (by forcing a log record with the information in that message before sending the ACK) that it will never ask the coordinator about that piece of information. </p>

<p>log 包含了如下内容：</p>

<ul>
<li><strong>the type (prepare, end, etc.) of the record</strong></li>
<li><strong>the identity of the process that writes the record</strong></li>
<li><strong>the name of the transaction</strong></li>
<li><strong>the identity of the coordinator</strong></li>
<li><strong>the names of the exclusive locks held by the writer in the case of prepare records</strong></li>
<li><strong>the identities of the subordinates in the case of the commit/abort records written by the coordinator</strong></li>
</ul>

<p>总结下，提交事务总共需要：</p>

<ul>
<li>subordinate 写两条记录：prepare record 和 commit record，且发送两条消息：YES VOTE 和 ACK</li>
<li>coordinator 发送两条消息：PREPARE 和 COMMIT，以及写两条记录：commit record（force-write）和 end record（非 force-write） </li>
</ul>

<h3>2P and Failures</h3>

<p>每个站点都存在一个 recovery 进程，处理来自其他站点的 recovery 进程的信息。当从 crash 中恢复时，recovery 进程读取 stable storage 的 log，并且在 virtual storage 中重建。在 virtual storage 的这部分信息有下列用途：</p>

<ul>
<li>应答其他站点发来的事务查询请求，这些事务的 coordinators 是运行在该挂掉的站点上（answer queries from other sites about transactions that had their coordinators at this site）</li>
<li>发送事务的查询信息给其他站点的 subordinates，这些事务的 coordinators 是运行在该挂掉的站点上（send unsolicited information to other sites that had subordinates for transactions that had their coordinators at this site）</li>
</ul>

<p>在 virtual storage 构建的好处在于可以快速回应其他站点的查询，而不需要从 stable storage 查询日志。</p>

<p>当 recovery 进程发现有事务处于 <strong>prepare</strong> 状态，则会定期向 coordinator 询问该事务应该如何处理（commit 还是 abort）。如果 recovery 进程发现有事务在执行过程中崩溃，没有留下任何日志，则直接回滚操作，写一条 abort record，然后“忘记”。</p>

<p>如果 recovery 进程发现事务处于 <strong>committing/aborting</strong> 状态，它将尝试定期发送 COMMIT/ABORT 给所有还没 ACK 过的 subordinates。一旦收到所有 ACK，则写一条 end record 并且“忘记”该事务。</p>

<p>如果 recovery 进程收到一条事务查询，但 virtual storage 中没有该事务的信息，则直接返回 ABORT。</p>

<h2>The Presumed Abort Protocol</h2>

<p>上一节提到，在找不到关于事务的信息时，recovery 进程将返回 ABORT。这意味着当 coordinator 决定要 abort 事务时，可以直接“忘记”该事务，coordinator 和 subordinates 不再需要 force-write 一条 abort record，subordinates 也不需要 ACK 来自 coordinator 的 ABORT 消息。coordinator 也不在需要记录 end record 了。</p>

<p>只读事务的情况下，leaf 进程直接返回 READ VOTE，释放锁，且“忘记”该事务。 A nonroot, nonleaf sends a READ VOTE only if its own vote and those of its subordinates’ are also READ VOTES. Otherwise, as long as none of the latter is a NO VOTE, it sends a YES VOTE.（存在部分只读事务）</p>

<p>There will not be a second phase of the protocol if the root process is readonly and it gets only READ VOTES. In this case the root process, just like the other processes, writes no log records for the transaction. </p>

<p>总结下，完全只读事务，所有进程都不需要写任何 log record。每个 nonleaf 进程发送一条 PREPARE 消息，每个 nonroot 进程发送一条信息 READ VOTE 消息。</p>

<h2>ZooKeeper Note</h2>

<p>Zookeeper: <strong>a generic &quot;master&quot; service</strong></p>

<p>Design challenges:</p>

<ul>
<li>What API?</li>
<li>How to make master fault tolerant?</li>
<li>How to get good performance?</li>
</ul>

<p>Challenges interact: good performance may influence API e.g., asynchronous interface to allow pipelining</p>

<p>Sessions: clients sign into zookeeper</p>

<ul>
<li><p>Session allows a client to fail-over to another zookeeper service
Client know the term and index of last completed operationsend it on each request. <strong>Service performs operation only if caught up with what client has seen.</strong></p></li>
<li><p>Sessions can timeout
Client must refresh a session continuously send a heartbeat to the server (like a lease). <strong>Zookeeper considers client &quot;dead&quot; if doesn&#39;t hear from a client.</strong> Client may keep doing its thing (e.g., network partition) but cannot perform other zookeeper ops in that session</p></li>
</ul>

<p>Challenge: Duplicates client requests</p>

<ul>
<li><p>Scenario
Primary receives client request, fails
Client resends client request to new primary</p></li>
<li><p>Lab 3: 
<strong>Table to detect duplicates</strong>
<strong>Limitation: one outstanding op per client</strong>（缓存回包，所以需要等上一个请求处理完，才能处理下一个请求，对比是否重复，重复的话返回已经缓存好的回包）
Problem problem: cannot pipeline client requests</p></li>
<li><p>Zookeeper:
Some ops are idempotent period
Some ops are easy to make idempotent: <strong>test-version-and-then-do-op</strong>
Some ops <strong>the client is responsible for detecting dups</strong>
 Consider the lock example.
   Create a file name that includes its session ID
     &quot;app/lock/request-sessionID-seqno&quot;
     zookeeper informs client when switch to new primary
 client runs getChildren()
   if new requests is there, all set
   if not, re-issue create</p></li>
</ul>

<p>Problem: read may return stale data if only master performs it</p>

<p>Zookeeper solution: don&#39;t promise non-stale data (by default)</p>

<ul>
<li>Reads are allowed to return stale data</li>
<li>Reads can be executed by any replica</li>
<li>Read throughput increases as number of servers increases</li>
<li>Read returns the last zxid it has seen
 So that new primary can catch up to zxid before serving the read
 Avoids reading from past</li>
<li>Only sync-read() guarantees data is not stale</li>
</ul>

<p>Sync optimization: <strong>avoid ZAB layer for sync-read</strong></p>

<p>Must ensure that read observes last committed txn. <strong>Leader puts sync in queue between it and replica.</strong> If ops ahead of in the queue commit, then leader must be leader, otherwise, issue null transaction.(<strong>In same spirit read optimization in Raft paper</strong>, see last par section 8 of raft paper)</p>

<h2>2P Note</h2>

<p>What about concurrent transactions?</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">x and y are bank balances
x and y start out as $10

T1 is doing a transfer of $1 from x to y
T1:
  add(x, 1)  -- server A
  add(y, -1) -- server B
T2:
  tmp1 = get(x)
  tmp2 = get(y)
  print tmp1, tmp2
</code></pre></figure>
<p>Problem: <strong>What if T2 runs between the two add() RPCs?</strong> Then T2 will print 11, 10 money will have been created!  T2 should print 10,10 or 9,11.</p>

<p><strong>The traditional correctness definition is &quot;serializability&quot;.</strong>  Results should be as if transactions ran one at a time in some order as if T1, then T2; or T2, then T1. The results for the two differ, either is OK.</p>

<p><strong>&quot;Two-phase locking&quot; is one way to implement serializability</strong>. Each database record has a lock. The lock is stored at the server that stores the record. Transaction must wait for and acquire a record&#39;s lock before using it. Thus add() handler implicitly acquires lock when it uses record. x or y transaction holds its locks until <em>after</em> commit or abort.</p>

<p>What are locks really doing?</p>

<ul>
<li>When transactions conflict, locks delay one to force serial execution.</li>
<li>When transactions don&#39;t conflict, locks allow fast parallel execution.</li>
</ul>

<p>Raft and two-phase commit solve different problems!</p>

<ul>
<li><p><strong>Use Raft to get high availability by replicating</strong>, i.e. to be able to operate when some servers are crashed. The servers all do the <em>same</em> thing</p></li>
<li><p><strong>Use 2PC when each subordinate does something different</strong> and <strong>all of them must do their part</strong>. <strong>2PC does not help availability</strong> since all servers must be up to get anything done. <strong>Raft does not ensure that all servers do something</strong> since only a majority have to be alive.</p></li>
</ul>

<p>What if you want <strong>high availability and distributed commit</strong>?</p>

<ul>
<li>Each &quot;server&quot; should be a Raft-replicated service</li>
<li>And the Transaction Coordinator(TC) should be Raft-replicated</li>
<li>Run two-phase commit among the replicated services</li>
</ul>

<p>Then you can tolerate failures and still make progress.</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/01/game-recover-based-on-replicated-state-machine/" title="link to 基于 Replicated State Machine 实现游戏进程恢复">基于 Replicated State Machine 实现游戏进程恢复</a></h2>
       <p class="excerpt">Introduction游戏服务器实现的业务逻辑普遍比较复杂，且大部分是带有状态的。如果进程重启或意外崩溃，会导致该服务器上的玩家断线，丢失进行中的游戏数据，带来极差的游戏体验。为了避免这种情况出现，一般游戏服务器都会持久化玩家数据以实现进程恢复，当重启或进程意外崩溃时，重新拉起进程后可以恢复到之前的状态。常用的做法是将玩家的状态信息保存在共享内存中，重启时加载共享内存进行恢复。共享内存虽然方便，但会有许多限制。比如 C++ 涉及到多态（虚函数表）、STL容器（heap分配），都不能直接映...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-01-13 11:30:24 +0800" class="post-list__meta--date date">2018-01-13</time> &#8226; <span class="post-list__meta--tags tags">工作</span><a class="btn-border-small" href=/2018/01/game-recover-based-on-replicated-state-machine/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2017/12/2017-review/" title="link to 再见，2017">再见，2017</a></h2>
       <p class="excerpt">回看起去年的总结 我的2016，心里挺有感慨的。17 年是出现转机的一年，在这最后一天，按照惯例，整理下这一年的历程和想法。关于自己在去年的时候，我总觉得自己在工作上挺失意的，各种原因下达不到自己的期望。还好，今年在工作方面对自己还算满意。最大的进步是对工作的心态上，不再有一些困惑和纠结。工作上努力去争取有挑战的需求，空闲的时候则抽更多的时间在个人学习上，维持好工作和自学的平衡。我挺喜欢这样的节奏，忙的时候全心全意把工作做好，不忙的时候就把更多的时间投入到自己感兴趣的领域。在经历 16 年...&hellip;</p>
       <div class="post-list__meta"><time datetime="2017-12-31 16:28:17 +0800" class="post-list__meta--date date">2017-12-31</time> &#8226; <span class="post-list__meta--tags tags">随笔</span><a class="btn-border-small" href=/2017/12/2017-review/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://masutangu.com/">@masutangu</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/Masutangu/Masutangu.github.io">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
