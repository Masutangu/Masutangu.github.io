<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>etcd-raft 源码学习笔记（Linearizable Read 之 ReadIndx）</title>
  <meta name="description" content="这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 《Strong consistency models》）。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="etcd-raft 源码学习笔记（Linearizable Read 之 ReadIndx）">
  <meta name="twitter:description" content="这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 《Strong consistency models》）。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="etcd-raft 源码学习笔记（Linearizable Read 之 ReadIndx）">
  <meta property="og:description" content="这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 《Strong consistency models》）。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2018/07/etcd-raft-note-3/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://500px.me/community/user-details/5cc3fb7c1480fb4fc2140a09627457614" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-07-05 13:46:43 +0800" itemprop="datePublished" class="post-meta__date date">2018-07-05</time> &#8226; <span class="post-meta__tags tags">源码阅读</span>
    </div>
    <h1 class="post-title">etcd-raft 源码学习笔记（Linearizable Read 之 ReadIndx）</h1>
  </header>

  <section class="post">
    <p>这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 <a href="https://aphyr.com/posts/313-strong-consistency-models">《Strong consistency models》</a>）。</p>

<p>raft 论文第 8 节阐述了思路：</p>

<blockquote>
<p>Read-only operations can be handled without writing anything into the log. However, with no additional measures, this would run the risk of returning stale data, since the leader responding to the request might have been superseded by a newer leader of which it is unaware. Linearizable reads must not return stale data, and Raft needs two extra precautions to guarantee this without using the log. First, a leader must have the latest information on which entries are committed. The Leader Completeness Property guarantees that a leader has all committed entries, but at the start of its term, it may not know which those are. To find out, it needs to commit an entry from its term. Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term. Second, a leader must check whether it has been deposed before processing a read-only request (its information may be stale if a more recent leader has been elected). Raft handles this by having the leader exchange heartbeat messages with a majority of the cluster before responding to read-only requests.</p>
</blockquote>

<p>在收到读请求时，leader 节点保存下当前的 commit index，并往 peers 发送心跳。如果确定该节点依然是 leader，则只需要等到该 commit index 的 log entry 被 apply 到状态机时就可以返回客户端结果。</p>

<p>我们先通过位于 etcd/etcdserver 目录下的样例来看看应用层是如何使用 ReadIndex 来保证 linearizable read 的：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">// v3_server.go

type RaftKV interface {
    Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)
    Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)
    DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)
    Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)
    Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
}

func (s *EtcdServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
    var resp *pb.RangeResponse
    var err error

    if !r.Serializable {
        err = s.linearizableReadNotify(ctx)  // 等待 linearizableReadNotify 返回 才能继续往下走
        if err != nil {
            return nil, err
        }
    }
    // 读取数据逻辑 省略..
    ...
    return resp, err
}
</code></pre></figure>
<p>在读请求 <code>Range</code> 执行前，调用了 <code>linearizableReadNotify</code>：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">func (s *EtcdServer) linearizableReadNotify(ctx context.Context) error {
    s.readMu.RLock()
    nc := s.readNotifier
    s.readMu.RUnlock()

    // signal linearizable loop for current notify if it hasn&#39;t been already
    select {
    case s.readwaitc &lt;- struct{}{}:
    default:
    }

    // wait for read state notification
    select {
    case &lt;-nc.c:
        return nc.err
    case &lt;-ctx.Done():
        return ctx.Err()
    case &lt;-s.done:
        return ErrStopped
    }
}
</code></pre></figure>
<p><code>linearizableReadNotify</code> 往 <code>readwaitc</code> 发送个空的结构体，并且等待 <code>nc.c</code> 的返回。<code>readwaitc</code> 是在另外的 goroutine <code>linearizableReadLoop</code> 里监听的：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">
func (s *EtcdServer) linearizableReadLoop() {
    var rs raft.ReadState

    for {
        ctx := make([]byte, 8)
        binary.BigEndian.PutUint64(ctx, s.reqIDGen.Next())  // ctx 即请求唯一标识 reqId

        select {
        case &lt;-s.readwaitc:  // 监听 readwaitc
        case &lt;-s.stopping:
            return
        }

        nextnr := newNotifier()
        nr := s.readNotifier
        s.readNotifier = nextnr

        s.r.ReadIndex(cctx, ctx)  // 调用 ReadIndex 接口，往 recvc channel 发送 type 为 pb.MsgReadIndex 的请求

        var (
            timeout bool
            done    bool
        )
        for !timeout &amp;&amp; !done {
            select {
            case rs = &lt;-s.r.readStateC:  // 收到 ready 对象时，会往 readStateC channel 传回来 readState，见 etcd/etcdserver/raft.go 文件的 func (r *raftNode) start(rh *raftReadyHandler)
                done = bytes.Equal(rs.RequestCtx, ctx)  // 比较下 reqId 是否一致
            case &lt;-time.After(s.Cfg.ReqTimeout()):
                nr.notify(ErrTimeout)
                timeout = true
            case &lt;-s.stopping:
                return
            }
        }
        if !done {
            continue
        }

        // 等待 readState 里的 index，也就是收到 pb.MsgReadIndex 请求时，leader 节点当前的 commit index 被 apply 到状态机时，此时调用 nr.notify(nil) 通知应用层可以读取状态机里的数据了，确保读到的不是 stale 数据
        if ai := s.getAppliedIndex(); ai &lt; rs.Index {
            select {
            case &lt;-s.applyWait.Wait(rs.Index):
            case &lt;-s.stopping:
                return
            }
        }
        // unblock all l-reads requested at indices before rs.Index
        nr.notify(nil)
    }
}
</code></pre></figure>
<p>在 <code>linearizableReadLoop</code> 调用 <code>nr.notify</code> 后，<code>linearizableReadNotify</code> 从 select 阻塞中返回，此时就可以继续走 <code>Range</code> 的逻辑，读取数据，返回给客户端。</p>

<p>从上面的例子，我们了解了应用层如何使用 Node 的 <code>ReadIndex</code> 接口来实现 linearizable read。下面我们来介绍 <code>ReadIndex</code> 这个新接口：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">// Node represents a node in a raft cluster.
type Node interface {
    // Propose proposes that data be appended to the log.
    Propose(ctx context.Context, data []byte) error

    // Ready returns a channel that returns the current point-in-time state.
    // Users of the Node must call Advance after retrieving the state returned by Ready.
    //
    // NOTE: No committed entries from the next Ready may be applied until all committed entries
    // and snapshots from the previous one have finished.
    Ready() &lt;-chan Ready

    // Advance notifies the Node that the application has saved progress up to the last Ready.
    // It prepares the node to return the next available Ready.
    //
    // The application should generally call Advance after it applies the entries in last Ready.
    //
    // However, as an optimization, the application may call Advance while it is applying the
    // commands. For example. when the last Ready contains a snapshot, the application might take
    // a long time to apply the snapshot data. To continue receiving Ready without blocking raft
    // progress, it can call Advance before finishing applying the last ready.
    Advance()

    // ReadIndex request a read state. The read state will be set in the ready.
    // Read state has a read index. Once the application advances further than the read
    // index, any linearizable read requests issued before the read request can be
    // processed safely. The read state will have the same rctx attached.
    ReadIndex(ctx context.Context, rctx []byte) error
}

func (n *node) ReadIndex(ctx context.Context, rctx []byte) error {
    return n.step(ctx, pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry})
}
</code></pre></figure>
<p>上篇文章 <a href="http://masutangu.com/2018/07/etcd-raft-note-2/">《etcd-raft 源码学习笔记（概览篇）》</a> 提到当节点为 leader 时，<code>step</code> 被设置为 <code>stepLeader</code> 。我们来看看 <code>stepLeader</code> 是如何处理 type 为 pb.MsgReadIndex 的 readIndexReq 的：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgReadIndex:
        // raft 5.4 safty 检查
        if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
            // Reject read only request when this leader has not committed any log entry at its term.
            return nil
        }

        // thinking: use an interally defined context instead of the user given context.
        // We can express this in terms of the term and index instead of a user-supplied value.
        // This would allow multiple reads to piggyback on the same message.
        switch r.readOnly.option {
        case ReadOnlySafe:
            r.readOnly.addRequest(r.raftLog.committed, m)  // r.raftLog.committed 为 当前 commit index
            r.bcastHeartbeatWithCtx(m.Entries[0].Data)  // 广播心跳包
        }
        return nil
    }
    return nil
}


</code></pre></figure>
<p>收到 readIndexReq 后，首先调用 <code>r.readOnly.addRequest</code> 保存下，然后调用 <code>bcastHeartbeatWithCtx</code> 广播心跳包， ctx 即唯一标识 readIndexReq 的 reqId。</p>

<p>来看看 raft 是如何管理 readIndexReq 的：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">// addRequest adds a read only reuqest into readonly struct.
// `index` is the commit index of the raft state machine when it received
// the read only request.
// `m` is the original read only request message from the local or remote node.
func (ro *readOnly) addRequest(index uint64, m pb.Message) {
    ctx := string(m.Entries[0].Data)  // ctx 即 reqId
    if _, ok := ro.pendingReadIndex[ctx]; ok {
        return
    }
    ro.pendingReadIndex[ctx] = &amp;readIndexStatus{index: index, req: m, acks: make(map[uint64]struct{})}  // acks 用于记录哪些 peer 已经 ack 确认。之后用于统计是否大于 quonum
    ro.readIndexQueue = append(ro.readIndexQueue, ctx)  // append 进 readIndexQueue
}
</code></pre></figure>
<p>再看看 <code>stepLeader</code> 如何处理心跳回包：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">func stepLeader(r *raft, m pb.Message) error {
    // These message types do not require any progress for m.From.
    switch m.Type {
    case pb.MsgHeartbeatResp:
        pr.RecentActive = true
        pr.resume()

        if r.readOnly.option != ReadOnlySafe || len(m.Context) == 0 {
            return nil
        }

        ackCount := r.readOnly.recvAck(m)
        if ackCount &lt; r.quorum() {  // 判断是否收到 quorum 的心跳回包
            return nil
        }

        // 收到 quorum 的心跳回包了，把 readIndexReq 依次 append r.readStates 中，返回 ready 对象时会包含 r.readStates
        rss := r.readOnly.advance(m)
        for _, rs := range rss {
            req := rs.req
            if req.From == None || req.From == r.id { // from local member
                r.readStates = append(r.readStates, ReadState{Index: rs.index, RequestCtx: req.Entries[0].Data})
            } else {
                r.send(pb.Message{To: req.From, Type: pb.MsgReadIndexResp, Index: rs.index, Entries: req.Entries})
            }
        }
    return nil
    }
    return nil
}
</code></pre></figure>
<p>调用 <code>r.readOnly.recvAck</code>，根据 readIndeReq 的 reqId 统计收到心跳回包的数量：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">// recvAck notifies the readonly struct that the raft state machine received
// an acknowledgment of the heartbeat that attached with the read only request
// context.
func (ro *readOnly) recvAck(m pb.Message) int {
    rs, ok := ro.pendingReadIndex[string(m.Context)]
    if !ok {
        return 0
    }

    rs.acks[m.From] = struct{}{}  // 记录下收到 m.From 这个节点的 ack
    // add one to include an ack from local node
    return len(rs.acks) + 1
}
</code></pre></figure>
<p>如果超过 quonum 表示该节点依然是 leader，此时从 <code>r.readOnly.advance</code> 拿到保存的 readIndexReq，append 到 <code>r.readStates</code> 中：</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">// advance advances the read only request queue kept by the readonly struct.
// It dequeues the requests until it finds the read only request that has
// the same context as the given `m`.
func (ro *readOnly) advance(m pb.Message) []*readIndexStatus {
    var (
        i     int
        found bool
    )

    ctx := string(m.Context)
    rss := []*readIndexStatus{}

    for _, okctx := range ro.readIndexQueue {
        i++
        rs, ok := ro.pendingReadIndex[okctx]
        if !ok {
            panic(&quot;cannot find corresponding read state from pending map&quot;)
        }
        rss = append(rss, rs)
        if okctx == ctx {
            // 取出 reqId 相同的 ReadState 和其前面的所有 ReadState 
            found = true
            break
        }
    }

    if found {
        ro.readIndexQueue = ro.readIndexQueue[i:]
        for _, rs := range rss {
            delete(ro.pendingReadIndex, string(rs.req.Entries[0].Data))
        }
        return rss
    }

    return nil
}
</code></pre></figure>
<p>之后调用 <code>newReady</code> 会把 <code>r.readStates</code> 返回给应用层，应用层取出 readIndexReq 中的 commit index，等到其被 apply 到状态机就可以允许读操作了。</p>
<figure class="highlight"><pre><code class="language-go" data-lang="go">func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
    rd := Ready{
        Entries:          r.raftLog.unstableEntries(),
        CommittedEntries: r.raftLog.nextEnts(),
        Messages:         r.msgs,
    }
    ...

    if len(r.readStates) != 0 {
        rd.ReadStates = r.readStates  // 附上 r.readStates
    }
    ...
    return rd
}
</code></pre></figure>
  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/07/etcd-raft-note-4/" title="link to etcd-raft 源码学习笔记（Linearizable Read 之 Lease）">etcd-raft 源码学习笔记（Linearizable Read 之 Lease）</a></h2>
       <p class="excerpt">这篇文章介绍 etcd-raft 如何实现 linearizable read（linearizable read 简单的说就是不返回 stale 数据，具体可以看这篇文章 《Strong consistency models》）。除了基于 ReadIndex 之外，raft 论文第 8 节还阐述了另一种基于 heartbeat 的 lease 思路：Alternatively, the leader could rely on the heartbeat mechanism to pro...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-07-06 08:46:43 +0800" class="post-list__meta--date date">2018-07-06</time> &#8226; <span class="post-list__meta--tags tags">源码阅读</span><a class="btn-border-small" href=/2018/07/etcd-raft-note-4/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/07/etcd-raft-note-2/" title="link to etcd-raft 源码学习笔记（概览篇）">etcd-raft 源码学习笔记（概览篇）</a></h2>
       <p class="excerpt">这篇文章主要整体上介绍 etcd-raft 库，包括各个类的作用，类之间的串联。不涉及 raft 算法。先来看看 etcd-raft 几个结构体的定义：type raft struct {    id uint64    Term uint64    Vote uint64    // the log    raftLog *raftLog    state StateType    // isLearner is true if the local raft node is a lear...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-07-04 13:33:35 +0800" class="post-list__meta--date date">2018-07-04</time> &#8226; <span class="post-list__meta--tags tags">源码阅读</span><a class="btn-border-small" href=/2018/07/etcd-raft-note-2/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://masutangu.com/2018/07/etcd-raft-note-3/";
        this.page.identifier = "/2018/07/etcd-raft-note-3/";
    };

    var disqus_shortname = 'masutangu';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://masutangu.com/">@masutangu</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/Masutangu/Masutangu.github.io">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
