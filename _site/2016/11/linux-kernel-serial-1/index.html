<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Linux 内核系列－进程</title>
  <meta name="description" content="本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Linux 内核系列－进程">
  <meta name="twitter:description" content="本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Linux 内核系列－进程">
  <meta property="og:description" content="本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2016/11/linux-kernel-serial-1/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://500px.me/community/user-details/5cc3fb7c1480fb4fc2140a09627457614" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-11-27 13:49:16 +0800" itemprop="datePublished" class="post-meta__date date">2016-11-27</time> &#8226; <span class="post-meta__tags tags">读书笔记</span>
    </div>
    <h1 class="post-title">Linux 内核系列－进程</h1>
  </header>

  <section class="post">
    <p>本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。</p>

<h1>概念</h1>

<p>进程即处于运行中的程序，除了程序的代码外，还包括打开的文件、挂起的信号、进程状态、内存地址空间以及用以存储全局变量的数据段等。</p>

<p>执行线程，简称线程，是在进程中活动的对象。每个线程都拥有独立的程序计数器、进程栈和一组进程寄存器。内核的调度对象是线程，而不是进程。</p>

<p>在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虚拟处理器提供给进程独享处理器的假象，虚拟内存则提供进程独占内存资源的假象。线程之间可以共享虚拟内存，但拥有各自的虚拟处理器。</p>

<h2>创建</h2>

<p>在 UNIX 系统中，只有系统调用 fork 可以创建新进程。</p>

<p>使用 fork 创建新进程，子进程从父进程继承了如下属性：</p>

<ul>
<li>实际用户 ID、实际组 ID、有效用户 ID、有效组 ID</li>
<li>附属组 ID</li>
<li>进程组 ID</li>
<li>会话 ID</li>
<li>控制终端</li>
<li>设置用户 ID 标志和设置组 ID 标志</li>
<li>打开的文件描述符（相当于调用了 dup 函数）</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和处理函数</li>
<li>close-on-exec 标志</li>
<li>环境</li>
<li>共享存储段</li>
<li>存储映射</li>
<li>资源限制</li>
</ul>

<p>父子进程区别如下：</p>

<ul>
<li>fork 返回值</li>
<li>进程 ID 和父进程 ID</li>
<li>子进程的 tms_utime、tms_stime、tms_cutime、tms_ustime 的值设置为 0</li>
<li>子进程不继承父进程设置的文件锁</li>
<li>子进程未处理的 alarm 被清除</li>
<li>子进程未处理的信号集被置空</li>
</ul>

<h2>终止</h2>

<p>进程终止通常由以下条件引起：</p>

<ul>
<li>正常退出</li>
<li>出错退出</li>
<li>严重错误</li>
<li>被其他进程杀死</li>
</ul>

<p>当进程终止时，内核会向其父进程发送 SIGCHLD 信号。</p>

<h2>层次结构</h2>

<p>在 UNIX 中，进程和其子进程共同组成一个进程组。整个系统中，所有进程都属于以 init 为根的一棵树。</p>

<p>进程组是一个或多个进程的集合，通常是在同一个作业中结合起来的。同一个进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组 ID。每个进程组有一个组长进程，组长进程的进程组 ID 等于其进程 ID。只要进程组中还有进程存在，该进程组就存在。一个进程只能为自己或其子进程设置进程组 ID，在子进程调用了 exec 后，它就无法再更改子进程的进程组 ID。</p>

<p>会话是一个或多个进程组的集合。一个会话可以有一个控制终端，建立与控制终端连接的会话首进程（session leader）被称为控制进程（controlling process）。会话可以有一个前台进程组和多个后台进程组。终端产生的信号都将发送给前台进程组，调制解调器断开连接时，挂断信号将发给控制进程。</p>

<p>孤儿进程组定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。换句话说，如果该组有一个进程的父进程属于同一会话的另一个组，则该组不是孤儿进程组。POSIX.1 要求向孤儿进程组中处于停止状态的进程发送 SIGHUP 信号，系统对于这种信号的默认处理是终止进程。</p>

<p>为什么需要孤儿进程组的概念：</p>

<blockquote>
<p>When a controlling process terminates, its terminal becomes free and a new session can be established on it. (In fact, another user could log in on the terminal.) This could cause a problem if any processes from the old session are still trying to use that terminal.</p>

<p>To prevent problems, process groups that continue running even after the session leader has terminated are marked as orphaned process groups. When a process group becomes an orphan, its processes are sent a SIGHUP signal. Ordinarily, this causes the processes to terminate. However, if a program ignores this signal or establishes a handler for it, it can continue running as in the orphan process group even after its controlling process terminates; but it still cannot access the terminal any more.</p>
</blockquote>

<h2>状态</h2>

<p>进程有以下三种状态：</p>

<ul>
<li>运行态：占用 CPU</li>
<li>就绪态：可以执行，等待其他进程执行完</li>
<li>阻塞态：需要外部事件触发</li>
</ul>

<h2>进程表</h2>

<p>操作系统维护一张进程表，每个进程占用一个表项。该表项包含了进程状态的重要信息。包括程序计数器、堆栈指针、内存分配状况、所打开的文件指针、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，以保证进程随后能再次启动。</p>

<p>下图为一个典型系统中进程表项的关键字段：</p>

<table><thead>
<tr>
<th>进程管理</th>
<th>存储管理</th>
<th>文件管理</th>
</tr>
</thead><tbody>
<tr>
<td>寄存器</td>
<td>正文段指针</td>
<td>根目录</td>
</tr>
<tr>
<td>程序计数器</td>
<td>数据段指针</td>
<td>工作目录</td>
</tr>
<tr>
<td>程序状态字</td>
<td>堆栈段指针</td>
<td>文件描述符</td>
</tr>
<tr>
<td>进程状态</td>
<td></td>
<td></td>
</tr>
<tr>
<td>优先级</td>
<td></td>
<td></td>
</tr>
<tr>
<td>调度参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>父进程</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>信号</td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程开始的时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用cpu的时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>子进程的cpu时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>下次alarm的时间</td>
<td></td>
<td></td>
</tr>
</tbody></table>

<h2>中断</h2>

<p>中断的处理和调度过程如下：</p>

<ul>
<li>硬件将程序计数器等压入堆栈</li>
<li>硬件从中断向量中加载新的程序计数器</li>
<li>汇编语言写的 procedure 保存堆栈中的寄存器等信息，并移除该信息</li>
<li>汇编语言写的 procedure 设置新的堆栈</li>
<li>c 中断服务例程开始执行</li>
<li>处理完后，调度程序决定下一个执行的进程</li>
<li>返回至汇编代码，恢复即将执行的进程的寄存器等信息，并启动该进程</li>
</ul>

<h2>线程</h2>

<p>线程提供共享同一地址空间和数据的能力，并且比进程更加轻量级。</p>

<p>如果多个线程都是 CPU 密集型的，那么并不能得到性能上的增强。但如果存在大量的计算和 IO 处理，那么多线程运行这些活动彼此重叠进行，从而加快应用程序的执行速度。</p>

<p>进程模型基于两种独立的概念：<strong>资源分组处理</strong>和<strong>执行</strong>。而线程的引入即是对这两种概念的区分。理解进程的一个角度是，用某种方法把相关资源集中在一起，将资源放在进程中可以更容易的管理。另一个概念是，进程有一个执行线程，通常简写为线程。线程拥有程序计数器用以记录执行的下一条指令，寄存器用以保存当前的工作变量，堆栈用以记录执行历史，其中每一帧保存了一个已调用但还没返回的函数。<strong>进程用于把资源集中到一起，而线程则是在 CPU 上被调度执行的实体。</strong></p>

<p>线程有两种主要的实现方法：</p>

<p><img src="/assets/images/linux-kernel-serial-1/illustration-2.png" width="800" /></p>

<ul>
<li><p>用户空间：</p>

<p>把整个线程包放在用户空间中，内核对线程一无所知。从内核的角度即单线程进程。这类实现有同样的通用结构，线程在一个运行时系统之上运行，运行时系统是管理线程的函数集合（pthread_create, pthread_exit, pthread_join 和 pthread_yield 等），如上图左图。</p>

<p>在用户空间管理线程时，每个进程需要有专用的线程表，用以跟踪该进程中的线程。线程表记录了线程的属性，如程序计数器、堆栈、寄存器和状态等。该线程表由运行时系统管理。</p>

<p>用户级线程的优点在于保存线程状态和调度都是本地过程，比内核调用更有效率，另外不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新。</p>

<p>用户级线程还允许每个进程定制自己的调度算法。</p>

<p>用户级线程的问题在于难以实现阻塞系统调用，page faults 引发阻塞，以及没有时钟中断，需要依赖线程自动放弃 CPU。</p></li>
<li><p>内核空间：</p>

<p>内核实现线程的管理，此时便不再需要运行时系统了，如上图右图。在内核中有专门的线程表记录所有线程。与用户级线程类似，内核的线程表保存线程的信息。</p></li>
</ul>

<h1>系统调用及库函数</h1>

<h2>进程终止</h2>

<p>正常终止包括以下方式：</p>

<ul>
<li>从 main 函数返回</li>
<li>调用 exit</li>
<li>调用 _exit 或 _Exit</li>
<li>最后一个线程从其启动例程中返回</li>
<li>从最后一个线程调用 pthread_exit</li>
</ul>

<p>异常退出有以下方式：</p>

<ul>
<li>调用 abort</li>
<li>接收到一个信号</li>
<li>最后一个线程对取消请求做出回应</li>
</ul>

<h3>退出函数</h3>
<figure class="highlight"><pre><code class="language-c" data-lang="c">#include &lt;stdlib.h&gt;
void exit(int status);
void _Exit(int status);

#include &lt;unistd.h&gt;
void _exit(int status);
</code></pre></figure>
<p>_exit 和 _Exit 立即进入内核，而 exit 会先执行些清理工作（exit 函数总执行一个标准 I/O 库的清理关闭操作：对所有打开流调用 fclose 函数，造成输出缓冲区中数据被冲洗）。</p>

<p>三个退出函数都带有一个整型参数，称为终止状态。</p>

<h1>Linux 中的实现</h1>

<h2>进程描述符及任务结构</h2>

<p>内核把进程的列表存放在名为任务队列（task list）的双向循环链表中。链表中的每一项类型都为 task_struct ，称为进程描述符（process descriptor）。task_struct 在 32 位机器上大概占用 1.7 KB。</p>

<p>进程描述符包含了进程的所有信息，包括打开的文件，进程地址空间，挂起的信号，进程的状态等等。</p>

<p>task_struct 结构体如下：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">struct task_struct {
    volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */
    void *stack;
    atomic_t usage;
    unsigned int flags; /* per process flags, defined below */

    int prio, static_prio, normal_prio;
    unsigned int rt_priority;
    const struct sched_class *sched_class;
    struct sched_entity se;
    struct sched_rt_entity rt;

    unsigned int policy;
    int nr_cpus_allowed;
    cpumask_t cpus_allowed;

    struct list_head tasks;  // 进程链表
    struct mm_struct *mm, *active_mm;

    /* task state */
    int exit_state;
    int exit_code, exit_signal;
    int pdeath_signal;  /*  The signal sent when the parent dies  */

    pid_t pid;
    pid_t tgid;

    /* 
     * pointers to (original) parent process, youngest child, younger sibling,
     * older sibling, respectively.  (p-&gt;father can be replaced with 
     * p-&gt;real_parent-&gt;pid)
     */
    struct task_struct *real_parent; /* real parent process */
    struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */
    /*
     * children/sibling forms the list of my natural children
     */
    struct list_head children;  /* list of my children */
    struct list_head sibling;   /* linkage in my parent&#39;s children list */
    struct task_struct *group_leader;   /* threadgroup leader */

    /* PID/PID hash table linkage. */
    struct pid_link pids[PIDTYPE_MAX];

    /* file system info */
    struct nameidata *nameidata;
    /* filesystem information */
    struct fs_struct *fs;
    /* open file information */
    struct files_struct *files;

    /* signal handlers */
    struct signal_struct *signal;
    struct sighand_struct *sighand;

    sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */
    struct sigpending pending;
};
</code></pre></figure>
<p>在内核 2.6 之前，task_struct 结构被存储于每个进程的内核栈的底部。2.6 之后，thread_info 结构体存储于内核栈的底部，而 task_struct 为该结构体的成员:</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">struct thread_info {
    struct task_struct      *task;          /* main task structure */
    struct exec_domain      *exec_domain;   /* execution domain */
    __u32                   flags;          /* low level flags */
    __u32                   status;         /* thread synchronous flags */
    __u32                   cpu;            /* current CPU */
    int                     preempt_count;  /* 0 =&gt; preemptable,  &lt;0 =&gt; BUG */
    mm_segment_t            addr_limit;
    struct restart_block    restart_block;
    void __user             *sysenter_return;
#ifdef CONFIG_X86_32
    unsigned long           previous_esp;   /* ESP of the previous stack in case of nested (IRQ) stacks */
    __u8                    supervisor_stack[0];
#endif
    int                     uaccess_err;
};
</code></pre></figure>
<p>PID 是进程的唯一标志，其类型为 pid_t。内核将进程的 PID 存放在各自的 task_struct 结构体中。</p>

<p>注：PID 在内核态和用户态是不同的概念。Linux 中的线程都有各自的 PID，而 getpid() 返回的其实不是 PID，而是 TGID。</p>

<p><a href="http://stackoverflow.com/questions/9154671/distinction-between-processes-and-threads-in-linux">stackoverflow</a> 上的解释：</p>

<blockquote>
<p>The first and most important thing to realize is that &quot;PID&quot; means different things in kernel space and user space. What the kernel calls PIDs are actually kernel-level thread ids (often called TIDs), not to be confused with pthread_t which is a separate identifier. Each thread on the system, whether in the same process or a different one, has a unique TID (or &quot;PID&quot; in the kernel&#39;s terminology). What&#39;s considered a PID in the POSIX sense of &quot;process&quot;, on the other hand, is called a &quot;thread group ID&quot; or &quot;TGID&quot; in the kernel. Each process consists of one or more threads (kernel processes) each with their own TID (kernel PID), but all sharing the same TGID, which is equal to the TID (kernel PID) of the initial thread in which main runs.</p>
</blockquote>

<p>current 宏用于快速定位当前执行的进程的进程描述符，current_thread_info() 的 C 语言实现如下：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">static inline struct thread_info *current_thread_info(void) __attribute_const__;

static inline struct thread_info *current_thread_info(void)
{
    return (struct thread_info *)
        (current_stack_pointer &amp; ~(THREAD_SIZE - 1));   // 按照 THREAD\_SIZE 对齐
}
</code></pre></figure>
<p>调用 current_thread_info()-&gt;task 返回 task_struct。</p>

<p>进程的当前状态由 task_struct 的 state 字段来表示，分别有以下几种情况：</p>

<p><img src="/assets/images/linux-kernel-serial-1/illustration-1.png" width="800" /></p>

<ul>
<li>TASK_RUNNING：进程正在执行或处于可运行的就绪状态。</li>
<li>TASK_INTERRUPTIBLE：进程正在休眠，等待某个条件发生。当收到信号时进程也会被唤醒。</li>
<li>TASK_UNINTERRUPTIBLE：和 TASK_INTERRUPTIBLE 类似，但收到信号时进程不会被唤醒。</li>
<li>__TASK_STOPPED：进程终止，通常发生于进程收到 SIGSTOP, SIGTSTP, SIGTTIN 或 SIGTTOU 信号。</li>
</ul>

<p>当进程执行了系统调用或触发了异常，它就陷入了内核空间，此时内核“代表进程执行”并处于进程的上下文中。在此上下文中 current 宏是有效的（处于中断上下文的情况下，系统不代表进程执行，此时不存在进程上下文，current 宏也是无效的）。</p>

<p>task_struct 的 parent 字段指向其父进程 task_struct，children 字段为其子进程的链表。因此可以通过下面代码得到父进程的进程描述符：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">struct task_struct *my_parent = current-&gt;parent;
</code></pre></figure>
<p>同样，以下代码可以依次访问子进程：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">struct task_struct *task; 
struct list_head *list;

list_for_each(list, &amp;current-&gt;children) {
    task = list_entry(list, struct task_struct, sibling); 
    /* task now points to one of current’s children */
}
</code></pre></figure>
<p>任务队列是双向循环链表，下面代码可以获取链表中的下一个进程：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">list_entry(task-&gt;tasks.next, struct task_struct, tasks)
</code></pre></figure>
<p>获取前一个进程：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">list_entry(task-&gt;tasks.prev, struct task_struct, tasks)
</code></pre></figure>
<h2>进程创建</h2>

<p>fork() 通过拷贝当前进程来创建一个子进程。子进程和父进程的区别仅仅在于 PID、PPID 和某些资源和统计量（例如挂起的信号）。exec() 函数负责读取可执行文件并将其载入地址空间开始运行。</p>

<p>Linux 通过 clone() 系统调用实现 fork()。这个调用通过一系列参数标志来指明父子进程需要共享的资源。fork()、vfork() 和 __clone() 库函数都根据各自需要的参数标志去调用 clone()，然后由 clone() 去调用 do_fork()。</p>

<p>do_fork() 完成创建进程中的大部分工作，该函数调用 copy_process() 函数，然后让进程开始运行。copy_process() 的步骤如下：</p>

<ul>
<li>调用 dup_task_struct() 为新进程创建一个内核栈、thread_info 结构和 task_struct。这些值与当前进程相同，此时父子进程的描述符完全相同。</li>
<li>检查当前用户所拥有的进程数没有超出资源限制。</li>
<li>子进程开始与父进程区别开来，将进程描述符里的大多数成员重新初始化。</li>
<li>将子进程的状态置为 TASK_UNINTERRUPTIBLE。（没有找到对应的代码）</li>
<li>copy_process() 调用 copy_flags() 以更新 task_struct 的 flags 成员，重置 PF_SUPERPRIV 标志位，并设置 PF_FORKNOEXEC 标志位。</li>
<li>根据不同的 clone_flags 参数，拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。一般情况下，同一个进程内的线程共享这些信息。</li>
<li>调用 alloc_pid() 为新进程分配一个有效的 PID。</li>
<li>最后，copy_process() 做扫尾工作并返回指向子进程的指针。</li>
</ul>

<p>回到 do_fork() 函数，如果 copy_process() 返回成功，唤醒新创建的子进程并让其投入运行。内核有意选择子进程先执行，如果子进程马上调用 exec() 函数可以避免写时拷贝的额外开销。</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">long do_fork(unsigned long clone_flags,
          unsigned long stack_start,
          struct pt_regs *regs,
          unsigned long stack_size,
          int __user *parent_tidptr,
          int __user *child_tidptr)
{
    struct task_struct *p;

    p = copy_process(clone_flags, stack_start, regs, stack_size,
             child_tidptr, NULL, trace);

    /*
     * Do this prior waking up the new thread - the thread pointer
     * might get invalid after that point, if the thread exits quickly.
     */
    if (!IS_ERR(p)) {
        struct completion vfork;

        trace_sched_process_fork(current, p);

        if (clone_flags &amp; CLONE_VFORK) {
            p-&gt;vfork_done = &amp;vfork;
            init_completion(&amp;vfork);
        }

        /*
         * We set PF_STARTING at creation in case tracing wants to
         * use this to distinguish a fully live task from one that
         * hasn&#39;t gotten to tracehook_report_clone() yet.  Now we
         * clear it and set the child going.
         */
        p-&gt;flags &amp;= ~PF_STARTING;

        if (unlikely(clone_flags &amp; CLONE_STOPPED)) {
            /*
             * We&#39;ll start up with an immediate SIGSTOP.
             */
            sigaddset(&amp;p-&gt;pending.signal, SIGSTOP);
            set_tsk_thread_flag(p, TIF_SIGPENDING);
            __set_task_state(p, TASK_STOPPED);
        } else {
            wake_up_new_task(p, clone_flags);
        }

        if (clone_flags &amp; CLONE_VFORK) {
            wait_for_completion(&amp;vfork);
        }
    } else {
        nr = PTR_ERR(p);
    }
    return nr;
}

static struct task_struct *copy_process(unsigned long clone_flags,
                    unsigned long stack_start,
                    struct pt_regs *regs,
                    unsigned long stack_size,
                    int __user *child_tidptr,
                    struct pid *pid,
                    int trace)
{
    int retval;
    struct task_struct *p;

    p = dup_task_struct(current);

    if (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=
            task_rlimit(p, RLIMIT_NPROC)) {
        if (!capable(CAP_SYS_ADMIN) &amp;&amp; !capable(CAP_SYS_RESOURCE) &amp;&amp;
            p-&gt;real_cred-&gt;user != INIT_USER)
            goto bad_fork_free;
    }

    p-&gt;did_exec = 0;
    delayacct_tsk_init(p);  /* Must remain after dup_task_struct() */
    copy_flags(clone_flags, p);
    INIT_LIST_HEAD(&amp;p-&gt;children);
    INIT_LIST_HEAD(&amp;p-&gt;sibling);
    rcu_copy_process(p);
    p-&gt;vfork_done = NULL;
    spin_lock_init(&amp;p-&gt;alloc_lock);

    init_sigpending(&amp;p-&gt;pending);

    p-&gt;utime = cputime_zero;
    p-&gt;stime = cputime_zero;
    p-&gt;gtime = cputime_zero;
    p-&gt;utimescaled = cputime_zero;
    p-&gt;stimescaled = cputime_zero;
#ifndef CONFIG_VIRT_CPU_ACCOUNTING
    p-&gt;prev_utime = cputime_zero;
    p-&gt;prev_stime = cputime_zero;
#endif

    /* copy all the process information */
    if ((retval = copy_semundo(clone_flags, p)))
        goto bad_fork_cleanup_audit;
    if ((retval = copy_files(clone_flags, p)))
        goto bad_fork_cleanup_semundo;
    if ((retval = copy_fs(clone_flags, p)))
        goto bad_fork_cleanup_files;
    if ((retval = copy_sighand(clone_flags, p)))
        goto bad_fork_cleanup_fs;
    if ((retval = copy_signal(clone_flags, p)))
        goto bad_fork_cleanup_sighand;
    if ((retval = copy_mm(clone_flags, p)))
        goto bad_fork_cleanup_signal;
    if ((retval = copy_namespaces(clone_flags, p)))
        goto bad_fork_cleanup_mm;
    if ((retval = copy_io(clone_flags, p)))
        goto bad_fork_cleanup_namespaces;
    retval = copy_thread(clone_flags, stack_start, stack_size, p, regs);
    if (retval)
        goto bad_fork_cleanup_io;

    if (pid != &amp;init_struct_pid) {
        retval = -ENOMEM;
        pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns);
        if (!pid)
            goto bad_fork_cleanup_io;

        if (clone_flags &amp; CLONE_NEWPID) {
            retval = pid_ns_prepare_proc(p-&gt;nsproxy-&gt;pid_ns);
            if (retval &lt; 0)
                goto bad_fork_free_pid;
        }
    }

    p-&gt;pid = pid_nr(pid);
    p-&gt;tgid = p-&gt;pid;
    if (clone_flags &amp; CLONE_THREAD)
        p-&gt;tgid = current-&gt;tgid;  // 同一进程内的所有线程的 tgid 相同


    /* ok, now we should be set up.. */
    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? -1 : (clone_flags &amp; CSIGNAL);
    p-&gt;pdeath_signal = 0;
    p-&gt;exit_state = 0;

    /*
     * Ok, make it visible to the rest of the system.
     * We dont wake it up yet.
     */
    p-&gt;group_leader = p;
    INIT_LIST_HEAD(&amp;p-&gt;thread_group);

    /* CLONE_PARENT re-uses the old parent */
    if (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) {
        p-&gt;real_parent = current-&gt;real_parent;
        p-&gt;parent_exec_id = current-&gt;parent_exec_id;
    } else {
        p-&gt;real_parent = current;
        p-&gt;parent_exec_id = current-&gt;self_exec_id;
    }

    return p;
}

static struct task_struct *dup_task_struct(struct task_struct *orig)
{
    struct task_struct *tsk;
    struct thread_info *ti;
    unsigned long *stackend;

    int err;

    prepare_to_copy(orig);

    tsk = alloc_task_struct();
    if (!tsk)
        return NULL;

    ti = alloc_thread_info(tsk);
    if (!ti) {
        free_task_struct(tsk);
        return NULL;
    }

    err = arch_dup_task_struct(tsk, orig);
    if (err)
        goto out;

    tsk-&gt;stack = ti;

    setup_thread_stack(tsk, orig);
    stackend = end_of_stack(tsk);
    *stackend = STACK_END_MAGIC;    /* for overflow detection */

    /* One for us, one for whoever does the &quot;release_task()&quot; (usually parent) */
    atomic_set(&amp;tsk-&gt;usage,2);
    atomic_set(&amp;tsk-&gt;fs_excl, 0);

    return tsk;
}

// x86 下的实现
int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
{
    *dst = *src;
    if (src-&gt;thread.xstate) {
        dst-&gt;thread.xstate = kmem_cache_alloc(task_xstate_cachep,
                              GFP_KERNEL);
        if (!dst-&gt;thread.xstate)
            return -ENOMEM;
        WARN_ON((unsigned long)dst-&gt;thread.xstate &amp; 15);
        memcpy(dst-&gt;thread.xstate, src-&gt;thread.xstate, xstate_size);
    }
    return 0;
}

#define task_thread_info(task)  ((struct thread_info *)(task)-&gt;stack)

#define setup_thread_stack(p, org) \
    *task_thread_info(p) = *task_thread_info(org); \
    task_thread_info(p)-&gt;task = (p);

static void copy_flags(unsigned long clone_flags, struct task_struct *p)
{
    unsigned long new_flags = p-&gt;flags;

    new_flags &amp;= ~PF_SUPERPRIV;
    new_flags |= PF_FORKNOEXEC;
    new_flags |= PF_STARTING;
    p-&gt;flags = new_flags;
    clear_freeze_flag(p);
}

void wake_up_new_task(struct task_struct *p, unsigned long clone_flags)
{
    unsigned long flags;
    struct rq *rq;
    int cpu __maybe_unused = get_cpu();

#ifdef CONFIG_SMP
    /*
     * Fork balancing, do it here and not earlier because:
     *  - cpus_allowed can change in the fork path
     *  - any previously selected cpu might disappear through hotplug
     *
     * We still have TASK_WAKING but PF_STARTING is gone now, meaning
     * -&gt;cpus_allowed is stable, we have preemption disabled, meaning
     * cpu_online_mask is stable.
     */
    cpu = select_task_rq(p, SD_BALANCE_FORK, 0);
    set_task_cpu(p, cpu);
#endif

    /*
     * Since the task is not on the rq and we still have TASK_WAKING set
     * nobody else will migrate this task.
     */
    rq = cpu_rq(cpu);
    raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);

    BUG_ON(p-&gt;state != TASK_WAKING);
    p-&gt;state = TASK_RUNNING;  // 设置成TASK_RUNNING状态  
    update_rq_clock(rq);
    activate_task(rq, p, 0);  // activate_task 会把该 task 放入 cpu 的 runqueue
    trace_sched_wakeup_new(rq, p, 1);
    check_preempt_curr(rq, p, WF_FORK);
#ifdef CONFIG_SMP
    if (p-&gt;sched_class-&gt;task_woken)
        p-&gt;sched_class-&gt;task_woken(rq, p);
#endif
    task_rq_unlock(rq, &amp;flags);
    put_cpu();
}


/*
 * activate_task - move a task to the runqueue.
 */
static void activate_task(struct rq *rq, struct task_struct *p, int wakeup)
{
    if (task_contributes_to_load(p))
        rq-&gt;nr_uninterruptible--;

    enqueue_task(rq, p, wakeup, false);  // 放入 runqueue
    inc_nr_running(rq);
}

</code></pre></figure>
<p>vfork() 的实现是通过向 clone() 传递一个特殊标志 CLONE_VFORK 来进行的：</p>

<ul>
<li>在调用 copy_process() 时，task_struct 的 vfork_done 成员被设置为 NULL。</li>
<li>在执行 do_fork() 时，如果指定了 CLONE_VFORK 标志位，则 vfork_done 会被设置为指向一个特定地址。</li>
<li>子进程先开始执行后，父进程会一直等待，直到子进程通过 vfork_done 指针向他发送信号。</li>
<li>进程退出内存地址空间时会调用 mm_release() 函数，该函数会检查 vfork_done 是非为空，如果非空，则向父进程发送信号。</li>
<li>返回到 do_fork()，父进程被唤醒并继续执行</li>
</ul>
<figure class="highlight"><pre><code class="language-c" data-lang="c">void mm_release(struct task_struct *tsk, struct mm_struct *mm)
{
    struct completion *vfork_done = tsk-&gt;vfork_done;

    /* notify parent sleeping on vfork() */
    if (vfork_done) {
        tsk-&gt;vfork_done = NULL;
        complete(vfork_done);
    }
}
</code></pre></figure>
<h2>线程</h2>

<p>Linux 把所有线程都当做进程来实现，每个线程都有唯一隶属于自己的 task_struct，所以在内核中，它看起来就像是一个普通的进程。</p>

<p>线程的创建和普通进程类似，只不过调用 clone() 的时候需要传递参数来指明需要共享的资源：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);
</code></pre></figure>
<p>下表列举了参数标志及其作用：</p>

<table><thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>CLONE_FILES</td>
<td>Parent and child share open files</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>Parent and child share filesystem information</td>
</tr>
<tr>
<td>CLONE_IDLETASK</td>
<td>Set PID to zero (used only by the idle tasks)</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>Create a new namespace for the child</td>
</tr>
<tr>
<td>CLONE_PARENT</td>
<td>Child is to have same parent as its parent</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>Continue tracing child</td>
</tr>
<tr>
<td>CLONE_SETTID</td>
<td>Write the TID back to user-space</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>Create a new TLS for the child</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>Parent and child share signal handlers and blocked signals</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>Parent and child share System V SEM_UNDO semantics</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>Parent and child are in the same thread group</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>vfork() was used and the parent will sleep until the child wakes it</td>
</tr>
<tr>
<td>CLONE_UNTRACED</td>
<td>Do not let the tracing process force CLONE_PTRACE on the child</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>Start process in the TASK_STOPPED state</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>Create a new TLS (thread-local storage) for the child</td>
</tr>
<tr>
<td>CLONE_CHILD_CLEARTID</td>
<td>Clear the TID in the child</td>
</tr>
<tr>
<td>CLONE_CHILD_SETTID</td>
<td>Set the TID in the child</td>
</tr>
<tr>
<td>CLONE_PARENT_SETTID</td>
<td>Set the TID in the parent</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>Parent and child share address space</td>
</tr>
</tbody></table>

<p>内核经常需要在后台执行一些操作，这通过内核线程来完成。内核线程和普通进程间的区别在于内核线程没有独立的地址空间（指向地址空间的 mm 指针被设置为 NULL）。内核线程只在内核空间运行，从来不切换到用户空间。内核线程和普通进程一样可以被调度和抢占。</p>

<h2>进程终止</h2>

<p>进程终止可以由自身调用 exit() 系统调用引起，或接收到不能处理或不能忽略的信号或异常时。进程终止由 do_exit() 完成大部分工作：</p>

<ul>
<li>将 task_struct 中的标志成员设置为 PF_EXITING。</li>
<li>调用 del_timer_sync() 删除内核定时器，确保没有定时器在排队也没有定时器处理程序在运行。</li>
<li>调用 acct_update_intergrals() 来输出记账信息。</li>
<li>调用 exit_mm() 函数释放进程占用的 mm_struct。如果该地址空间没有被共享，则彻底释放它们。</li>
<li>设置 exit_code 成员为由 exit() 提供的退出代码。</li>
<li>接下来调用 exit_sem() 函数，如果该进程正在排队等候 IPC 信号，则 dequeue。</li>
<li>调用 exit_files() 和 exit_fs()，分别递减文件描述符、文件系统数据的引用计数。如果引用计数降为零，则释放资源。</li>
<li>调用 exit_notify() 向父进程发送信号，给其子进程重新找养父，并把进程状态设置为 EXIT_ZOMBIE。</li>
<li>do_exit() 调用 schedule() 函数切换到新的进程。由于处于 EXIT_ZOMBIE 状态的进程不会再被调度，所以 do_exit() 永不返回。</li>
</ul>

<p>至此，与进程相关的所有资源都被释放，进程不可运行并处于 EXIT_ZOMBIE 状态。它占用的内存就是内核栈、thread_info 结构和 task_struct 结构。此时进程存在的唯一目的就是向父进程提供信息。父进程检索到信息或通知内核那是无关信息后，进程所持有的剩余内存将被释放。</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">NORET_TYPE void do_exit(long code)
{
    struct task_struct *tsk = current;
    int group_dead;

    /*
     * We&#39;re taking recursive faults here in do_exit. Safest is to just
     * leave this task alone and wait for reboot.
     */
    if (unlikely(tsk-&gt;flags &amp; PF_EXITING)) {
        printk(KERN_ALERT
            &quot;Fixing recursive fault but reboot is needed!\n&quot;);
        /*
         * We can do this unlocked here. The futex code uses
         * this flag just to verify whether the pi state
         * cleanup has been done or not. In the worst case it
         * loops once more. We pretend that the cleanup was
         * done as there is no way to return. Either the
         * OWNER_DIED bit is set by now or we push the blocked
         * task into the wait for ever nirwana as well.
         */
        tsk-&gt;flags |= PF_EXITPIDONE;
        set_current_state(TASK_UNINTERRUPTIBLE);
        schedule();
    }

    exit_signals(tsk);  /* sets PF_EXITING */

    acct_update_integrals(tsk);

    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);

    tsk-&gt;exit_code = code;

    exit_mm(tsk);

    exit_sem(tsk);
    exit_files(tsk);
    exit_fs(tsk);
    check_stack_usage();
    exit_thread();
    cgroup_exit(tsk, 1);

    exit_notify(tsk, group_dead);

    /*
     * We can do this unlocked here. The futex code uses this flag
     * just to verify whether the pi state cleanup has been done
     * or not. In the worst case it loops once more.
     */
    tsk-&gt;flags |= PF_EXITPIDONE;
    preempt_disable();
    exit_rcu();
    /* causes final put_task_struct in finish_task_switch(). */
    tsk-&gt;state = TASK_DEAD;
    schedule();
}

static void exit_mm(struct task_struct * tsk)
{
    struct mm_struct *mm = tsk-&gt;mm;
    struct core_state *core_state;

    mm_release(tsk, mm);
    if (!mm)
        return;

    down_read(&amp;mm-&gt;mmap_sem);
    atomic_inc(&amp;mm-&gt;mm_count);
    BUG_ON(mm != tsk-&gt;active_mm);
    /* more a memory barrier than a real lock */
    task_lock(tsk);
    tsk-&gt;mm = NULL;
    up_read(&amp;mm-&gt;mmap_sem);
    enter_lazy_tlb(mm, current);
    /* We don&#39;t want this task to be frozen prematurely */
    clear_freeze_flag(tsk);
    task_unlock(tsk);
    mm_update_next_owner(mm);
    mmput(mm);
}

/*
 * Send signals to all our closest relatives so that they know
 * to properly mourn us..
 */
static void exit_notify(struct task_struct *tsk, int group_dead)
{
    int signal;
    void *cookie;

    /*
     * This does two things:
     *
     * A.  Make init inherit all the child processes
     * B.  Check to see if any process groups have become orphaned
     *  as a result of our exiting, and if they have any stopped
     *  jobs, send them a SIGHUP and then a SIGCONT.  (POSIX 3.2.2.2)
     */
    forget_original_parent(tsk);
    exit_task_namespaces(tsk);

    write_lock_irq(&amp;tasklist_lock);
    if (group_dead)
        kill_orphaned_pgrp(tsk-&gt;group_leader, NULL);

    /* Let father know we died
     *
     * Thread signals are configurable, but you aren&#39;t going to use
     * that to send signals to arbitary processes.
     * That stops right now.
     *
     * If the parent exec id doesn&#39;t match the exec id we saved
     * when we started then we know the parent has changed security
     * domain.
     *
     * If our self_exec id doesn&#39;t match our parent_exec_id then
     * we have changed execution domain as these two values started
     * the same after a fork.
     */
    if (tsk-&gt;exit_signal != SIGCHLD &amp;&amp; !task_detached(tsk) &amp;&amp;
        (tsk-&gt;parent_exec_id != tsk-&gt;real_parent-&gt;self_exec_id ||
         tsk-&gt;self_exec_id != tsk-&gt;parent_exec_id))
        tsk-&gt;exit_signal = SIGCHLD;

    signal = tracehook_notify_death(tsk, &amp;cookie, group_dead);
    if (signal &gt;= 0)
        signal = do_notify_parent(tsk, signal);  // 给父进程发信号。如果父进程处理 SIGCHLD 信号，返回 DEATH_REAP

    tsk-&gt;exit_state = signal == DEATH_REAP ? EXIT_DEAD : EXIT_ZOMBIE;  

    /* mt-exec, de_thread() is waiting for us */
    if (thread_group_leader(tsk) &amp;&amp;
        tsk-&gt;signal-&gt;group_exit_task &amp;&amp;
        tsk-&gt;signal-&gt;notify_count &lt; 0)
        wake_up_process(tsk-&gt;signal-&gt;group_exit_task);

    write_unlock_irq(&amp;tasklist_lock);

    tracehook_report_death(tsk, signal, cookie, group_dead);

    /* If the process is dead, release it - nobody will wait for it */
    if (signal == DEATH_REAP)
        release_task(tsk);
}

</code></pre></figure>
<p>调用 do_exit() 之后，其进程描述符依然被保留。在其父进程获得退出信息或通知内核它并不关注后，子进程的 task_struct 才被释放。</p>

<p>wait() 这一组函数都是通过唯一的系统调用 wait4() 来实现。它的标准动作是挂起调用它的进程，直到其中一个子进程退出。此时函数会返回该子进程的 PID。此外，调用该函数时提供的指针会包含子进程退出时的退出码。</p>

<p>wait 系统调用会调用 do_wait() 函数，其将调用 do_wait_thread() -&gt; wait_consider_task() -&gt; wait_task_zombie() -&gt; release_task()。release_task() 会释放进程描述符，完成以下工作：</p>

<ul>
<li>调用 __exit_signal()，进行最终统计，并调用 _unhash_process()，后者又会调用 detach_pid() 从 pidhash 上删除该进程，同时也从任务列表中删除该进程。</li>
<li>__exit_signal() 释放僵死进程所占用的剩余资源。</li>
<li>如果该进程是线程组的最后一个进程，并且领头进程已经死掉，那么release_task() 就得通知僵死的领头进程的父进程。</li>
<li>release_task() 调用 put_task_struct() 释放进程内核栈和 thread_info 结构所占的页，并释放 task_struct 所占的 slab 高速缓存。</li>
</ul>
<figure class="highlight"><pre><code class="language-c" data-lang="c">
void release_task(struct task_struct * p)
{
    struct task_struct *leader;
    int zap_leader;

repeat:
    __exit_signal(p);
    zap_leader = 0;
    leader = p-&gt;group_leader;
    if (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) {
        BUG_ON(task_detached(leader));
        do_notify_parent(leader, leader-&gt;exit_signal);
        /*
         * If we were the last child thread and the leader has
         * exited already, and the leader&#39;s parent ignores SIGCHLD,
         * then we are the one who should release the leader.
         *
         * do_notify_parent() will have marked it self-reaping in
         * that case.
         */
        zap_leader = task_detached(leader);

        /*
         * This maintains the invariant that release_task()
         * only runs on a task in EXIT_DEAD, just for sanity.
         */
        if (zap_leader)
            leader-&gt;exit_state = EXIT_DEAD;
    }

    write_unlock_irq(&amp;tasklist_lock);
    release_thread(p);
    call_rcu(&amp;p-&gt;rcu, delayed_put_task_struct);

    p = leader;
    if (unlikely(zap_leader))
        goto repeat;
}


/*
 * This function expects the tasklist_lock write-locked.
 */
static void __exit_signal(struct task_struct *tsk)
{
    struct signal_struct *sig = tsk-&gt;signal;
    struct sighand_struct *sighand;

    BUG_ON(!sig);
    BUG_ON(!atomic_read(&amp;sig-&gt;count));


    posix_cpu_timers_exit(tsk);
    if (atomic_dec_and_test(&amp;sig-&gt;count))
        posix_cpu_timers_exit_group(tsk);
    else {
        /*
         * If there is any task waiting for the group exit
         * then notify it:
         */
        if (sig-&gt;group_exit_task &amp;&amp; atomic_read(&amp;sig-&gt;count) == sig-&gt;notify_count)
            wake_up_process(sig-&gt;group_exit_task);

        if (tsk == sig-&gt;curr_target)
            sig-&gt;curr_target = next_thread(tsk);
        /*
         * Accumulate here the counters for all threads but the
         * group leader as they die, so they can be added into
         * the process-wide totals when those are taken.
         * The group leader stays around as a zombie as long
         * as there are other threads.  When it gets reaped,
         * the exit.c code will add its counts into these totals.
         * We won&#39;t ever get here for the group leader, since it
         * will have been the last reference on the signal_struct.
         */
        sig-&gt;utime = cputime_add(sig-&gt;utime, tsk-&gt;utime);
        sig-&gt;stime = cputime_add(sig-&gt;stime, tsk-&gt;stime);
        sig-&gt;gtime = cputime_add(sig-&gt;gtime, tsk-&gt;gtime);
        sig-&gt;min_flt += tsk-&gt;min_flt;
        sig-&gt;maj_flt += tsk-&gt;maj_flt;
        sig-&gt;nvcsw += tsk-&gt;nvcsw;
        sig-&gt;nivcsw += tsk-&gt;nivcsw;
        sig-&gt;inblock += task_io_get_inblock(tsk);
        sig-&gt;oublock += task_io_get_oublock(tsk);
        task_io_accounting_add(&amp;sig-&gt;ioac, &amp;tsk-&gt;ioac);
        sig-&gt;sum_sched_runtime += tsk-&gt;se.sum_exec_runtime;
        sig = NULL; /* Marker for below. */
    }

    __unhash_process(tsk);

    /*
     * Do this under -&gt;siglock, we can race with another thread
     * doing sigqueue_free() if we have SIGQUEUE_PREALLOC signals.
     */
    flush_sigqueue(&amp;tsk-&gt;pending);

    tsk-&gt;signal = NULL;
    tsk-&gt;sighand = NULL;
    spin_unlock(&amp;sighand-&gt;siglock);

    __cleanup_sighand(sighand);
    clear_tsk_thread_flag(tsk,TIF_SIGPENDING);
    if (sig) {
        flush_sigqueue(&amp;sig-&gt;shared_pending);
        taskstats_tgid_free(sig);
        /*
         * Make sure -&gt;signal can&#39;t go away under rq-&gt;lock,
         * see account_group_exec_runtime().
         */
        task_rq_unlock_wait(tsk);
        __cleanup_signal(sig);
    }
}

static void __unhash_process(struct task_struct *p)
{
    nr_threads--;
    detach_pid(p, PIDTYPE_PID);
    if (thread_group_leader(p)) {
        detach_pid(p, PIDTYPE_PGID);
        detach_pid(p, PIDTYPE_SID);

        list_del_rcu(&amp;p-&gt;tasks);  // 没理解 为什么需要是 group_header 才从 tasks_list 上删掉？
        list_del_init(&amp;p-&gt;sibling);
        __get_cpu_var(process_counts)--;
    }
    list_del_rcu(&amp;p-&gt;thread_group);
}


void release_task(struct task_struct *p)
{
    struct task_struct *leader;

    __exit_signal(p);

    zap_leader = 0;
    leader = p-&gt;group_leader;
    if (leader != p &amp;&amp; thread_group_empty(leader)
            &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE) {
        /*
         * If we were the last child thread and the leader has
         * exited already, and the leader&#39;s parent ignores SIGCHLD,
         * then we are the one who should release the leader.
         */
        zap_leader = do_notify_parent(leader, leader-&gt;exit_signal);
        if (zap_leader)
            leader-&gt;exit_state = EXIT_DEAD;
    }

    release_thread(p);
}

void detach_pid(struct task_struct *task, enum pid_type type)
{
    __change_pid(task, type, NULL);
}

static void __change_pid(struct task_struct *task, enum pid_type type,
            struct pid *new)
{
    struct pid_link *link;
    struct pid *pid;
    int tmp;

    link = &amp;task-&gt;pids[type];
    pid = link-&gt;pid;

    hlist_del_rcu(&amp;link-&gt;node);
    link-&gt;pid = new;

    for (tmp = PIDTYPE_MAX; --tmp &gt;= 0; )
        if (!hlist_empty(&amp;pid-&gt;tasks[tmp]))
            return;

    free_pid(pid);
}
</code></pre></figure>
<p>如果父进程在子进程之前退出，需要给子进程在当前的线程组内找一个进程作为父亲，如果失败，则让 init 做子进程的父进程。forget_original_parent() 调用 find_new_reaper() 来执行寻父过程：</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c">
static void forget_original_parent(struct task_struct *father)
{
    struct task_struct *p, *n, *reaper;
    LIST_HEAD(dead_children);

    exit_ptrace(father);

    write_lock_irq(&amp;tasklist_lock);
    reaper = find_new_reaper(father);

    list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) {
        struct task_struct *t = p;
        do {
            t-&gt;real_parent = reaper;
            if (t-&gt;parent == father) {
                BUG_ON(task_ptrace(t));
                t-&gt;parent = t-&gt;real_parent;
            }
        } while_each_thread(p, t);
        reparent_leader(father, p, &amp;dead_children);
    }
    write_unlock_irq(&amp;tasklist_lock);

    BUG_ON(!list_empty(&amp;father-&gt;children));

    list_for_each_entry_safe(p, n, &amp;dead_children, sibling) {
        list_del_init(&amp;p-&gt;sibling);
        release_task(p);
    }
}

static struct task_struct *find_new_reaper(struct task_struct *father)
{
    struct pid_namespace *pid_ns = task_active_pid_ns(father);
    struct task_struct *thread;

    thread = father;
    while_each_thread(father, thread) {
        if (thread-&gt;flags &amp; PF_EXITING)
            continue;
        if (unlikely(pid_ns-&gt;child_reaper == father))
            pid_ns-&gt;child_reaper = thread;
        return thread;
    }

    if (unlikely(pid_ns-&gt;child_reaper == father)) {
        write_unlock_irq(&amp;tasklist_lock);
        if (unlikely(pid_ns == &amp;init_pid_ns))
            panic(&quot;Attempted to kill init!&quot;);

        zap_pid_ns_processes(pid_ns);
        write_lock_irq(&amp;tasklist_lock);
        /*
         * We can not clear -&gt;child_reaper or leave it alone.
         * There may by stealth EXIT_DEAD tasks on -&gt;children,
         * forget_original_parent() must move them somewhere.
         */
        pid_ns-&gt;child_reaper = init_pid_ns.child_reaper;
    }

    return pid_ns-&gt;child_reaper;
}
</code></pre></figure>
  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/11/linux-kernel-serial-2/" title="link to Linux 内核系列－进程通信和同步">Linux 内核系列－进程通信和同步</a></h2>
       <p class="excerpt">本系列文章为阅读《现代操作系统》《UNIX 环境高级编程》和《Linux 内核设计与实现》所整理的读书笔记，源代码取自 Linux-kernel 2.6.34 版本并有做简化。概念竞争条件多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时许，称为竞争条件。忙等待的互斥几种实现互斥的方案：屏蔽中断在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，包括时钟中断。CPU 只有在发生中断的时候才会进行进程切换，这样在中断被屏蔽后 CPU 将不会被切换到其他进程...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-11-27 13:49:16 +0800" class="post-list__meta--date date">2016-11-27</time> &#8226; <span class="post-list__meta--tags tags">读书笔记</span><a class="btn-border-small" href=/2016/11/linux-kernel-serial-2/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/10/libuv-source-code/" title="link to Libuv 源码阅读">Libuv 源码阅读</a></h2>
       <p class="excerpt">花了几天时间读了下 libuv 的源码，整理成这篇文章。第一节是读官方教程做的笔记，主要是供自己备忘用，读者可以跳过。第二节解读 libuv 的源码，重点在 libuv 队列的实现和如何用线程池实现异步文件 IO。概念handles 和 requestslibuv 提供了两个抽象：handles 和 requests。handles 是 long－lived 的，会在其 active 的时候做特定的操作。requests 则为 short-lived 操作，request 可以独自执行或被...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-10-13 15:56:27 +0800" class="post-list__meta--date date">2016-10-13</time> &#8226; <span class="post-list__meta--tags tags">源码阅读</span><a class="btn-border-small" href=/2016/10/libuv-source-code/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://masutangu.com/2016/11/linux-kernel-serial-1/";
        this.page.identifier = "/2016/11/linux-kernel-serial-1/";
    };

    var disqus_shortname = 'masutangu';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://masutangu.com/">@masutangu</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/Masutangu/Masutangu.github.io">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
