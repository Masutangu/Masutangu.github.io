<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Elric 使用手册</title>
  <meta name="description" content="这篇文章正式介绍下我之前用 Python 实现的分布式任务框架 Elric，包括其API，架构，周边能力以及实现细节。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Elric 使用手册">
  <meta name="twitter:description" content="这篇文章正式介绍下我之前用 Python 实现的分布式任务框架 Elric，包括其API，架构，周边能力以及实现细节。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Elric 使用手册">
  <meta property="og:description" content="这篇文章正式介绍下我之前用 Python 实现的分布式任务框架 Elric，包括其API，架构，周边能力以及实现细节。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2016/07/elric-documentation/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://masutangu.lofter.com" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-07-07 15:02:11 +0800" itemprop="datePublished" class="post-meta__date date">2016-07-07</time> &#8226; <span class="post-meta__tags tags">个人项目</span>
    </div>
    <h1 class="post-title">Elric 使用手册</h1>
  </header>

  <section class="post">
    <p>这篇文章正式介绍下我之前用 Python 实现的分布式任务框架 <a href="https://github.com/Masutangu/Elric">Elric</a>，包括其API，架构，周边能力以及实现细节。</p>

<p>读者可以先阅读之前的这篇文章《<a href="http://masutangu.com/2015/08/elric-distributed-job-scheduler-by-python/">Python实现的分布式任务调度系统</a>》来了解Elric的起源和早期设计的思想。</p>

<h1>一. 简介</h1>

<p>Elric 是一个 Python 实现的简单的分布式任务框架。Master-Worker 架构，Worker 向 Master 提交任务和执行 Master 下发的任务。支持多种任务类型：即时任务，周期任务，crontab 任务和定时任务。
其实现参考了 <a href="https://apscheduler.readthedocs.io/en/latest/">Apscheduler</a>，Elric 的部分逻辑参考了 Apscheduler， 部分代码（trigger）取自 Apscheduler。</p>

<h1>二. API</h1>

<h2>Master</h2>

<ul>
<li><p>初始化和启动 Master</p>

<p>启动 Master 很简单，样例代码如下：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">rom master.rqextend import RQMasterExtend
rq_Master = RQMasterExtend()
rq_Master.start()
</code></pre></figure></li>
</ul>

<h2>Worker</h2>

<ul>
<li><p>初始化和启动 Worker</p>

<p>Worker 的构造函数稍微复杂一些：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">def __init__(self, name, listen_keys=None, Worker_num=2, timezone=None, logger_name=&#39;elric.Worker&#39;)
</code></pre></figure>
<ul>
<li>name：Worker 的名字，不同用途的 Worker 应该取不同的名字。</li>
<li>listen_keys：Worker 监听的任务队列名，类型为 list。</li>
<li>Worker_num：Worker 的进程池数。</li>
<li>timezone：时区，默认为 local。<br></li>
</ul>

<p>启动 Worker 将会开始从监听的任务队列里取任务来执行，初始化和启动 Worker 的样例代码如下：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">from Worker.rqueue import RQWorker
rq_Worker = RQWorker(name=&#39;test&#39;, listen_keys=[&#39;job1&#39;, &#39;job2&#39;])
rq_Worker.start()
</code></pre></figure>
<p>上述代码初始化一个名字为 test 的 Worker，它将从 job1，job2 这两个任务队列中取下任务来执行。</p></li>
<li><p>提交任务</p>

<p>提交任务的接口如下：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">def submit_job(self, func, job_key, args=None, kwargs=None, trigger=None, job_id=None,
               replace_exist=False, need_filter=False, **trigger_args)
</code></pre></figure>
<ul>
<li>func：提交该任务需要执行的函数。</li>
<li>job_key：该任务将提交的任务队列名。</li>
<li>args：提交的函数执行所需要的位置参数。</li>
<li>kwargs：提交的函数执行所需要的命名参数。</li>
<li>trigger：提交任务的执行时间信息，date 为定时任务，cron 为 crontab 任务、interval 为周期任务，为空则为即时任务。</li>
<li>job_id：提交任务的id，用于调试和去重。如果没有提供将自动生成一个随机id。</li>
<li>need_filter：是否去重。Master 使用 (job_key，job_id) 唯一标记一个任务。如果 need_filter 为 True，submit_job 时会 Master 会检查去重模块 dupefilter 是否有（job_key，job_id）任务成功执行的记录，如果已存在则被过滤。该特性主要用于爬虫。</li>
</ul></li>
</ul>

<h2>去重</h2>

<p>Elric 支持任务去重，通常这个特性用于爬虫，比如爬取过的页面无需再次爬取时，可以通过设置 need_filter 为 True 来实现：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">blog_url = &#39;http://masutangu.com/&#39;
rq_worker = RQWorker(name=&#39;crawler&#39;, listen_keys=[&#39;crawl_blog&#39;, ])
rq_worker.submit_job(crawl_blog, &#39;crawl_blog&#39;, args=[blog_url], job_id=blog_url)
</code></pre></figure>
<p>任务执行完成后，Master 的 dupefilter 模块会标记（&#39;crawl_blog&#39;，&#39;<a href="http://masutangu.com/">http://masutangu.com/</a>&#39; ）任务已经执行成功。之后如果 Master 再次接收到任务，会到 dupefilter 模块查询是否有相应的记录，如果存在则直接过滤该任务，不再下发。</p>

<h2>配置</h2>

<p><a href="https://github.com/Masutangu/Elric/blob/master/settings.py">settings.py</a> 文件的配置信息如下：</p>

<ul>
<li>DISTRIBUTED_LOCK_CONFIG：Master分布式锁的相关配置。</li>
<li>JOB_QUEUE_CONFIG：任务队列的相关配置。</li>
<li>FILTER_CONFIG：去重的相关配置。</li>
<li>JOB_STORE_CONFIG：任务存储的相关配置。</li>
<li>LOGGINGF_CONFIG：日志的相关配置。</li>
</ul>

<h2>样例代码</h2>
<figure class="highlight"><pre><code class="language-text" data-lang="text">from Worker.rqueue import RQWorker

def wapper_job():
    print &#39;run first job&#39;
    rq_Worker.submit_job(nest_job, &#39;job1&#39;, args=[&#39;hi i am nested job&#39;])

def nest_job(welcome):
    print welcome

def test_job(language=None):
    print &#39;my favorite language is {language}&#39;.format(language=language)

def test_date_job():
    print &#39;hello i am date job&#39;

def test_cron_job():
    print &#39;hello i am crontab job&#39;

if __name__ == &#39;__main__&#39;:
    # 初始化名字为 test 的 Worker ，监听 &#39;job1&#39; 和 &#39;job2&#39; 这两个任务队列
    rq_worker = RQWorker(name=&#39;test&#39;, listen_keys=[&#39;job1&#39;, &#39;job2&#39;])

    # 向 Master 提交任务，该任务将由 Master 在 2015-07-17 21:13:30 这个时间点通过 &#39;job1&#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_date_job 函数
    rq_worker.submit_job(test_date_job, &#39;job1&#39;, trigger=&#39;date&#39;, run_date=&#39;2015-07-17 21:13:30&#39;)

    # 向 Master 提交任务，该任务将每隔30秒由 Master 通过 &#39;job1&#39; 任务队列下发给 Worker ，Worker 拿到后将执行 wapper_job 函数
    rq_worker.submit_job(wapper_job, &#39;job1&#39;, trigger=&#39;interval&#39;, seconds=30)

    # 向 Master 提交任务，该任务为即时任务（没有提供trigger），将马上由Master 通过任务队列 &#39;job2&#39; 下发给 Worker ，Worker 拿到后将执行 test_job 函数
    rq_worker.submit_job(test_job, &#39;job2&#39;, kwargs={&#39;language&#39;: &#39;python&#39;})

    # 向 Master 提交任务，该任务将在每分钟的第7秒由 Master 通过 &#39;job2&#39; 任务队列下发给 Worker ，Worker 拿到后将执行 test_cron_job 函数
    rq_worker.submit_job(test_cron_job, &#39;job2&#39;, trigger=&#39;cron&#39;, second=7)

    # 启动 Worker，如果 &#39;job1&#39; 或 &#39;job2&#39; 有任务则拉取下来执行
    rq_worker.start()
</code></pre></figure>
<p>完整的demo可见<a href="https://github.com/Masutangu/Elric/tree/master/example">https://github.com/Masutangu/Elric/tree/master/example</a></p>

<h1>三. 架构</h1>

<p>Elric 架构图如下：
<img src="/assets/images/elric-documentation/illustration-1.png" width="800" /></p>

<p>运转流程如下（包含部分实现细节）：</p>

<ul>
<li>Worker 调用 submit_job 提交任务，该任务将存放在任务队列的 &#39;<strong>elric_submit_channel</strong>&#39; 队列中，等待 Master 处理。同时启动 Worker，Worker 将监听其感兴趣的任务队列，比如 &#39;job1&#39; 队列。</li>
<li><p>Master 从任务队列 &#39;<strong>elric_submit_channel</strong>&#39; 中拉取 Worker 提交的任务，然后做如下处理：</p>

<ul>
<li><p>去重处理：</p>

<p>首先判断任务的 need_filter 是否为 True，如果为 True，则由 dupefilter 模块去重，已经执行过的将被过滤掉。为 False 则跳过该步骤。  </p></li>
<li><p>非即时处理：</p>

<p>如果任务不是即时任务（ trigger 不为空），则将该任务存储到任务存储 jobstore 中，Master 有另一线程定时扫描 jobstore 取出到期任务来下发。如果为即时任务，则跳过该步骤。</p></li>
<li><p>任务下发：</p>

<p>将即时任务或到期任务下发到相应的任务队列，例如放到名为 &#39;job1&#39; 的任务队列。</p></li>
</ul></li>
<li><p>Worker 监听到 &#39;job1&#39; 任务队列有新任务，取出后交给 executor 来执行。</p></li>
</ul>

<h1>四. 周边能力</h1>

<p>任务的执行结果存放在 mongodb ，为了方便使用者查询和定位问题，我提供了一个简单粗糙的 web 服务：<a href="https://github.com/Masutangu/ElricStats">ElricStats</a>，通过他可以方便的查询每个任务执行的时间和结果。</p>

<h1>五. 实现细节</h1>

<h2>Master的分布式锁</h2>

<p>为了支持多机器部署Master，在某些操作需要有锁的机制来保证原子性，比如在查询 jobstore 并取出到期任务下发时，简化代码如下：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
    # 将任务下发到任务队列
    self._enqueue_job(job_key, serialized_job)

    # 获取任务的下次执行时间，并更新到 jobstore 
    job = Job.deserialize(serialized_job)
    last_run_time = Job.get_serial_run_times(job, now)
    job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
    self.update_job(job)
</code></pre></figure>
<p>如果在这个操作没有加锁保证原子性，将有可能下发重复的任务。这里我采用了redis实现的分布式锁来解决这个问题。其原理利用了 redis 的 setnx 命令，详细可以查看这篇文章《<a href="http://redis.io/topics/distlock">Distributed locks with Redis</a>》。</p>

<p>我把分布式锁封装成 Context Managers 的形式：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">class distributed_lock(object):
    def __init__(self, **config):
        self.config = config
        self.dlm = redlock.Redlock([config[&#39;server&#39;], ],
                                retry_count=config[&#39;retry_count&#39;],
                                retry_delay=config[&#39;retry_delay&#39;])
        self.dlm_lock = None

    def __enter__(self):
        while not self.dlm_lock:
            self.dlm_lock = self.dlm.lock(self.config[&#39;resource&#39;], 1000)
            if self.dlm_lock:
                break
            else:
                time.sleep(self.config[&#39;retry_delay&#39;])

    def __exit__(self, type, value, traceback):
        self.dlm.unlock(self.dlm_lock)
        self.dlm_lock = None
</code></pre></figure>
<p>这样就可以使用 with statement 来管理：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">with distributed_lock(**DISTRIBUTED_LOCK_CONFIG):
    for job_id, job_key, serialized_job in self.jobstore.get_due_jobs(now):
        # 将任务下发到任务队列
        self._enqueue_job(job_key, serialized_job)

        # 获取任务的下次执行时间，并更新到 jobstore 
        job = Job.deserialize(serialized_job)
        last_run_time = Job.get_serial_run_times(job, now)
        job.next_run_time = Job.get_next_trigger_time(job, last_run_time[-1])   
        self.update_job(job)
</code></pre></figure>
<h1>六. 后续优化</h1>

<p>Elric 目前来说还比较粗糙，后续有时间我希望对下面这几个方面做些优化：</p>

<ul>
<li>配置规范化：目前我的配置文件 settings.py （包括logging模块）的实现并不规范，后续希望参考 <a href="https://www.djangoproject.com/">Django</a> 的做法来实现配置管理。 </li>
<li>防雪崩机制优化：目前防雪崩机制比较简单，在任务队列满的时候 Master 会缓存一部分任务。后期改造成在下发的任务里带上任务的下发时间，Worker 取到任务后如果发现任务已经过期一段时间则直接抛弃。</li>
</ul>

  </section>
</article>

<section class="read-more">
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/07/python-note-1/" title="link to Python笔记">Python笔记</a></h2>
       <p class="excerpt">这篇文章整理了python相关的资料，包括性能优化、常见错误和高级用法。注：本文内容整理自网上博客，《Python Cookbook》等，非原创。性能优化1. 字典和列表Python 字典中使用了 hash table，因此查找操作的复杂度为 O(1)，而 list 实际是个数组，在 list 中，查找需要遍历整个 list，其复杂度为 O(n)，因此对成员的查找访问等操作字典要比 list 更快。from time import timet = time()list = [&#39;a&...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-07-06 18:56:31 +0800" class="post-list__meta--date date">2016-07-06</time> &#8226; <span class="post-list__meta--tags tags">编程语言</span><a class="btn-border-small" href=/2016/07/python-note-1/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://masutangu.com/2016/07/elric-documentation/";
        this.page.identifier = "/2016/07/elric-documentation/";
    };

    var disqus_shortname = 'masutangu';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2016-07-08 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="http://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
