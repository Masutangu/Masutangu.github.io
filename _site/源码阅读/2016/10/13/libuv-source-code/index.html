<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家  这里是 Masutangu 的个人博客。">
    <meta name="keywords"  content="Masutangu, Masutangu 的博客, Masutangu Blog, 博客, 个人网站, 互联网, 后端, Python, Go, C++">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Libuv 源码阅读 - Masutangu 的博客 | Masutangu Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="花了几天时间读了下 libuv 的源码，整理成这篇文章。&lt;a href = #section_1&gt;第一节&lt;/a&gt;是读官方教程做的笔记，主要是供自己备忘用，读者可以跳过。&lt;a href = #section_2&gt;第二节&lt;/a&gt;解读 libuv 的源码，重点在 libuv 队列的实现和如何用线程池实现异步文件 IO。

">
    
    <meta property="article:published_time" content="2016-10-13T15:56:27Z">
    
    
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar.jpg">
    <meta property="og:url" content="http://localhost:4000/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2016/10/13/libuv-source-code/">
    <meta property="og:site_name" content="Masutangu 的博客 | Masutangu Blog">
    
    <title>Libuv 源码阅读 - Masutangu 的博客 | Masutangu Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2016/10/13/libuv-source-code/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Masutangu</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">关于</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">归档</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>Libuv 源码阅读</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by Masutangu on October 13, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>花了几天时间读了下 libuv 的源码，整理成这篇文章。&lt;a href = #section_1&gt;第一节&lt;/a&gt;是读官方教程做的笔记，主要是供自己备忘用，读者可以跳过。&lt;a href = #section_2&gt;第二节&lt;/a&gt;解读 libuv 的源码，重点在 libuv 队列的实现和如何用线程池实现异步文件 IO。</p>

<h1 id="概念"><span id="section_1">概念</span></h1>

<h2 id="handles-和-requests">handles 和 requests</h2>
<p>libuv 提供了两个抽象：handles 和 requests。handles 是 long－lived 的，会在其 active 的时候做特定的操作。requests 则为 short-lived 操作，request 可以独自执行或被 handle 调用执行。</p>

<h2 id="io-loop">I/O loop</h2>
<p>I/O loop（或 event loop）是 libuv 的核心。每个 I/O loop 绑定单一的线程。</p>

<blockquote>
  <p>The libuv event loop (or any other API involving the loop or handles, for that matter) is not thread-safe except where stated otherwise.</p>
</blockquote>

<p>event loop 采用单线程异步 IO 的形式：所有网络操作都使用 non-blocking 套接字，并使用各个平台上性能最好的 poll 机制例如 linux 上的 epoll，OSX 的 kqueue 等等。</p>

<p><img src="/assets/images/libuv-source-code/illustration-1.png" width="800" /></p>

<p>I/O loop 的流程：</p>

<ul>
  <li>event loop 在每次循环周期开始前都会缓存当前时间，以减少时间相关的系统调用</li>
  <li>执行到期定时器的 callback</li>
  <li>执行上一轮循环推迟的 I/O callback</li>
  <li>执行 Idle handle 的 callback</li>
  <li>执行 Prepare handle 的 callback</li>
  <li>计算 poll timeout</li>
  <li>阻塞处理 I/O，超时时间为上一步计算的 poll timeout</li>
  <li>执行 Check handle 的 callback</li>
  <li>执行 Close callback</li>
</ul>

<blockquote>
  <p>libuv uses a thread pool to make asynchronous file I/O operations possible, but network I/O is always performed in a single thread, each loop’s thread.</p>
</blockquote>

<h2 id="file-io">File I/O</h2>
<p>libuv 的异步文件 I/O 是通过线程池实现的。</p>

<blockquote>
  <p>libuv provides a threadpool which can be used to run user code and get notified in the loop thread. <strong>This thread pool is internally used to run all filesystem operations</strong>, as well as getaddrinfo and getnameinfo requests.</p>
</blockquote>

<blockquote>
  <p>The threadpool is global and shared across all event loops. When a particular function makes use of the threadpool (i.e. when using <code class="highlighter-rouge">uv_queue_work()</code>) libuv preallocates and initializes the maximum number of threads allowed by UV_THREADPOOL_SIZE.</p>
</blockquote>

<blockquote>
  <p>libuv currently uses a global thread pool on which all loops can queue work on. 3 types of operations are currently run on this pool:</p>
</blockquote>

<blockquote>
  <ul>
    <li>Filesystem operations</li>
    <li>DNS functions (getaddrinfo and getnameinfo)</li>
    <li>User specified code via uv_queue_work()</li>
  </ul>
</blockquote>

<h2 id="主要结构体">主要结构体</h2>

<h3 id="uv_loop_t">uv_loop_t</h3>
<blockquote>
  <p>The event loop is the central part of libuv’s functionality. It takes care of polling for i/o and scheduling callbacks to be run based on different sources of events.</p>
</blockquote>

<p>uv_loop_t 执行的三种模式</p>

<ul>
  <li>
    <p><strong>UV_RUN_DEFAULT</strong></p>

    <p>Runs the event loop until there are no more active and referenced handles or requests. Returns non-zero if uv_stop() was called and there are still active handles or requests. Returns zero in all other cases.</p>
  </li>
  <li>
    <p><strong>UV_RUN_ONCE</strong></p>

    <p>Poll for i/o once. Note that this function blocks if there are no pending callbacks. Returns zero when done (no active handles or requests left), or non-zero if more callbacks are expected (meaning you should run the event loop again sometime in the future).</p>
  </li>
  <li>
    <p><strong>UV_RUN_NOWAIT</strong></p>

    <p>Poll for i/o once but don’t block if there are no pending callbacks. Returns zero if done (no active handles or requests left), or non-zero if more callbacks are expected (meaning you should run the event loop again sometime in the future).</p>
  </li>
</ul>

<h3 id="uv_handle_t">uv_handle_t</h3>
<blockquote>
  <p>uv_handle_t is the base type for all libuv handle types.</p>
</blockquote>

<blockquote>
  <p>Structures are aligned so that any libuv handle can be cast to uv_handle_t. All API functions defined here work with any handle type.</p>
</blockquote>

<ul>
  <li>
    <p><code class="highlighter-rouge">void uv_ref(uv_handle_t* handle)</code></p>

    <p>Reference the given handle. References are idempotent, that is, if a handle is already referenced calling this function again will have no effect.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">void uv_unref(uv_handle_t* handle)</code></p>

    <p>Un-reference the given handle. References are idempotent, that is, if a handle is not referenced calling this function again will have no effect.</p>
  </li>
</ul>

<p>uv_unref 主要用于计时器。<a href="https://nikhilm.github.io/uvbook/utilities.html#reference-count">例子在此</a>，摘抄如下：</p>

<blockquote>
  <p>These functions can be used to allow a loop to exit even when a watcher is active or to use custom objects to keep the loop alive.</p>
</blockquote>

<blockquote>
  <p>The latter can be used with interval timers. You might have a garbage collector which runs every X seconds, or your network service might send a heartbeat to others periodically, but you don’t want to have to stop them along all clean exit paths or error scenarios. Or you want the program to exit when all your other watchers are done. In that case just unref the timer immediately after creation so that if it is the only watcher running then uv_run will still exit.</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">gc_req</span><span class="p">;</span>
<span class="n">uv_timer_t</span> <span class="n">fake_job_req</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_req</span><span class="p">);</span>
    <span class="n">uv_unref</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gc_req</span><span class="p">);</span>

    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gc_req</span><span class="p">,</span> <span class="n">gc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

    <span class="c1">// could actually be a TCP download or something
</span>    <span class="n">uv_timer_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fake_job_req</span><span class="p">);</span>
    <span class="n">uv_timer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fake_job_req</span><span class="p">,</span> <span class="n">fake_job</span><span class="p">,</span> <span class="mi">9000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>We initialize the garbage collector timer, then immediately unref it. Observe how after 9 seconds, when the fake job is done, the program automatically exits, even though the garbage collector is still running.</p>
</blockquote>

<h3 id="uv_req_t">uv_req_t</h3>
<blockquote>
  <p>uv_req_t is the base type for all libuv request types.</p>
</blockquote>

<h1 id="代码解读"><span id="section_2">代码解读</span></h1>

<h2 id="队列">队列</h2>

<p>libuv 的队列是循环双向链表，队列在 libuv 中用到的地方很多，例如 event loop 用队列来存储 handle（handle_queue)，待监听的io事件（watcher_queue）等等。</p>

<h3 id="定义">定义</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">QUEUE</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="cp">#define QUEUE_NEXT(q)       (*(QUEUE **) &amp;((*(q))[0]))
#define QUEUE_PREV(q)       (*(QUEUE **) &amp;((*(q))[1]))
#define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT(QUEUE_PREV(q)))
#define QUEUE_NEXT_PREV(q)  (QUEUE_PREV(QUEUE_NEXT(q)))
</span>
<span class="cp">#define QUEUE_INIT(q)                                                         \
  do {                                                                        \
    QUEUE_NEXT(q) = (q);                                                      \
    QUEUE_PREV(q) = (q);                                                      \
  }                                                                           \
  while (0)
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>这段定义了 QUEUE 是元素类型为 void* 的数组，数组长度为 2。
如果按下面这样定义：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="cp">#define QUEUE_NEXT(q)       ((QUEUE *) ((*(q))[0]))
#define QUEUE_PREV(q)       ((QUEUE *) ((*(q))[1]))
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>返回值不是左值，在 QUEUE_INIT 函数中对 QUEUE_NEXT 和 QUEUE_PREV 的赋值会编译失败。
C/C++ 中类型转换有可能会返回左值（可以看 <a href="http://stackoverflow.com/questions/26508609/is-the-result-of-a-cast-an-rvalue">stackoverflow</a> 的讲解)：</p>

<blockquote>
  <p>The result of the expression (T) cast-expression is of type T. The result is an lvalue if T is an lvalue reference type or an rvalue reference to function type and an xvalue if T is an rvalue reference to object type; <strong>otherwise the result is a prvalue.</strong>[ Note: if T is a non-class type that is cv-qualified, the cv-qualifiers are ignored when determining the type of the resulting prvalue; see 3.10. —end note ]</p>
</blockquote>

<p>因此需要先将 ((*(q))[0])) 取址再解引用（解引用返回左值）。</p>

<h3 id="接口">接口</h3>

<p>下面是 QUEUE 几个重要的接口：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre>
<span class="c1">// 取出数据，具体例子可参考：https://gist.github.com/bodokaiser/5657156
</span><span class="cp">#define QUEUE_DATA(ptr, type, field)                                          \
  ((type *) ((char *) (ptr) - offsetof(type, field)))
</span>
<span class="c1">// 将 n 队列的元素添加到 h 队列，保留 h 队列原先的元素。注意操作后 n 队列的结构被破坏，不能在遍历 n 队列
</span><span class="cp">#define QUEUE_ADD(h, n)                                                       \
  do {                                                                        \
    QUEUE_PREV_NEXT(h) = QUEUE_NEXT(n);                                       \
    QUEUE_NEXT_PREV(n) = QUEUE_PREV(h);                                       \
    QUEUE_PREV(h) = QUEUE_PREV(n);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
  }                                                                           \
  while (0)
</span>
<span class="c1">// QUEUE_MOVE 的 helper 函数
</span><span class="cp">#define QUEUE_SPLIT(h, q, n)                                                  \
  do {                                                                        \
    QUEUE_PREV(n) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(n) = (n);                                                 \
    QUEUE_NEXT(n) = (q);                                                      \
    QUEUE_PREV(h) = QUEUE_PREV(q);                                            \
    QUEUE_PREV_NEXT(h) = (h);                                                 \
    QUEUE_PREV(q) = (n);                                                      \
  }                                                                           \
  while (0)
</span>
<span class="c1">// 将 h 队列的元素添加到 n 队列， h 队列被清空，n 队列原先的元素也被清空
</span><span class="cp">#define QUEUE_MOVE(h, n)                                                      \
  do {                                                                        \
    if (QUEUE_EMPTY(h))                                                       \
      QUEUE_INIT(n);                                                          \
    else {                                                                    \
      QUEUE* q = QUEUE_HEAD(h);                                               \
      QUEUE_SPLIT(h, q, n);                                                   \
    }                                                                         \
  }                                                                           \
  while (0)
</span>
<span class="c1">// 添加元素 q 到 h 队列的尾部，QUEUE_PREV(h) 为原先队列的 tail 节点
</span><span class="cp">#define QUEUE_INSERT_TAIL(h, q)                                               \
  do {                                                                        \
    QUEUE_NEXT(q) = (h);                                                      \
    QUEUE_PREV(q) = QUEUE_PREV(h);                                            \
    QUEUE_PREV_NEXT(q) = (q);                                                 \
    QUEUE_PREV(h) = (q);                                                      \
  }                                                                           \
  while (0)
</span></pre></td></tr></tbody></table></code></pre></div></div>

<p>上面提到了 QUEUE 是一个循环链表。定义 h 为队列的哨兵节点，则 QUEUE_NEXT(h) 指向队列的 head 节点，QUEUE_PREV(h) 指向队列的 tail 节点。</p>

<p>结合图例来看看 QUEUE_INSERT_TAIL 的实现。</p>

<p>原队列，因为只有一个元素（h节点为哨兵节点，不算在内），因此其即是 head 也是 tail：
<img src="/assets/images/libuv-source-code/illustration-2.png" width="800" /></p>

<p>新增一个新元素后如下所示：
<img src="/assets/images/libuv-source-code/illustration-3.png" width="800" /></p>

<p>下面是 QUEUE_MOVE 的图例。
h 队列 和 n 队列 QUEUE_MOVE 操作前如下图：
<img src="/assets/images/libuv-source-code/illustration-4.png" width="800" /></p>

<p>QUEUE_MOVE 后，h 队列被清空，n 队列的哨兵节点连接到原 h 队列的 head 和 tail：
<img src="/assets/images/libuv-source-code/illustration-5.png" width="800" /></p>

<p>最后是 QUEUE_ADD 的图例，原理就是将 n 队列的 head 和 h 队列的 tail 相连，并把 h 队列的 tail 重置指向 n 队列的 tail：
<img src="/assets/images/libuv-source-code/illustration-6.png" width="800" /></p>

<h2 id="epoll-事件管理">epoll 事件管理</h2>
<p>IO 事件都会调用 <code class="highlighter-rouge">uv__io_start</code> 函数，该函数将需要监听的事件保存到 event loop 的 watcher_queue 队列中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">uv__io_start</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="n">uv__io_t</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">QUEUE_EMPTY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">watcher_queue</span><span class="p">))</span>
    <span class="n">QUEUE_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">watcher_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">watcher_queue</span><span class="p">);</span>  <span class="c1">// 添加到 loop-&gt;watcher_queue 队列
</span>  
  <span class="p">...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>然后在 event loop 的循环中，会调用 <code class="highlighter-rouge">uv__io_poll</code>。该函数将 loop-&gt;watcher_queue 队列中的事件取出，添加到 epoll 进行监听：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">uv__io_poll</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">uv__io_t</span><span class="o">*</span> <span class="n">w</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">QUEUE_EMPTY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">watcher_queue</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 遍历取出 loop-&gt;watcher_queue 队列中待监听的事件，直至队列为空
</span>    <span class="n">q</span> <span class="o">=</span> <span class="n">QUEUE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">watcher_queue</span><span class="p">);</span>
    <span class="n">QUEUE_REMOVE</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">QUEUE_INIT</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">QUEUE_DATA</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">uv__io_t</span><span class="p">,</span> <span class="n">watcher_queue</span><span class="p">);</span>  <span class="c1">// 取出 uv__io_t 结构，该结构保存了用户注册的回调函数
</span>  
    <span class="n">e</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">pevents</span><span class="p">;</span>
    <span class="n">e</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">op</span> <span class="o">=</span> <span class="n">UV__EPOLL_CTL_ADD</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">op</span> <span class="o">=</span> <span class="n">UV__EPOLL_CTL_MOD</span><span class="p">;</span>

    <span class="cm">/* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching
     * events, skip the syscall and squelch the events after epoll_wait().
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv__epoll_ctl</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">backend_fd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 添加到 epoll
</span>      <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span>
        <span class="n">abort</span><span class="p">();</span>

      <span class="n">assert</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">UV__EPOLL_CTL_ADD</span><span class="p">);</span>

      <span class="cm">/* We've reactivated a file descriptor that's been watched before. */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">uv__epoll_ctl</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">backend_fd</span><span class="p">,</span> <span class="n">UV__EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">))</span>
        <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">w</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">pevents</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="p">...</span> 
  
  
  <span class="c1">// 阻塞等待 epoll 返回直到超时
</span>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">no_epoll_wait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">sigmask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">no_epoll_pwait</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">nfds</span> <span class="o">=</span> <span class="n">uv__epoll_pwait</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">backend_fd</span><span class="p">,</span>
                             <span class="n">events</span><span class="p">,</span>
                             <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">events</span><span class="p">),</span>
                             <span class="n">timeout</span><span class="p">,</span>
                             <span class="n">sigmask</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">ENOSYS</span><span class="p">)</span>
        <span class="n">no_epoll_pwait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">nfds</span> <span class="o">=</span> <span class="n">uv__epoll_wait</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">backend_fd</span><span class="p">,</span>
                            <span class="n">events</span><span class="p">,</span>
                            <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">events</span><span class="p">),</span>
                            <span class="n">timeout</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">ENOSYS</span><span class="p">)</span>
        <span class="n">no_epoll_wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
    
    <span class="n">loop</span><span class="o">-&gt;</span><span class="n">watchers</span><span class="p">[</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">nwatchers</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">events</span><span class="p">;</span>  <span class="c1">// 将 events 保存在 loop-&gt;watchers，为了在 uv__io_close 中可以将对应 fd 的 event 删掉
</span>    <span class="n">loop</span><span class="o">-&gt;</span><span class="n">watchers</span><span class="p">[</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">nwatchers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">nfds</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pe</span> <span class="o">=</span> <span class="n">events</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

      <span class="cm">/* Skip invalidated events, see uv__platform_invalidate_fd */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

      <span class="n">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="n">loop</span><span class="o">-&gt;</span><span class="n">nwatchers</span><span class="p">);</span>

      <span class="n">w</span> <span class="o">=</span> <span class="n">loop</span><span class="o">-&gt;</span><span class="n">watchers</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* File descriptor that we've stopped watching, disarm it.
         *
         * Ignore all errors because we may be racing with another thread
         * when the file descriptor is closed.
         */</span>
        <span class="n">uv__epoll_ctl</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">backend_fd</span><span class="p">,</span> <span class="n">UV__EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">pe</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="cm">/* Give users only events they're interested in. Prevents spurious
       * callbacks when previous callback invocation in this loop has stopped
       * the current watcher. Also, filters out events that users has not
       * requested us to watch.
       */</span>
      <span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">pevents</span> <span class="o">|</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>

      <span class="cm">/* Work around an epoll quirk where it sometimes reports just the
       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to
       * move forward, we merge in the read/write events that the watcher
       * is interested in; uv__read() and uv__write() will then deal with
       * the error or hangup in the usual fashion.
       *
       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user
       * reads the available data, calls uv_read_stop(), then sometime later
       * calls uv_read_start() again.  By then, libuv has forgotten about the
       * hangup and the kernel won't report EPOLLIN again because there's
       * nothing left to read.  If anything, libuv is to blame here.  The
       * current hack is just a quick bandaid; to properly fix it, libuv
       * needs to remember the error/hangup event.  We should get that for
       * free when we switch over to edge-triggered I/O.
       */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">==</span> <span class="n">POLLERR</span> <span class="o">||</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">==</span> <span class="n">POLLHUP</span><span class="p">)</span>
        <span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|=</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">pevents</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLOUT</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Run signal watchers last.  This also affects child process watchers
         * because those are implemented in terms of signal watchers.
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_io_watcher</span><span class="p">)</span>
          <span class="n">have_signals</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span>
          <span class="n">w</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pe</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>  <span class="c1">// 调用用户注册的回调
</span>
        <span class="n">nevents</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  
    <span class="n">loop</span><span class="o">-&gt;</span><span class="n">watchers</span><span class="p">[</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">nwatchers</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">loop</span><span class="o">-&gt;</span><span class="n">watchers</span><span class="p">[</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">nwatchers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="线程池实现异步文件-io">线程池实现异步文件 IO</h2>

<p>libuv 中文件操作的异步 IO 是通过线程池实现的。原理是将文件操作由工作线程来完成，当操作完成后工作线程通过 fd 通知主线程（该 fd 同样由 epoll 管理），主线程监听该 fd，当有 epoll 事件时根据层层回调，最终会调用到用户注册的回调函数。</p>

<p>下面看看这块逻辑，所有文件操作都调用了 POST 定义的宏。POST 判断是否注册了回调，如果有则表示该操作为异步调用，此时调用 <code class="highlighter-rouge">uv__work_submit</code> 向线程池提交任务。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="cp">#define POST                                                                  \
  do {                                                                        \
    if (cb != NULL) {                                                         \
      uv__work_submit(loop, &amp;req-&gt;work_req, uv__fs_work, uv__fs_done);        \
      return 0;                                                               \
    }                                                                         \
    else {                                                                    \
      // 回调为 null 是同步调用                                                  \
      uv__fs_work(&amp;req-&gt;work_req);                                            \
      return req-&gt;result;                                                     \
    }                                                                         \
  }                                                                           \
  while (0)
</span>
<span class="c1">// 操作完成后的回调函数
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">uv__fs_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uv_fs_t</span><span class="o">*</span> <span class="n">req</span><span class="p">;</span>

  <span class="n">req</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">uv_fs_t</span><span class="p">,</span> <span class="n">work_req</span><span class="p">);</span>
  <span class="n">uv__req_unregister</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">loop</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECANCELED</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">req</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECANCELED</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">req</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>  <span class="c1">// 调用用户注册的回调
</span><span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">uv__work_submit</code> 先调用 <code class="highlighter-rouge">init_once</code> 初始化工作线程池，再调用 <code class="highlighter-rouge">post</code> 提交任务给工作线程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">uv__work_submit</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                     <span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span>
                     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">),</span>
                     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">uv_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">once</span><span class="p">,</span> <span class="n">init_once</span><span class="p">);</span>
  <span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span><span class="p">;</span>
  <span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span> <span class="o">=</span> <span class="n">work</span><span class="p">;</span>
  <span class="n">w</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
  <span class="n">post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>

  <span class="n">nthreads</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">default_threads</span><span class="p">);</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">"UV_THREADPOOL_SIZE"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">nthreads</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">nthreads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">&gt;</span> <span class="n">MAX_THREADPOOL_SIZE</span><span class="p">)</span>
    <span class="n">nthreads</span> <span class="o">=</span> <span class="n">MAX_THREADPOOL_SIZE</span><span class="p">;</span>

  <span class="n">threads</span> <span class="o">=</span> <span class="n">default_threads</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nthreads</span> <span class="o">&gt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">default_threads</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="n">uv__malloc</span><span class="p">(</span><span class="n">nthreads</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">threads</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nthreads</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">default_threads</span><span class="p">);</span>
      <span class="n">threads</span> <span class="o">=</span> <span class="n">default_threads</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">uv_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">))</span>  <span class="c1">// 初始化条件变量
</span>    <span class="n">abort</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">uv_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">))</span>  <span class="c1">// 初始化互斥锁
</span>    <span class="n">abort</span><span class="p">();</span>

  <span class="n">QUEUE_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv_thread_create</span><span class="p">(</span><span class="n">threads</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>  <span class="c1">// 创建工作线程
</span>      <span class="n">abort</span><span class="p">();</span>

  <span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 工作线程
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">;</span>
  <span class="n">QUEUE</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">QUEUE_EMPTY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">idle_threads</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">uv_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>   <span class="c1">// wq 保存任务队列，当 wq 为空时阻塞等待任务，有新任务提交就会唤醒该 worker
</span>      <span class="n">idle_threads</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">QUEUE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">exit_message</span><span class="p">)</span>
      <span class="n">uv_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">QUEUE_REMOVE</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
      <span class="n">QUEUE_INIT</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>  <span class="cm">/* Signal uv_cancel() that the work req is
                             executing. */</span>
    <span class="p">}</span>

    <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">exit_message</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">QUEUE_DATA</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uv__work</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
    <span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>   <span class="c1">// work 执行文件操作
</span>
    <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>
    <span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* Signal uv_cancel() that the work req is done
                        executing. */</span>
    <span class="n">QUEUE_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>  <span class="c1">// 将已完成的 uv__work 添加到 loop-&gt;wq 队列
</span>    <span class="n">uv_async_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_async</span><span class="p">);</span>  <span class="c1">// 通知主线程该任务已经执行完成
</span>    <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 提交任务 
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">post</span><span class="p">(</span><span class="n">QUEUE</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">QUEUE_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>  <span class="c1">// 将任务提交到 wq 队列
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">idle_threads</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">uv_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 有空闲工作线程时就唤醒 worker
</span>  <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>最后看看工作线程和主线程的通信，在文件操作完成后，工作线程调用 <code class="highlighter-rouge">uv__async_send</code> ，该函数会往 wa-&gt;wfd 或 wa-&gt;io_watcher.fd 写一个空子节：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">uv_async_send</span><span class="p">(</span><span class="n">uv_async_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Do a cheap read first. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cmpxchgi</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">uv__async_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">async_watcher</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">uv__async_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">uv__async</span><span class="o">*</span> <span class="n">wa</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">;</span>
  <span class="kt">ssize_t</span> <span class="n">len</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">buf</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
  <span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">wfd</span><span class="p">;</span>

<span class="cp">#if defined(__linux__)
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">wa</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>  <span class="cm">/* eventfd */</span>
  <span class="p">}</span>
<span class="cp">#endif
</span>
  <span class="k">do</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

  <span class="n">abort</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>主线程监听 io_watcher.fd，当有 epoll 事件时回调的顺序如下：</p>

<p>调用 uv__io_t 的 cb 即 <code class="highlighter-rouge">uv__async_io</code> –&gt; 调用 uv__async 的 cb 即 <code class="highlighter-rouge">uv__async_event</code>  –&gt; 调用 uv_async_t 的 cb 即 <code class="highlighter-rouge">uv__work_done</code> –&gt; 调用 uv__work 的 done 即用户提交的回调函数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">uv_loop_init</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">uv_async_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_async</span><span class="p">,</span> <span class="n">uv__work_done</span><span class="p">);</span>  <span class="c1">// 初始化 async 
</span>  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">uv__work_done</span><span class="p">(</span><span class="n">uv_async_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">;</span>
  <span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">;</span>
  <span class="n">QUEUE</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">QUEUE</span> <span class="n">wq</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">loop</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">uv_loop_t</span><span class="p">,</span> <span class="n">wq_async</span><span class="p">);</span>
  <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>
  <span class="n">QUEUE_MOVE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>  <span class="c1">// 因为访问 loop-&gt;wq 需要锁，为了避免长时间锁，所以拷贝一份副本出来，下面的遍历直接操作该副本
</span>  <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">QUEUE_EMPTY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 遍历 loop-&gt;wq 的副本
</span>    <span class="n">q</span> <span class="o">=</span> <span class="n">QUEUE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
    <span class="n">QUEUE_REMOVE</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uv__work</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span> <span class="o">==</span> <span class="n">uv__cancelled</span><span class="p">)</span> <span class="o">?</span> <span class="n">UV_ECANCELED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">w</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>  <span class="c1">// 调用 done，即 uv__fs_done 函数，最终会调用用户注册的回调
</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//  uv__async_start 函数会调用 uv__io_start，监听 wa-&gt;io_watcher.fd
</span><span class="kt">int</span> <span class="nf">uv_async_init</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="n">uv_async_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span> <span class="n">uv_async_cb</span> <span class="n">async_cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">err</span> <span class="o">=</span> <span class="n">uv__async_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">async_watcher</span><span class="p">,</span> <span class="n">uv__async_event</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">uv__handle_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">,</span> <span class="n">UV_ASYNC</span><span class="p">);</span>
  <span class="n">handle</span><span class="o">-&gt;</span><span class="n">async_cb</span> <span class="o">=</span> <span class="n">async_cb</span><span class="p">;</span>
  <span class="n">handle</span><span class="o">-&gt;</span><span class="n">pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">QUEUE_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">async_handles</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
  <span class="n">uv__handle_start</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 创建 wa-&gt;io_watcher.fd 
</span><span class="kt">int</span> <span class="nf">uv__async_start</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uv__async</span><span class="o">*</span> <span class="n">wa</span><span class="p">,</span> <span class="n">uv__async_cb</span> <span class="n">cb</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">.</span><span class="n">fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="c1">// 下面一大段是创建 io_watcher.fd 的逻辑
</span>  <span class="n">err</span> <span class="o">=</span> <span class="n">uv__async_eventfd</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">uv__make_pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">,</span> <span class="n">UV__F_NONBLOCK</span><span class="p">);</span>
<span class="cp">#if defined(__linux__)
</span>    <span class="cm">/* Save a file descriptor by opening one of the pipe descriptors as
     * read/write through the procfs.  That file descriptor can then
     * function as both ends of the pipe.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

      <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"/proc/self/fd/%d"</span><span class="p">,</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">uv__open_cloexec</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uv__close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">uv__close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
        <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="cp">#endif
</span>  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">uv__io_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">,</span> <span class="n">uv__async_io</span><span class="p">,</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// 注册 async io 事件的 callback 为 uv__async_io
</span>  <span class="n">uv__io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wa</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">,</span> <span class="n">POLLIN</span><span class="p">);</span>  <span class="c1">// 将该 io_watcher 添加到 loop-&gt;watcher_queue，参考上文的 uv__io_start 
</span>  <span class="n">wa</span><span class="o">-&gt;</span><span class="n">wfd</span> <span class="o">=</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">wa</span><span class="o">-&gt;</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span><span class="p">;</span>  <span class="c1">// 注册 uv__async 的 cb 为 uv__async_event
</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2016/10/05/learn-libco/" data-toggle="tooltip" data-placement="top" title="浅读 Libco">
                        Previous<br>
                        <span>浅读 Libco</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/11/27/linux-kernel-serial-1/" data-toggle="tooltip" data-placement="top" title="Linux 内核系列－进程">
                        Next<br>
                        <span>Linux 内核系列－进程</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://blog.zhiheng.io">onlyice</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/masutangu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://www.instagram.com/masutanguu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Masutangu 2018
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-77236140-1';
    var _gaDomain = 'masutangu.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
