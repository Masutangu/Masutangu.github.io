<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>MIT 6.824 学习笔记（三）</title>
  <meta name="description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="MIT 6.824 学习笔记（三）">
  <meta name="twitter:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="MIT 6.824 学习笔记（三）">
  <meta property="og:description" content="本系列文章是对 MIT 6.824 课程的学习笔记。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://masutangu.com/2017/12/mit-6824-note-3/">
  <link rel="alternate" type="application/rss+xml" title="Masutangu" href="http://masutangu.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Masutangu 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Masutangu logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Masutangu" class="blog-button">Masutangu</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">长风破浪会有时 直挂云帆济沧海</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">也許我這一生　始終在追逐那顆九號球</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://500px.me/community/user-details/5cc3fb7c1480fb4fc2140a09627457614" target="_blank" title="Life">生活</a></li>
                
                  <li class="navigation__item"><a href="https://about.me/masutangu" target="_blank" title="About me">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/masutangu" title="@masutangu 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:masutangu.cs@gmail.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-12-02 15:19:31 +0800" itemprop="datePublished" class="post-meta__date date">2017-12-02</time> &#8226; <span class="post-meta__tags tags">读书笔记</span>
    </div>
    <h1 class="post-title">MIT 6.824 学习笔记（三）</h1>
  </header>

  <section class="post">
    <p>本系列文章是对 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">MIT 6.824</a> 课程的学习笔记。</p>

<h1>Spinnaker</h1>

<h2>Introduction</h2>

<blockquote>
<p>Spinnaker is an experimental datastore that is designed to run on a large cluster of commodity servers in a single datacenter. This paper describes Spinnaker’s Paxos-based replication protocol. The use of Paxos ensures that a data partition in Spinnaker will be available for reads and writes as long a majority of its replicas are alive.</p>
</blockquote>

<p>实现持续可用性的一个解决方案是<strong>主从复制</strong>，但主从复制存在以下缺陷：</p>

<p><img src="/assets/images/mit-6824-note-3/illustration-1.png" width="800" /></p>

<p>在上图的例子中，主从节点都从 LSN=10 开始（a），之后 slave 节点挂了（b），master 节点继续接收写请求，一直到 LSN=20。之后 master 节点也挂了（c），之后 slave 节点恢复（d），然而，在此时 slave 节点不能接收任何读写请求因为它缺失了 LSN=11 到LSN＝20 之间的记录。如果要避免这种情况，只有在任意节点挂掉的时候，都阻塞写请求。但这样就降低了整个系统的 availability。</p>

<p>分布式系统中，<strong>一致性模型描述了如何使不同的 relicas 保持同步</strong>。<strong>强一致性</strong>保证了所有的 replicas 都是一致的，但要实现强一致性需要牺牲 availability 或网络分区容忍性。CAP 理论提出 <strong>Consistency</strong>、<strong>Availability</strong> 和 <strong>Partition tolerance</strong> 三者最多只能同时满足两项。</p>

<p>比如 Dynamo 这样的系统，使用<strong>最终一致性</strong>模型来提供高可用性和分区容忍性。Dynamo 是一个 AP 系统，牺牲了 Consistency。</p>

<p>Spinnaker 使用基于 Paxos 的协议来实现日志提交和故障恢复。Paxos 确保了系统在大多数节点存活的情况下可以运作。Spinnaker 是一个 CA 系统，用于单一的 datacenter，并使用另外的 replication strategy 来保证跨 datacenter 的容错性。 </p>

<h2>Related work</h2>

<p><strong>Two-phase commit (2PC)</strong> 是保持 replicas 一致的一种方式。但 2PC 更偏向于将每个 participant 当作一个独立的资源管理者，而不仅仅是 replica。使用 2PC 来实现 replication 有些 overkill，并且还有不少缺陷。首先单一节点失败会导致系统 abort。其次每个 transaction 都发起 2PC 会导致极差的性能。每次 2PC 都需要两次磁盘强制写和传输两条信息的时延。最后，2PC 在 coordinator 挂掉时无法运作。</p>

<p>Amazon 的 Dynamo 通过<strong>分布式时钟</strong>来解决最终一致性的问题。</p>

<p>Google 的 Bigtable 提供了强一致性，和 spinnaker 不同的是，Bigtable 依赖 GFS 来存储数据和日志，还有实现 replication。这样每个 transaction 的 workload 就加重了（需要和 gfs 的 master 交互）。</p>

<h2>Architecture</h2>

<blockquote>
<p>Like Bigtable and PNUTS, Spinnaker distributes the rows of a table across its cluster using range partitioning. Each node is assigned a base key range, which is replicated on the next N − 1 nodes (N = 3 by default).</p>
</blockquote>

<p><img src="/assets/images/mit-6824-note-3/illustration-2.png" width="800" /></p>

<blockquote>
<p>Each group of nodes involved in replicating a key range is denoted as a <strong>cohort</strong>. Note that cohorts overlap.</p>
</blockquote>

<p>每个日志由一个 LSN 唯一的标记。Commit queue 是在内存的数据结构，用于存放 pending writes。写操作只有在接收到大多数 cohort 的 ack 之后才能提交。在此之前都存放在 commit queue 中。</p>

<p><img src="/assets/images/mit-6824-note-3/illustration-3.png" width="800" /></p>

<p>已经提交的写操作存于 memtable 中，并被定期刷到被称为 SSTable 的 immutable disk structure。SSTable 会被定期合并以提升读性能并删除不需要的数据。</p>

<h2>The replication protocol</h2>

<p><img src="/assets/images/mit-6824-note-3/illustration-4.png" width="800" /></p>

<p>提交一个写操作需要三次日志强制写和四条信息交互，不过大多数操作都是重叠的（可以并行）。</p>

<h2>Recovery</h2>

<p>Follower 的恢复需要两个阶段：<strong>local recovery</strong> 和 <strong>catch up</strong>。定义 f.cmt 表示 follower 的最后一个提交日志的 LSN，f.lst 表示 follower 的最后一个日志的 LSN。Local recovery 阶段，follower 从最近一次 checkpoint 开始重新执行日志直到 f.cmt，之后进入 catch up 阶段。Catch up 阶段，follower 通知 leader 自己的 f.cmt，leader 回复 f.cmt 之后所有的 commit writes。Leader 将会阻塞所有新的写请求直到 follower 已经跟上。</p>

<p>当 leader 挂掉，新的 leader 将被选举，并且会确保新的 leader 会包含所有已提交的写操作。在老的 leader 挂掉时，有可能其提交的写操作在某些 followers 还处于 pending 的状态。新 leader 将使用下图的算法，继续提交所有 unresolved 写操作。</p>

<p><img src="/assets/images/mit-6824-note-3/illustration-5.png" width="800" /></p>

<h2>Leader election</h2>

<p>选举算法如下图：</p>

<p><img src="/assets/images/mit-6824-note-3/illustration-6.png" width="800" /></p>

<h1>Dynamo: Amazon’s Highly Available Key-value Store</h1>

<h2>Introduction</h2>

<p>一个系统的<strong>可靠性</strong>和<strong>可扩展性</strong>取决于如何管理应用状态。Amazon 采用一种高度去中心化，松耦合，由数百个服务组成的面向服务架构。在这种环境中尤其需要一个高可用的存储技术。</p>

<p>Dynamo 被设计用于管理服务状态，要求具备非常高的可靠性，而且需要严格控制<strong>可用性、一致性、成本效益和性能</strong>的之间的权衡。</p>

<p>Amazon 服务平台中许多服务只需要主键访问数据存储。通常关系数据库模式会导致效率低下，且可扩展性和可用性也有限。Dynamo 提供了一个简单且唯一的主键接口，以满足这些应用的要求。</p>

<p>Dynamo 综合一些著名的技术来实现可伸缩性和可用性：使用<strong>一致性哈希</strong>划分和复制数据，一致性由<strong>对象版本</strong>来实现。更新时副本之间的一致性是由<strong>类似仲裁（quorum-like）</strong>的技术和<strong>去中心化的副本同步协议</strong>来保证。Dynamo 采用了<strong>基于 gossip</strong> 的分布式故障检测和 membership protocol。</p>

<h2>System Assumptions and Requirements</h2>

<p>Dynamo 的目标应用程序是通过较弱的一致性（ACID中的“C”）来达到高可用性。Dynamo 不提供任何数据隔离（ACID中的“I”）保证，只允许单一主键更新。</p>

<h2>Design Considerations</h2>

<p>对于容易出现服务器和网络故障的系统，可使用<strong>乐观复制</strong>来提高系统的可用性，数据变化允许在后台发送到副本，同时容忍网络断开。这种做法带来的挑战是如何检测和协调由此引发的冲突。协调的过程引入了两个问题：<strong>何时协调</strong>以及<strong>谁负责协调</strong>。Dynamo 被设计成<strong>最终一致性（eventually consistent）</strong>的数据存储，所有的更新操作最终会分发到所有副本。</p>

<p>一个重要的设计考虑的因素是何时去协调更新操作冲突，例如是在读还是写过程中协调冲突。许多传统 data store 在写的过程中协调冲突，从而保持读的复杂度相对简单。另一方面，<strong>Dynamo 的目标是“永远可写”</strong>。对于 Amazon 许多服务来讲，拒绝客户的更新操作可能导致糟糕的客户体验。这迫使我们<strong>将协调冲突的复杂性推给“读”</strong>，以确保“写”永远不会拒绝。</p>

<p>其他重要的设计原则：</p>

<ul>
<li><p><strong>增量的可扩展性（Incremental scalability）</strong></p>

<p>Dynamo 需要能够水平扩展一台存储主机，而对系统操作者和系统本身的影响很小。</p></li>
<li><p><strong>对称性（Symmetry）</strong></p>

<p>每个 Dynamo 节点应该有一样的责任，不应该存在有区别或具备特殊的角色或额外的责任的节点。根据我们的经验，对称性(symmetry)简化了系统的配置和维护。</p></li>
<li><p><strong>去中心化（Decentralization）</strong></p>

<p>是对对称性的延伸，设计应采用有利于去中心化而不是集中控制的技术。</p></li>
<li><p><strong>异质性（Heterogeneity）</strong></p>

<p>系统必须能够利用其运行所在的基础设施的异质性。例如，负载的分配必须与各个独立的服务器的能力成比例。这样就可以一次只增加一个高处理能力的节点，而无需一次升级所有的主机。</p></li>
</ul>

<h2>Partitioning Algorithm</h2>

<p>Dynamo 的关键设计要求之一是<strong>增量可扩展性</strong>，这需要一个机制来将数据动态划分到系统中的节点上。Dynamo 的分区方案依赖于一致哈希。<strong>一致性哈希的主要优点是节点的新增或减少只影响其最直接的邻居</strong>，而对其他节点没影响。</p>

<p>基本的一致性哈希算法存在一些不足：</p>

<ul>
<li>环上​​的节点随机分配位置导致数据和负载的不均匀分布</li>
<li>基本算法无法满足节点性能的<strong>异质性（Heterogeneity）</strong></li>
</ul>

<p>为了解决这些问题，<strong>Dynamo 引入虚拟节点</strong>：每个节点被分配到环上多点，而不是只映射到环上的一个单点。系统中每个节点对多个虚拟节点负责。</p>

<p>使用虚拟节点具有以下优点：</p>

<ul>
<li>如果一个节点不可用，这个节点的负载将均匀地分散给其余的可用节点</li>
<li>当一个节点再次可用，或者是新添加到系统中，the newly available node accepts a roughly equivalent amount of load from each of the other available nodes. </li>
<li>一个节点负责的虚拟节点数目由其处理能力来决定（heterogeneity）</li>
</ul>

<h2>Replication</h2>

<p>每个键 K 被分配到一个协调器节点。协调器节点负责其管辖范围内的数据的复制。除了在本地存储每个 key 外，协调器节点也将 key 复制到环上顺时针方向的 N-1 后继节点。系统中每个节点负责环上的从其自己到第 N 个前继节点间的区域。</p>

<p>负责存储一个特定的键的节点列表被称为<strong>首选列表</strong>。</p>

<h2>Data Versioning</h2>

<p>Dynamo 提供最终一致性，允许更新操作异步地传播到所有副本。put 调用可能在更新操作被所有的副本执行之前就返回给调用者，这会导致在随后的 get 操作可能会返回一个不是最新的对象。</p>

<p>Dynamo 将每次数据修改的结果当作一个全新且不可修改的数据版本。它允许同一时间存在多个版本的对象。大多数情况，新版本包括了老的版本，系统自己可以决定权威版本（语法协调 syntactic reconciliation）。然而，在出现失败且伴随并发更新操作的时候，可能导致对象的版本冲突。在这种情况下，系统无法协调，需要由客户端必须执行协调，将多个分支演化后的数据折叠成一个合并的版本（语义协调 semantic reconciliation）。</p>

<p>Dynamo 使用<strong>矢量时钟</strong>来捕捉同一对象不同版本的因果关系。矢量时钟实际上是一系列（节点，计数器）对。一个矢量时钟和每个对象的每个版本相关联。通过审查向量时钟，可以判断一个对象的两个版本是平行或因果顺序。<strong>如果第一个时钟对象上的计数器小于或等于第二个时钟对象上的所有节点，那么第一个是第二个的祖先</strong>，可以被忽略。否则这两个变化是冲突的，需要协调。</p>

<p>在 Dynamo 中，当客户端更新一个对象时必须指定它正要更新哪个版本，这通过从早期的读操作中获得的上下文对象来指定。它包含了向量时钟信息。当处理一个读请求，如果 Dynamo 访问到多个不能语法协调的分支，它将返回处于分支叶子的所有对象。</p>

<h2>Execution of get () and put () operations</h2>

<p><strong>处理读或写操作的节点被称为协调员。</strong>通常，这是首选列表中前 N 个节点中的第一个。如果请求是通过 load balancer 收到，访问 key 的请求可能被路由到环上任一节点。在这种情况下，如果该节点不是请求的 key 的首选列表中前 N 个节点之一，该节点将请求转发到首选列表前 N 个中的第一个节点。</p>

<p>为了保持副本的一致性，Dynamo 使用的一致性协议类似于仲裁（Quorum NRW 模型）。该协议有两个关键配置值：R 和 W。R is the minimum number of nodes that must participate in a successful read operation. W is the minimum number of nodes that must participate in a successful write operation. N 则是数据的副本数量。设定 R 和 W，使得 R + W &gt; N，即<strong>读操作副本加上写操作副本必须大于数据的副本量</strong>。在此模型中，一个 get 或者 put 操作延时是由最慢的 R 或 W 副本决定的。因此 R 和 W 通常配置为小于 Ｎ，以减小时延。</p>

<p>当收到对 key 的 put 请求时，协调员为新版本生成向量时钟并写入本地，然后将新版本（带上向量时钟）发送给首选列表中的前 Ｎ 个可达节点。如果至少 Ｗ-1 个节点返回了响应，那么这个写操作被认为是成功的。</p>

<p>同样，对于 get 请求，协调员从首选列表中前 Ｎ 个可达节点处请求该 key 所有版本的数据，然后等待 Ｒ 个响应，然后返回结果给客户端。如果协调员收到多个版本的数据，它返回所有它认为没有因果关系的版本。</p>

<h2>Handling Failures: Hinted Handoff</h2>

<p>Dynamo 如果使用传统的仲裁方式，在服务器故障和网络分裂的情况下将不可用。因此 Dynamo 使用了<strong>“马虎仲裁”</strong>机制，所有的读，写操作是由首选列表上的前 N 个健康的节点执行的，它们可能不总是在散列环上遇到的那前 N 个节点。</p>

<p>举个例子，如果写操作过程中节点 A 暂时挂掉或不可达，本来发往 A 的副本现在被发送到节点 D。发送到 D 的副本将在其原数据中表明 A 节点才是该副本的预期接收者。接收到的暗示副本将被保存在单独的本地存储中定期扫描。在检测到了 A 已经复苏，D 会尝试发送副本到 A。一旦传送成功，D 可将数据从本地存储中删除，不会降低系统中的副本总数。</p>

<p>数据中心有可能因为断电、冷却装置故障、网络故障或自然灾害发生故障。Dynamo 将每个对象跨多个数据中心地进行复制。从本质上讲，每个个 key 的首选列表的分布在多个数据中心。这些数据中心通过高速网络连接。这种<strong>跨多个数据中心的复制方案</strong>使我们能够处理整个数据中心故障。</p>

<h2>Handling permanent failures: Replica synchronization</h2>

<p>Dynamo 实现了<strong>反熵（anti-entropy 或副本同步）协议</strong>来保持副本同步。</p>

<p>为了更快地检测副本之间的不一致性并减少传输的数据量，<strong>Dynamo 使用 MerkleTree</strong>。MerkleTree 是一个哈希树，其叶子是各个 key 的哈希值，父节点为其各自孩子节点的哈希。MerkleTree 的主要优点是树的每个分支可以独立地检查。另外，MerkleTree 有助于减少为检查副本间不一致而传输的数据的大小。如果两树的根哈希值相等，那么树的叶节点值也相等，该节点不需要同步。</p>

<h2>Membership and Failure Detection</h2>

<p>去中心化的故障检测协议使用一个简单的 Gossip 式的协议，使系统中的每个节点可以了解其他节点加入或离开。详细可以参考论文《On
scalable and efficient distributed failure detectors》</p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2017/12/2017-review/" title="link to 再见，2017">再见，2017</a></h2>
       <p class="excerpt">回看起去年的总结 我的2016，心里挺有感慨的。17 年是出现转机的一年，在这最后一天，按照惯例，整理下这一年的历程和想法。关于自己在去年的时候，我总觉得自己在工作上挺失意的，各种原因下达不到自己的期望。还好，今年在工作方面对自己还算满意。最大的进步是对工作的心态上，不再有一些困惑和纠结。工作上努力去争取有挑战的需求，空闲的时候则抽更多的时间在个人学习上，维持好工作和自学的平衡。我挺喜欢这样的节奏，忙的时候全心全意把工作做好，不忙的时候就把更多的时间投入到自己感兴趣的领域。在经历 16 年...&hellip;</p>
       <div class="post-list__meta"><time datetime="2017-12-31 16:28:17 +0800" class="post-list__meta--date date">2017-12-31</time> &#8226; <span class="post-list__meta--tags tags">随笔</span><a class="btn-border-small" href=/2017/12/2017-review/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2017/12/mit-6824-note-2/" title="link to MIT 6.824 学习笔记（二）">MIT 6.824 学习笔记（二）</a></h2>
       <p class="excerpt">本系列文章是对 MIT 6.824 课程的学习笔记。RaftIntroductionRaft 是用于管理复制日志的一致性算法。为了方便理解，Raft 将一致性算法分解为几个关键模块：Leader 选举、日志复制和安全性，同时通过更强的一致性来减少需要考虑的状态。一致性算法允许一组机器像一个整体一样工作，即使其中一些机器挂掉。一致性算法在构建大规模可信赖系统中扮演重要的角色。Raft 和许多一致性算法类似，但他也有自己的新特性：Strong leaderRaft 使用比其他一致性算法更强的 ...&hellip;</p>
       <div class="post-list__meta"><time datetime="2017-12-02 15:19:31 +0800" class="post-list__meta--date date">2017-12-02</time> &#8226; <span class="post-list__meta--tags tags">读书笔记</span><a class="btn-border-small" href=/2017/12/mit-6824-note-2/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://masutangu.com/2017/12/mit-6824-note-3/";
        this.page.identifier = "/2017/12/mit-6824-note-3/";
    };

    var disqus_shortname = 'masutangu';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">本站由 <a href="http://masutangu.com/">@masutangu</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/Masutangu/Masutangu.github.io">本站源码</a> - &copy; 2018</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-77236140-1', 'masutangu.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
