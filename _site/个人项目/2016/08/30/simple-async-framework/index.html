<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于程序与设计、黑客与画家  这里是 Masutangu 的个人博客。">
    <meta name="keywords"  content="Masutangu, Masutangu 的博客, Masutangu Blog, 博客, 个人网站, 互联网, 后端, Python, Go, C++">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="简单异步应用框架的实现 - Masutangu 的博客 | Masutangu Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="两年前刚进公司的时候，第一次接触了异步框架，那时还处于懵懵懂懂的状态。最近换了组，接触到另外一种实现的异步框架，这次有了一定的积累后，对异步框架的设计也有了更多的理解。刚好最近自己基于 libuv 造了个简单的轮子 saf (Simple Async Framework)，趁此机会和大家聊聊异步框架的设计思想和实现。

">
    
    <meta property="article:published_time" content="2016-08-30T08:14:24Z">
    
    
    
    
    <meta property="og:image" content="http://localhost:4000/img/avatar.jpg">
    <meta property="og:url" content="http://localhost:4000/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/2016/08/30/simple-async-framework/">
    <meta property="og:site_name" content="Masutangu 的博客 | Masutangu Blog">
    
    <title>简单异步应用框架的实现 - Masutangu 的博客 | Masutangu Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/2016/08/30/simple-async-framework/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Masutangu</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
                    
                    
                    
                    
                    <li>
                        <a href="/about/">关于</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">归档</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>简单异步应用框架的实现</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by Masutangu on August 30, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>两年前刚进公司的时候，第一次接触了异步框架，那时还处于懵懵懂懂的状态。最近换了组，接触到另外一种实现的异步框架，这次有了一定的积累后，对异步框架的设计也有了更多的理解。刚好最近自己基于 libuv 造了个简单的轮子 <a href="https://github.com/Masutangu/SAF">saf (Simple Async Framework)</a>，趁此机会和大家聊聊异步框架的设计思想和实现。</p>

<h1 id="异步框架设计思想">异步框架设计思想</h1>
<h2 id="服务器模型">服务器模型</h2>
<p>先来看看传统的服务器模型，如下图：</p>

<p><img src="/assets/images/simple-async-framework/illustration-1.png" width="800" /></p>

<p>一般来说，服务器端可以分为三层：<strong>接入层</strong>，<strong>逻辑层</strong>，<strong>数据层</strong>。接入层负责客户端的接入，逻辑层则实现业务逻辑，数据层就是数据的存储。</p>

<p>简单来说，逻辑层做的事情无非就是解析客户端的请求包，写入数据到数据层或从数据层读取数据，再组装回包发送给客户端。</p>

<p>我们拿微博做例子，用户登录微博，客户端发起拉取首页的请求，server 首先解析客户端请求，拿到用户 id，再根据用户 id 到数据层查询以下数据并拼装回包发回给客户端：</p>

<ul>
  <li>关注数</li>
  <li>粉丝数</li>
  <li>微博数</li>
  <li>个人简介，包括头像</li>
  <li>微博时间轴，即关注的人最近发的微博</li>
</ul>

<h2 id="同步-vs-异步">同步 vs 异步</h2>
<p>继续上面微博的例子，我们假设微博时间轴采用拉的方式去获取。
同步的 server，实现的逻辑如下图：</p>

<p><img src="/assets/images/simple-async-framework/illustration-2.png" width="800" /></p>

<p>如果同步的 server 是单线程，那每次发送请求到数据层查询数据时都会阻塞，在收到数据层的回包前 server 做不了其他事情，CPU 在等待期间空转，非常浪费资源。</p>

<p>异步 server 则不会有这个烦恼，当 server 向数据层发送请求时会立即返回，此时 server 可以处理其它客户端请求，直到数据层返回所请求的数据，通知到 server，server 再继续之前的业务逻辑。流程图大致如下：</p>

<p><img src="/assets/images/simple-async-framework/illustration-3.png" width="800" /></p>

<p>我们再仔细看上面的流程图，可以发现除了拉取微博时间轴需要依赖关注人列表之外，其它数据查询都互不依赖。因此可以把流程优化下：</p>

<p><img src="/assets/images/simple-async-framework/illustration-4.png" width="800" /></p>

<p>通过这样的优化，耗时从</p>

<p><strong>关注数请求耗时 + 粉丝数请求耗时 + 微博数请求耗时 + 个人简介耗时 + 时间轴耗时</strong></p>

<p>缩减到</p>

<p><strong>MAX(关注数请求耗时，粉丝数请求耗时，微博数请求耗时，个人简介耗时) + 时间轴耗时</strong>。</p>

<h2 id="模型抽象化">模型抽象化</h2>
<p>通过上面的例子，来讲讲如何将上述异步处理逻辑抽象化。
我们可以把业务逻辑以<strong>状态（state）</strong>为单位来划分，如下图。<strong>状态与状态之间是串行的</strong>，即你必须执行完一个状态，才会跳转到下一个状态。比如我们必须先拉取关注列表，才能根据关注列表去拉取时间轴。</p>

<p><img src="/assets/images/simple-async-framework/illustration-5.png" width="800" /></p>

<p>而一个状态内可以有很多<strong>动作（action）</strong>，<strong>一个状态内的动作是互相不依赖的，即可以并行执行</strong>，如下图。如我们可以同时发请求拉去关注数，粉丝数，微博数，因为他们之间是互相独立没有依赖的。</p>

<p><img src="/assets/images/simple-async-framework/illustration-6.png" width="800" /></p>

<h1 id="异步框架的实现">异步框架的实现</h1>
<p>讲完了概念，开始来实践。linux 下有 epoll 模型，另外还有大名鼎鼎的 libuv 提供了跨平台的异步 IO。那接下来结合我自己造的轮子，谈谈如何基于 epoll 或 libuv 来实现一个异步框架。</p>

<h2 id="状态保存">状态保存</h2>
<p>无论是函数调用，或者线程切换，都会保存上下文，等到函数调用返回或线程切回来时，才能继续处理之前未完成的逻辑。而我们的异步模型（其实就是状态机），也是类似的道理，我们需要在请求发送时保存好上下文，才能在收到回包时继续之前的逻辑往下走。
saf 是基于 libuv 的，因此我使用 libuv 的 handle 结构体的 data 字段来保存上下文。如果是直接使用 epoll 来实现异步server，则可以用 fd 来绑定上下文（全局的 map，key 为 fd，value 为上下文信息）。</p>

<h2 id="消息透传">消息透传</h2>
<p>既然各个状态是有依赖关系的，那就得有一个消息（message）实体贯穿整个处理流程。通过这个消息实体来传递各个状态所需要的信息。这也是为什么 saf 中 action 和 state 的接口都有一个 msg 参数的原因（见下节<strong>接口设计</strong>）。</p>

<h2 id="接口设计">接口设计</h2>
<p>封装一个异步框架，意味着对于框架使用者来说其无需关心网络收发包的细节，只需关心自身业务逻辑的实现。那我们在设计接口上就需要屏蔽这些细节。</p>

<p>既然要对使用者屏蔽收发包细节，表明收包和发包的回调都由框架来控制。因此我们只需要暴露打包请求包和解包回包的接口给使用者去实现。框架调用使用者实现的打包接口后，将打好的 buffer 发送出去，在收到回包之后，再调用使用者实现的解包接口来处理回包。</p>

<p>在 saf 的接口设计中，我尽量保持接口命名的统一，<code class="highlighter-rouge">prepareProcess</code> 表示在执行前的预处理工作，<code class="highlighter-rouge">afterProcess</code> 表示执行完后的后续处理工作。下面可以看到在不同的模块中，<code class="highlighter-rouge">prepareProcess</code> 和 <code class="highlighter-rouge">afterProcess</code> 的功能略有不同。</p>

<h3 id="消息类">消息类</h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">//msg.h
</span>
<span class="k">class</span> <span class="nc">Msg</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Msg</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>如上所述，消息用于状态之间传递依赖的信息，由业务自行继承添加所需成员。</p>

<h3 id="handler-类">Handler 类</h3>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>    <span class="c1">//handler.h
</span>
    <span class="cm">/*
     * 解析客户端请求包
     * 返回 &gt; 0 表示收包不完整
     * 返回 0 表示解析成功
     * 返回 &lt; 0 表示解包失败, server将会杀掉客户端连接
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * 打包客户端回包到输入 buf 中,len 为输入 buf 长度
     * 返回 &gt; 0 表示 buf 不够, len 为实际需要的 buf 长度
     * 返回 0 表示打包成功, len 为 buf 的实际长度
     * 返回 &lt; 0 表示打包失败, server将会杀掉客户端连接
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * 创建该 handler 的 msg
     */</span>
    <span class="k">virtual</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">createMsg</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Handler 类对应客户端请求的处理流程。业务继承 Handler 基类，实现请求包和回包的打解包接口以及创建业务消息的接口。</p>

<p>在 Handler 的构造函数添加该 Handler 包含的 State。在收到客户端请求后，框架调用相应的 Handler 的 <code class="highlighter-rouge">prepareProcess</code> 接口对客户端请求进行解包。然后依次执行各个 State，全部 State 执行完成后，框架调用该 Handler 的 <code class="highlighter-rouge">afterProcess</code> 将回包打包到传入的 buffer 参数，再由框架将该 buffer 发送回客户端。</p>

<h3 id="state-类">State 类</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>    <span class="c1">// state.h
</span>
    <span class="cm">/*
     * 执行 state 包含的 action 前, 框架会调用该函数, 可以做预处理工作
     * 返回 0 表示成功
     * 返回 != 0 表示失败
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">prepareProcess</span><span class="p">(</span><span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
    <span class="cm">/*
     * state 包含的 action 都执行完时, 框架会调用该函数,可以做一些后续处理工作
     * 返回 0 表示成功
     * 返回 != 0 表示失败
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">afterProcess</span><span class="p">(</span><span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>State 类对应上面<strong>模型抽象化</strong>小节的<strong>状态</strong>。</p>

<p>在 State 的构造函数添加该 State 包含的 Action。State 执行前，框架调用该 State 的 <code class="highlighter-rouge">prepareProcess</code> 接口，使用者可以在该接口做些预处理工作。当 State 执行完成后，框架调用该 State 的 <code class="highlighter-rouge">afterProcess</code> 接口。</p>

<h3 id="action-类">Action 类</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>    <span class="c1">//action.h 
</span>    
    <span class="cm">/*
     * 设置 action 的目的 ip，端口和通信协议（目前只支持tcp） 
     */</span>
    <span class="kt">void</span> <span class="n">setActionInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
    
    <span class="cm">/*
     * 设置 action 的超时时间，单位为毫秒。 &lt;=0 为永不超时
     */</span>
    <span class="kt">void</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span> <span class="p">}</span>  

    <span class="cm">/*
     * 打包 Action 请求包到输入 buf 中, len 为输入 buf 的长度
     * 返回 0 表示打包成功, len 为实际需要的 buf 长度
     * 返回 &gt; 表示 buf 不够, len 为实际需要的 buf 长度
     * 返回 &lt; 0 表示失败
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * 解析 Action 回包
     * 返回 0 表示解析回包成功
     * 返回 &lt; 0 表示出错
     * 返回 &gt; 0 表示收包未完整
     */</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>Action 类对应上面<strong>模型抽象化</strong>小节的<strong>动作</strong>。</p>

<p>Action 执行前，框架调用该 Action 的 <code class="highlighter-rouge">prepareProcess</code> 接口，将 Action 的请求包打包到传入的 buffer 参数，当收到 Action 的回包后，框架会调用 Action 的 <code class="highlighter-rouge">afterProcess</code> 接口，将回包解包。</p>

<h3 id="register_header_parser">REGISTER_HEADER_PARSER</h3>
<p><code class="highlighter-rouge">REGISTER_HEADER_PARSER</code> 宏用于注册解析请求包头函数。</p>

<h3 id="register_handler">REGISTER_HANDLER</h3>
<p><code class="highlighter-rouge">REGISTER_HANDLER</code> 宏用于注册请求对应的 handler 类</p>

<h2 id="状态机逻辑">状态机逻辑</h2>
<p>接下来看看 saf 如何将 handler／state／action 串联起来（代码有所简化）</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>    <span class="c1">//handler.cpp
</span>    <span class="cm">/* 
     * 主逻辑，ClientContext 保存了客户端会话的上下文
     * 其 m_state_idx 成员表示当前所属的状态 id
     * m_action_idx 成员表示处于当前所属状态的动作id
     * m_msg 即业务定义的消息类，被透传给 state 和 action 中
     */</span>  
    <span class="kt">void</span> <span class="n">Handler</span><span class="o">::</span><span class="n">process</span><span class="p">(</span><span class="n">ClientContext</span><span class="o">*</span> <span class="n">c_ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_state_idx</span> <span class="o">&lt;</span> <span class="n">m_state_list</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">State</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="n">m_state_list</span><span class="p">[</span><span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_state_idx</span><span class="o">++</span><span class="p">];</span>
            <span class="c1">// 执行 state 前, 将 action_idx 置 0
</span>            <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_action_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="c1">// 调用 state 的 prepareProcess 接口
</span>            <span class="n">state</span><span class="o">-&gt;</span><span class="n">prepareProcess</span><span class="p">(</span><span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_msg</span><span class="p">);</span>
            <span class="c1">// 开始执行该state
</span>            <span class="n">state</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="n">c_ctx</span><span class="p">);</span>   
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">DEFAULT_BUF_SIZE</span><span class="p">];</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">actual_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">actual_len</span> <span class="o">=</span> <span class="n">DEFAULT_BUF_SIZE</span><span class="p">;</span>
            <span class="c1">// 调用 handler 的 afterProcess 接口，打包回包到 actual_buf 中
</span>            <span class="n">afterProcess</span><span class="p">(</span><span class="n">actual_buf</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_msg</span><span class="p">);</span>
            <span class="c1">// 发送回包给客户端
</span>            <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">sendResponse</span><span class="p">(</span><span class="n">actual_buf</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>    <span class="c1">//state.cpp
</span>
    <span class="cm">/* 
     * state 处理逻辑
     */</span>
    <span class="kt">void</span> <span class="n">State</span><span class="o">::</span><span class="n">process</span><span class="p">(</span><span class="n">ClientContext</span><span class="o">*</span> <span class="n">c_ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果没有action,直接finish
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">m_action_list</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">finish</span><span class="p">(</span><span class="n">c_ctx</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">DEFAULT_BUF_SIZE</span><span class="p">];</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">actual_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">actual_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// buf 的实际长度
</span>        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// 执行该 state 下所有 action 
</span>        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_action_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Action</span><span class="o">*</span> <span class="n">action</span> <span class="o">=</span> <span class="n">m_action_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">actual_len</span> <span class="o">=</span> <span class="n">DEFAULT_BUF_SIZE</span><span class="p">;</span>
            <span class="n">actual_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
            <span class="c1">// 调用 action 的 prepareProcess 接口，打包 action 的请求包到 actual_buf 中
</span>            <span class="n">action</span><span class="o">-&gt;</span><span class="n">prepareProcess</span><span class="p">(</span><span class="n">actual_buf</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_msg</span><span class="p">);</span>
            <span class="c1">// 执行该 action
</span>            <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">processAction</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">actual_buf</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// action 完成后回调该接口，如果所有action都完成，则调用下面的 finish 接口
</span>    <span class="kt">void</span> <span class="n">State</span><span class="o">::</span><span class="n">finishAction</span><span class="p">(</span><span class="n">ClientContext</span><span class="o">*</span> <span class="n">c_ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"finishAction</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_action_idx</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_action_idx</span> <span class="o">&gt;=</span> <span class="n">m_action_list</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">finish</span><span class="p">(</span><span class="n">c_ctx</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 调用 state 所属的 handler 的 process 函数
</span>    <span class="kt">void</span> <span class="n">State</span><span class="o">::</span><span class="n">finish</span><span class="p">(</span><span class="n">ClientContext</span><span class="o">*</span> <span class="n">c_ctx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">afterProcess</span><span class="p">(</span><span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_msg</span><span class="p">);</span>
        <span class="n">m_handler</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="n">c_ctx</span><span class="p">);</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>    <span class="c1">//ClientContext.cpp
</span>
    <span class="cm">/*
     * action 收到回包后的回调
     */</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">recvActionRsp</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="k">const</span> <span class="n">uv_buf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// data 字段保存了 action 的上下文
</span>        <span class="n">ActionContext</span><span class="o">*</span> <span class="n">a_ctx</span> <span class="o">=</span> <span class="p">(</span><span class="n">ActionContext</span><span class="o">*</span><span class="p">)</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">nread</span><span class="p">);</span>
        <span class="c1">// action 的上下文中保存了客户端请求的上下文
</span>        <span class="n">ClientContext</span><span class="o">*</span> <span class="n">c_ctx</span> <span class="o">=</span> <span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">c_ctx</span><span class="p">;</span>
        <span class="c1">// 调用 action 的 afterProcess 接口
</span>        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">afterProcess</span><span class="p">(</span><span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">recv_buf</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span> <span class="n">c_ctx</span><span class="o">-&gt;</span><span class="n">m_msg</span><span class="p">);</span>
        <span class="c1">// 通知 action 所属的 state 该 action 完成了
</span>        <span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">action</span><span class="o">-&gt;</span><span class="n">m_state</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">(</span><span class="n">a_ctx</span><span class="o">-&gt;</span><span class="n">c_ctx</span><span class="p">);</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="样例">样例</h2>
<p>以下是 saf 的一个简单的 <a href="https://github.com/Masutangu/SAF/blob/master/sample.cpp">demo</a>。代码仅说明用，所以比较简单粗暴。该 server 的所有请求都由 myHandler 来处理，myHandler 包含一个状态 myState1。myState1 包含一个 Action, 该 Action 将客户端请求包拷贝并通过 tcp 发送给 127.0.0.1:7000 的服务，接收到回包后再把回包原样发回给客户端。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre></td><td class="rouge-code"><pre><span class="c1">//
// Created by Masutangu on 16/8/9.
//
</span>
<span class="cp">#include "saf/header.h"
</span>
<span class="cp">#include &lt;cstring&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">saf</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">BUF_SIZE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">myMsg</span><span class="o">:</span> <span class="k">public</span> <span class="n">Msg</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">char</span> <span class="n">readbuf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">writebuf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">myAction</span><span class="o">:</span> <span class="k">public</span> <span class="n">Action</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">myAction</span><span class="o">::</span><span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">myMsg</span><span class="o">*</span> <span class="n">my_msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">myMsg</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"myAction prepareProcess, data: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_msg</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">my_msg</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">BUF_SIZE</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">BUF_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">myAction</span><span class="o">::</span><span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"myAction afterProcess: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">myMsg</span><span class="o">*</span> <span class="n">my_msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">myMsg</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">my_msg</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">BUF_SIZE</span> <span class="o">?</span> <span class="n">len</span><span class="o">:</span><span class="n">BUF_SIZE</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">myState1</span><span class="o">:</span> <span class="k">public</span> <span class="n">State</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myState1</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">myState1</span><span class="o">::</span><span class="n">myState1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">myAction</span><span class="o">*</span> <span class="n">action</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myAction</span><span class="p">;</span>
    <span class="n">action</span><span class="o">-&gt;</span><span class="n">setActionInfo</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">7000</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//设置action的ip和端口
</span>    <span class="n">addAction</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">myHandler</span><span class="o">:</span> <span class="k">public</span> <span class="n">Handler</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">myHandler</span><span class="p">();</span>
    <span class="n">Msg</span><span class="o">*</span> <span class="n">createMsg</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>

<span class="p">};</span>

<span class="n">Msg</span><span class="o">*</span> <span class="n">myHandler</span><span class="o">::</span><span class="n">createMsg</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">myMsg</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">myHandler</span><span class="o">::</span><span class="n">myHandler</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">myState1</span><span class="o">*</span> <span class="n">state1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myState1</span><span class="p">();</span>
    <span class="n">addState</span><span class="p">(</span><span class="n">state1</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">myHandler</span><span class="o">::</span><span class="n">prepareProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"handler: prepareProcess len=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">myMsg</span><span class="o">*</span> <span class="n">my_msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">myMsg</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">my_msg</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">myHandler</span><span class="o">::</span><span class="n">afterProcess</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">len</span><span class="p">,</span> <span class="n">Msg</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">myMsg</span><span class="o">*</span> <span class="n">my_msg</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">myMsg</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">my_msg</span><span class="o">-&gt;</span><span class="n">writebuf</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">parseReq</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 该请求的类型为 1，由 myHandler 处理
</span><span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">REGISTER_HANDLER</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">myHandler</span><span class="p">);</span>  <span class="c1">// 请求类型为 1 的由 myHandler 类处理
</span>    <span class="n">REGISTER_HEADER_PARSER</span><span class="p">(</span><span class="n">parseReq</span><span class="p">);</span> <span class="c1">// 请求包头由 parseReq 函数解析
</span>
    <span class="n">AsyncServer</span> <span class="n">server</span> <span class="o">=</span> <span class="n">AsyncServer</span><span class="p">();</span>
    <span class="n">server</span><span class="p">.</span><span class="n">setBindAddress</span><span class="p">(</span><span class="s">"0.0.0.0"</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span> <span class="c1">// 监听 8000 端口
</span>    <span class="n">server</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="总结">总结</h1>
<p>由于时间和能力有限，saf 目前来说非常简陋，也没有经过严格的测试。对于一个框架来说，要做的事情还有很多，比如日志模块的完善、性能分析和优化。不过，<strong>done is better than perfect</strong>. 最后，如有问题或意见，欢迎留言或者 email 我，也欢迎转载分享～</p>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/%E5%B7%A5%E4%BD%9C/2016/07/13/conclusion-of-two-years/" data-toggle="tooltip" data-placement="top" title="工作两年记">
                        Previous<br>
                        <span>工作两年记</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/2016/09/03/talk-about-protobuf/" data-toggle="tooltip" data-placement="top" title="Protobuf 编码原理">
                        Next<br>
                        <span>Protobuf 编码原理</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://blog.zhiheng.io">onlyice</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/masutangu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://www.instagram.com/masutanguu">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Masutangu 2018
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-77236140-1';
    var _gaDomain = 'masutangu.com';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
